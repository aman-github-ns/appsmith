"use strict";(self.webpackChunkappsmith=self.webpackChunkappsmith||[]).push([[9080],{48208:function(n,e,t){t.d(e,{N2:function(){return i},YA:function(){return s},eL:function(){return l},f2:function(){return d},ou:function(){return a},sp:function(){return r},uf:function(){return o},y4:function(){return c}});var o={READY:"READY",READY_ACK:"READY_ACK",UPDATE_SRCDOC:"UPDATE_SRCDOC",UPDATE_REFERENCES:"UPDATE_REFERENCES",UPDATE_REFERENCES_ACK:"UPDATE_REFERENCES_ACK",PAUSE:"PAUSE",RESUME:"RESUME",DISCONNECTED:"DISCONNECTED",CLOSE:"CLOSE"},s="custom-widget-builder-context-state-is-reference-open",a="custom-widget-builder-context-state-selected-layout",i={name:"",widgetId:"",srcDoc:{html:"",js:"",css:""},uncompiledSrcDoc:{html:"",js:"",css:""},model:{},events:{},key:Math.random(),isReferenceOpen:!1,selectedLayout:"tabs",debuggerLogs:[],showConnectionLostMessage:!1,theme:{colors:{primaryColor:"",backgroundColor:""},borderRadius:{appBorderRadius:""},boxShadow:{appBoxShadow:""},fontFamily:{appFontFamily:""}}},r="https://docs.appsmith.com/reference/widgets/custom",d="".concat(r,"#default-model"),c="".concat(r,"#onready"),l="".concat(r,"#height")},8162:function(n,e,t){t.d(e,{Z:function(){return k}});var o=t(1413),s=t(29439),a=t(30168),i=t(50390),r=t(62608),d=t(44977),c=t(97626),l=t(95765),u=t(81591),h=t(61575),p=t(77271),E="CUSTOM_WIDGET_READY",m="CUSTOM_WIDGET_READY_ACK",f="CUSTOM_WIDGET_UPDATE_MODEL",g="CUSTOM_WIDGET_TRIGGER_EVENT",T="CUSTOM_WIDGET_MODEL_CHANGE",b="CUSTOM_WIDGET_UI_CHANGE",_="CUSTOM_WIDGET_MESSAGE_RECEIVED_ACK",w="CUSTOM_WIDGET_THEME_UPDATE",v="CUSTOM_WIDGET_UPDATE_HEIGHT";var C,y,M,S=t(73010),D=t(93782),O=t(6191),I=t(23994),U=t(64395),A=t(62559),G=r.ZP.iframe(C||(C=(0,a.Z)(["\n  width: ","px;\n  height: ","px;\n  min-height: ","px;\n"])),(function(n){return n.componentWidth}),(function(n){return n.componentHeight}),(function(n){return n.componentMinHeight})),R=r.ZP.div(y||(y=(0,a.Z)(["\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n"]))),W=r.ZP.div(M||(M=(0,a.Z)(["\n  height: 100%;\n  width: 100%;\n"]))),x=(0,D.x)().disableIframeWidgetSandbox;var k=(0,l.$j)((function(n,e){var t,o=(0,u.ew)(n);return{needsOverlay:"EDITOR"===e.renderMode&&!o&&e.widgetId!==(null===(t=(0,h.nO)(n))||void 0===t?void 0:t.widgetId)||(0,O.h)(n)}}))((function(n){var e=(0,i.useRef)(null),t=i.useState(!0),a=(0,s.Z)(t,2),r=a[0],l=a[1],u=(0,i.useState)(!1),h=(0,s.Z)(u,2),C=h[0],y=h[1],M=(0,i.useState)(n.height),D=(0,s.Z)(M,2),O=D[0],k=D[1],H=(0,i.useMemo)((function(){var e,t,s,a,i;return(0,o.Z)((0,o.Z)({},null===(e=n.theme)||void 0===e?void 0:e.colors),{},{borderRadius:null===(t=n.theme)||void 0===t||null===(s=t.borderRadius)||void 0===s?void 0:s.appBorderRadius,boxShadow:null===(a=n.theme)||void 0===a||null===(i=a.boxShadow)||void 0===i?void 0:i.appBoxShadow})}),[n.theme]);(0,i.useEffect)((function(){var t=function(t){var o,s,a,i,r,d=(null===(o=e.current)||void 0===o?void 0:o.contentWindow)||(null===(s=e.current)||void 0===s||null===(a=s.contentDocument)||void 0===a?void 0:a.defaultView);if(t.source===d){var c,l;null===(c=e.current)||void 0===c||null===(l=c.contentWindow)||void 0===l||l.postMessage({type:_,key:t.data.key,success:!0},"*");var u=t.data;switch(u.type){case E:y(!0),null===(i=e.current)||void 0===i||null===(r=i.contentWindow)||void 0===r||r.postMessage({type:m,model:n.model,ui:{width:n.width,height:n.height},mode:n.renderMode,theme:H},"*"),"DEPLOYED"!==n.renderMode&&"EDITOR"!==n.renderMode||p.ZP.logEvent("CUSTOM_WIDGET_LOAD_INIT",{widgetId:n.widgetId,renderMode:n.renderMode});break;case f:n.update(u.data);break;case g:n.execute(u.data.eventName,u.data.contextObj);break;case v:var h,T=u.data.height;if("BUILDER"!==n.renderMode&&T&&(n.dynamicHeight!==S.Hc.FIXED||n.layoutSystemType===U.f.AUTO))null===(h=e.current)||void 0===h||h.style.setProperty("height","".concat(T,"px")),k(T);break;case"CUSTOM_WIDGET_CONSOLE_EVENT":n.onConsole&&n.onConsole(u.data.type,u.data.args)}}};return window.addEventListener("message",t,!1),function(){return window.removeEventListener("message",t,!1)}}),[n.model,n.width,n.height,n.layoutSystemType,n.dynamicHeight]),(0,i.useEffect)((function(){e.current&&e.current.contentWindow&&C&&e.current.contentWindow.postMessage({type:T,model:n.model},"*")}),[n.model]),(0,i.useEffect)((function(){e.current&&e.current.contentWindow&&C&&e.current.contentWindow.postMessage({type:b,ui:{width:n.width,height:O}},"*")}),[n.width,O]),(0,i.useEffect)((function(){e.current&&e.current.contentWindow&&C&&e.current.contentWindow.postMessage({type:w,theme:H},"*")}),[H]),(0,i.useEffect)((function(){var t;n.dynamicHeight===S.Hc.FIXED&&n.layoutSystemType===U.f.FIXED&&(null===(t=e.current)||void 0===t||t.style.setProperty("height","".concat(n.height,"px")),k(n.height))}),[n.dynamicHeight,n.height,e.current,n.layoutSystemType]);var N="\n    <html>\n      <head>\n        <style>".concat('/* http://meyerweb.com/eric/tools/css/reset/ \n   v2.0 | 20110126\n   License: none (public domain)\n*/\n\nhtml,\nbody,\ndiv,\nspan,\napplet,\nobject,\niframe,\nh1,\nh2,\nh3,\nh4,\nh5,\nh6,\np,\nblockquote,\npre,\na,\nabbr,\nacronym,\naddress,\nbig,\ncite,\ncode,\ndel,\ndfn,\nem,\nimg,\nins,\nkbd,\nq,\ns,\nsamp,\nsmall,\nstrike,\nstrong,\nsub,\nsup,\ntt,\nvar,\nb,\nu,\ni,\ncenter,\ndl,\ndt,\ndd,\nol,\nul,\nli,\nfieldset,\nform,\nlabel,\nlegend,\ntable,\ncaption,\ntbody,\ntfoot,\nthead,\ntr,\nth,\ntd,\narticle,\naside,\ncanvas,\ndetails,\nembed,\nfigure,\nfigcaption,\nfooter,\nheader,\nhgroup,\nmenu,\nnav,\noutput,\nruby,\nsection,\nsummary,\ntime,\nmark,\naudio,\nvideo {\n  margin: 0;\n  padding: 0;\n  border: 0;\n}\n/* HTML5 display-role reset for older browsers */\narticle,\naside,\ndetails,\nfigcaption,\nfigure,\nfooter,\nheader,\nhgroup,\nmenu,\nnav,\nsection {\n  display: block;\n}\nbody {\n  line-height: 1;\n}\nol,\nul {\n  list-style: none;\n}\nblockquote,\nq {\n  quotes: none;\n}\nblockquote:before,\nblockquote:after,\nq:before,\nq:after {\n  content: "";\n  content: none;\n}\ntable {\n  border-collapse: collapse;\n  border-spacing: 0;\n}\n','</style>\n      </head>\n      <body>\n        <script type="text/javascript">').concat(n.onConsole?'(function (nativeConsole) {\n  const postMessage = (method, args) => {\n    window.parent.postMessage(\n      {\n        type: "CUSTOM_WIDGET_CONSOLE_EVENT",\n        data: {\n          type: method,\n          args: args.map((d) => ({\n            message: d,\n          })),\n        },\n      },\n      "*",\n    );\n  };\n\n  const createProxy = (method) =>\n    new Proxy(nativeConsole[method], {\n      apply(target, _this, args) {\n        try {\n          postMessage(method, args);\n        } finally {\n          return Reflect.apply(target, _this, args);\n        }\n      },\n    });\n\n  ["log", "warn", "info"].forEach((method) => {\n    nativeConsole[method] = createProxy(method);\n  });\n\n  window.addEventListener("error", (event) => {\n    postMessage("error", [event.message]);\n  });\n})(window.console);\n':"",'<\/script>\n        <script type="module">\n          ').concat('// Custom widget events definition\nexport const EVENTS = {\n  CUSTOM_WIDGET_READY: "CUSTOM_WIDGET_READY",\n  CUSTOM_WIDGET_READY_ACK: "CUSTOM_WIDGET_READY_ACK",\n  CUSTOM_WIDGET_UPDATE_MODEL: "CUSTOM_WIDGET_UPDATE_MODEL",\n  CUSTOM_WIDGET_TRIGGER_EVENT: "CUSTOM_WIDGET_TRIGGER_EVENT",\n  CUSTOM_WIDGET_MODEL_CHANGE: "CUSTOM_WIDGET_MODEL_CHANGE",\n  CUSTOM_WIDGET_UI_CHANGE: "CUSTOM_WIDGET_UI_CHANGE",\n  CUSTOM_WIDGET_MESSAGE_RECEIVED_ACK: "CUSTOM_WIDGET_MESSAGE_RECEIVED_ACK",\n  CUSTOM_WIDGET_CONSOLE_EVENT: "CUSTOM_WIDGET_CONSOLE_EVENT",\n  CUSTOM_WIDGET_THEME_UPDATE: "CUSTOM_WIDGET_THEME_UPDATE",\n  CUSTOM_WIDGET_UPDATE_HEIGHT: "CUSTOM_WIDGET_UPDATE_HEIGHT",\n};\n\n// Function to create a communication channel to the parent\nexport const createChannelToParent = () => {\n  const onMessageMap = new Map();\n  // Function to register an event handler for a message type\n  function onMessage(type, fn) {\n    let eventHandlerList = onMessageMap.get(type);\n    if (eventHandlerList && eventHandlerList instanceof Array) {\n      eventHandlerList.push(fn);\n    } else {\n      eventHandlerList = [fn];\n      onMessageMap.set(type, eventHandlerList);\n    }\n    return () => {\n      // Function to unsubscribe an event handler\n      const index = eventHandlerList.indexOf(fn);\n      eventHandlerList.splice(index, 1);\n    };\n  }\n  // Listen for \'message\' events and dispatch to registered event handlers\n  window.addEventListener("message", (event) => {\n    if (event.source === window.parent) {\n      const handlerList = onMessageMap.get(event.data.type);\n      if (handlerList) {\n        handlerList.forEach((fn) => fn(event.data));\n      }\n    }\n  });\n  // Queue to hold postMessage requests\n  const postMessageQueue = [];\n  // Flag to indicate if the flush is scheduled\n  let isFlushScheduled = false;\n\n  /*\n   * Function to schedule microtask to flush postMessageQueue\n   * to ensure the order of message processed on the parent\n   */\n  const scheduleMicrotaskToflushPostMessageQueue = () => {\n    if (!isFlushScheduled) {\n      isFlushScheduled = true;\n      queueMicrotask(() => {\n        (async () => {\n          while (postMessageQueue.length > 0) {\n            const message = postMessageQueue.shift();\n            await new Promise((resolve) => {\n              const key = Math.random();\n              const unlisten = onMessage(\n                EVENTS.CUSTOM_WIDGET_MESSAGE_RECEIVED_ACK,\n                (data) => {\n                  if (data.key === key && data.success) {\n                    unlisten();\n                    resolve();\n                  }\n                },\n              );\n\n              // Send the message to the parent\n              window.parent.postMessage(\n                Object.assign(Object.assign({}, message), { key }),\n                "*",\n              );\n            });\n          }\n          isFlushScheduled = false;\n        })();\n      });\n    }\n  };\n\n  return {\n    onMessageMap,\n    postMessage: (type, data) => {\n      try {\n        // Try block to catch non clonealbe data error while postmessaging\n        // throw error if the data is not cloneable\n        postMessageQueue.push({\n          type,\n          data,\n        });\n\n        scheduleMicrotaskToflushPostMessageQueue();\n      } catch (e) {\n        throw e;\n      }\n    },\n    onMessage,\n  };\n};\n\n/*\n * Function to initialize the script\n * wrapping this inside a function to make it testable\n */\nexport function main() {\n  // Create a communication channel to the parent\n  const channel = createChannelToParent();\n  /*\n   * Variables to hold the subscriber functions\n   */\n  const modelSubscribers = [];\n  const uiSubscribers = [];\n  const themeSubscribers = [];\n  /*\n   * Variables to hold ready function and state\n   */\n  let onReady;\n  let isReady = false;\n  let isReadyCalled = false;\n\n  const heightObserver = new ResizeObserver(() => {\n    const height = document.body.clientHeight;\n\n    channel.postMessage(EVENTS.CUSTOM_WIDGET_UPDATE_HEIGHT, {\n      height,\n    });\n  });\n\n  // Callback for when the READY_ACK message is received\n  channel.onMessage(EVENTS.CUSTOM_WIDGET_READY_ACK, (event) => {\n    window.appsmith.model = event.model;\n    window.appsmith.ui = event.ui;\n    window.appsmith.theme = event.theme;\n    window.appsmith.mode = event.mode;\n    heightObserver.observe(window.document.body);\n\n    // Subscribe to model and UI changes\n    window.appsmith.onModelChange(generateAppsmithCssVariables("model"));\n    window.appsmith.onUiChange(generateAppsmithCssVariables("ui"));\n    window.appsmith.onThemeChange(generateAppsmithCssVariables("theme"));\n\n    // Set the widget as ready\n    isReady = true;\n\n    if (!isReadyCalled && onReady) {\n      onReady();\n      isReadyCalled = true;\n    }\n  });\n  // Callback for when MODEL_CHANGE message is received\n  channel.onMessage(EVENTS.CUSTOM_WIDGET_MODEL_CHANGE, (event) => {\n    if (event.model) {\n      const prevModel = window.appsmith.model;\n\n      window.appsmith.model = event.model;\n\n      // Notify model subscribers\n      modelSubscribers.forEach((fn) => {\n        fn(event.model, prevModel);\n      });\n    }\n  });\n  // Callback for when UI_CHANGE message is received\n  channel.onMessage(EVENTS.CUSTOM_WIDGET_UI_CHANGE, (event) => {\n    if (event.ui) {\n      const prevUi = window.appsmith.ui;\n\n      window.appsmith.ui = event.ui;\n      // Notify UI subscribers\n      uiSubscribers.forEach((fn) => {\n        fn(event.ui, prevUi);\n      });\n    }\n  });\n\n  channel.onMessage(EVENTS.CUSTOM_WIDGET_THEME_UPDATE, (event) => {\n    if (event.theme) {\n      const prevTheme = window.appsmith.theme;\n\n      window.appsmith.theme = event.theme;\n      // Notify theme subscribers\n      themeSubscribers.forEach((fn) => {\n        fn(event.theme, prevTheme);\n      });\n    }\n  });\n\n  if (!window.appsmith) {\n    // Define appsmith global object\n    Object.defineProperty(window, "appsmith", {\n      configurable: false,\n      writable: false,\n      value: {\n        mode: "",\n        theme: {},\n        onThemeChange: (fn) => {\n          if (typeof fn !== "function") {\n            throw new Error("onThemeChange expects a function as parameter");\n          }\n\n          themeSubscribers.push(fn);\n          fn(window.appsmith.theme);\n\n          return () => {\n            // Unsubscribe from theme changes\n            const index = themeSubscribers.indexOf(fn);\n\n            if (index > -1) {\n              themeSubscribers.splice(index, 1);\n            }\n          };\n        },\n        onUiChange: (fn) => {\n          if (typeof fn !== "function") {\n            throw new Error("onUiChange expects a function as parameter");\n          }\n\n          uiSubscribers.push(fn);\n          fn(window.appsmith.ui);\n          return () => {\n            // Unsubscribe from UI changes\n            const index = uiSubscribers.indexOf(fn);\n            if (index > -1) {\n              uiSubscribers.splice(index, 1);\n            }\n          };\n        },\n        onModelChange: (fn) => {\n          if (typeof fn !== "function") {\n            throw new Error("onModelChange expects a function as parameter");\n          }\n\n          modelSubscribers.push(fn);\n          fn(window.appsmith.model);\n          return () => {\n            // Unsubscribe from model changes\n            const index = modelSubscribers.indexOf(fn);\n            if (index > -1) {\n              modelSubscribers.splice(index, 1);\n            }\n          };\n        },\n        updateModel: (obj) => {\n          if (!obj || typeof obj !== "object") {\n            throw new Error("updateModel expects an object as parameter");\n          }\n\n          appsmith.model = Object.assign(\n            Object.assign({}, appsmith.model),\n            obj,\n          );\n\n          // Send an update model message to the parent\n          channel.postMessage(EVENTS.CUSTOM_WIDGET_UPDATE_MODEL, obj);\n        },\n        triggerEvent: (eventName, contextObj) => {\n          if (typeof eventName !== "string") {\n            throw new Error("eventName should be a string");\n          } else if (contextObj && typeof contextObj !== "object") {\n            throw new Error("contextObj should be an object");\n          }\n\n          // Send a trigger event message to the parent\n          channel.postMessage(EVENTS.CUSTOM_WIDGET_TRIGGER_EVENT, {\n            eventName,\n            contextObj,\n          });\n        },\n        model: {},\n        ui: {},\n        onReady: (fn) => {\n          if (typeof fn !== "function") {\n            throw new Error("onReady expects a function as parameter");\n          }\n\n          onReady = fn;\n\n          if (isReady && !isReadyCalled && onReady) {\n            onReady();\n            isReadyCalled = true;\n          }\n        },\n      },\n    });\n  }\n\n  // Listen for the \'load\' event and send READY message to the parent\n  window.addEventListener("load", () => {\n    channel.postMessage(EVENTS.CUSTOM_WIDGET_READY);\n  });\n}\n\n/*\n * Function to create appsmith css variables for model and ui primitive values\n * variables get regenerated every time the model or ui changes.\n */\nexport const generateAppsmithCssVariables = (provider) => (source) => {\n  let cssTokens = document.getElementById(`appsmith-${provider}-css-tokens`);\n  if (!cssTokens) {\n    cssTokens = document.createElement("style");\n    cssTokens.id = `appsmith-${provider}-css-tokens`;\n    window.document.head.appendChild(cssTokens);\n  }\n\n  const cssTokensContent = Object.keys(source).reduce((acc, key) => {\n    if (typeof source[key] === "string" || typeof source[key] === "number") {\n      return `\n    ${acc}\n    --appsmith-${provider}-${key}: ${source[key]};\n    `;\n    } else {\n      return acc;\n    }\n  }, "");\n  cssTokens.innerHTML = `:root {${cssTokensContent}}`;\n};\n',"\n          main();\n        <\/script>\n        ").concat(n.srcDoc.html,'\n        <script type="module">\n          ').concat(n.srcDoc.js,"\n        <\/script>\n        <style>").concat(n.srcDoc.css,"</style>\n      </body>\n    </html>\n  ");return(0,i.useEffect)((function(){l(!0)}),[N]),(0,A.jsxs)(W,{className:(0,d.Z)({"bp3-skeleton":r}),children:[n.needsOverlay&&(0,A.jsx)(R,{"data-testid":"iframe-overlay"}),(0,A.jsx)(c.Z,{backgroundColor:n.backgroundColor,borderColor:n.borderColor,borderRadius:n.borderRadius,borderWidth:n.borderWidth,boxShadow:n.boxShadow,widgetId:n.widgetId,children:(0,A.jsx)(G,{componentHeight:O,componentMinHeight:n.dynamicHeight===S.Hc.AUTO_HEIGHT_WITH_LIMITS?n.minDynamicHeight*I.cJ.DEFAULT_GRID_ROW_HEIGHT:0,componentWidth:n.width,loading:"lazy",onLoad:function(){l(!1)},ref:e,sandbox:x?void 0:"allow-forms allow-modals allow-orientation-lock allow-pointer-lock allow-popups allow-scripts",srcDoc:N})})]})}))}}]);
//# sourceMappingURL=9080.97a7b2d2.chunk.js.map