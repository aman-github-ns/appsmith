{"version":3,"file":"static/js/spa-aggregate.e4393f88.chunk.js","mappings":"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","sources":["../node_modules/@newrelic/browser-agent/dist/esm/common/deny-list/deny-list.js","../node_modules/@newrelic/browser-agent/dist/esm/common/harvest/harvest-scheduler.js","../node_modules/@newrelic/browser-agent/dist/esm/common/serialize/bel-serializer.js","../node_modules/@newrelic/browser-agent/dist/esm/common/timing/nav-timing.js","../node_modules/@newrelic/browser-agent/dist/esm/common/unload/eol.js","../node_modules/@newrelic/browser-agent/dist/esm/features/spa/aggregate/interaction-node.js","../node_modules/@newrelic/browser-agent/dist/esm/features/spa/aggregate/interaction.js","../node_modules/@newrelic/browser-agent/dist/esm/features/spa/aggregate/serializer.js","../node_modules/@newrelic/browser-agent/dist/esm/features/spa/aggregate/index.js"],"sourcesContent":["/** An array of filter objects {hostname, pathname} for identifying XHR events to be excluded from collection.\n * @see {@link https://docs.newrelic.com/docs/browser/new-relic-browser/configuration/filter-ajax-request-events/ Filter AjaxRequest events}\n * @type {Array.<{hostname: string, pathname: string}>}\n */\nvar denyList = [];\n\n/**\n * Evaluates whether an XHR event should be included for collection based on the {@link denyList|AjaxRequest deny list}.\n * @param {Object} params - object with properties of the XHR event\n * @returns {boolean} `true` if request does not match any entries of {@link denyList|deny list}; else `false`\n */\nexport function shouldCollectEvent(params) {\n  if (denyList.length === 0) {\n    return true;\n  }\n\n  // XHR requests with an undefined hostname (e.g., data URLs) should not be collected.\n  if (params.hostname === undefined) {\n    return false;\n  }\n  for (var i = 0; i < denyList.length; i++) {\n    var parsed = denyList[i];\n    if (parsed.hostname === '*') {\n      return false;\n    }\n    if (domainMatchesPattern(parsed.hostname, params.hostname) && comparePath(parsed.pathname, params.pathname)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Initializes the {@link denyList|XHR deny list} by extracting hostname and pathname from an array of filter strings.\n * @param {string[]} denyListConfig - array of URL filters to identify XHR requests to be excluded from collection\n */\nexport function setDenyList(denyListConfig) {\n  denyList = [];\n  if (!denyListConfig || !denyListConfig.length) {\n    return;\n  }\n  for (var i = 0; i < denyListConfig.length; i++) {\n    let url = denyListConfig[i];\n    if (!url) continue; // ignore bad values like undefined or empty strings\n\n    if (url.indexOf('http://') === 0) {\n      url = url.substring(7);\n    } else if (url.indexOf('https://') === 0) {\n      url = url.substring(8);\n    }\n    const firstSlash = url.indexOf('/');\n    let host, pathname;\n    if (firstSlash > 0) {\n      host = url.substring(0, firstSlash);\n      pathname = url.substring(firstSlash);\n    } else {\n      host = url;\n      pathname = '';\n    }\n    let [hostname] = host.split(':');\n    denyList.push({\n      hostname,\n      pathname\n    });\n  }\n}\n/**\n * Returns true if the right side of `domain` (end of string) matches `pattern`.\n * @param {string} pattern - a string to be matched against the end of `domain` string\n * @param {string} domain - a domain string with no protocol or path (e.g., app1.example.com)\n * @returns {boolean} `true` if domain matches pattern; else `false`\n */\nfunction domainMatchesPattern(pattern, domain) {\n  if (pattern.length > domain.length) {\n    return false;\n  }\n  return domain.indexOf(pattern) === domain.length - pattern.length;\n}\n\n/**\n * Returns true if a URL path matches a pattern string, disregarding leading slashes.\n * @param {string} pattern - a string to compare with path (e.g., api/v1)\n * @param {string} path - a string representing a URL path (e.g., /api/v1)\n * @returns {boolean} `true` if path and pattern are an exact string match (except for leading slashes); else `false`\n */\nfunction comparePath(pattern, path) {\n  if (pattern.indexOf('/') === 0) {\n    pattern = pattern.substring(1);\n  }\n  if (path.indexOf('/') === 0) {\n    path = path.substring(1);\n  }\n\n  // No path in pattern means match all paths.\n  if (pattern === '') {\n    return true;\n  }\n  return pattern === path;\n}","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as submitData from '../util/submit-data';\nimport { SharedContext } from '../context/shared-context';\nimport { Harvest } from './harvest';\nimport { subscribeToEOL } from '../unload/eol';\nimport { SESSION_EVENTS } from '../session/constants';\n\n/**\n * Periodically invokes harvest calls and handles retries\n */\nexport class HarvestScheduler extends SharedContext {\n  /**\n     * Create a HarvestScheduler\n     * @param {string} endpoint - The base BAM endpoint name -- ex. 'events'\n     * @param {object} opts - The options used to configure the HarvestScheduler\n     * @param {Function} opts.onFinished - The callback to be fired when a harvest has finished\n     * @param {Function} opts.getPayload - A callback which can be triggered to return a payload for harvesting\n     * @param {number} opts.retryDelay - The number of seconds to wait before retrying after a network failure\n     * @param {boolean} opts.raw - Use a prefabricated payload shape as the harvest payload without the need for formatting\n     * @param {string} opts.customUrl - A custom url that falls outside of the shape of the standard BAM harvester url pattern.  Will use directly instead of concatenating various pieces\n     * @param {*} parent - The parent object, whose state can be passed into SharedContext\n     */\n  constructor(endpoint, opts, parent) {\n    super(parent); // gets any allowed properties from the parent and stores them in `sharedContext`\n    this.endpoint = endpoint;\n    this.opts = opts || {};\n    this.started = false;\n    this.timeoutHandle = null;\n    this.aborted = false; // this controls the per-interval and final harvests for the scheduler (currently per feature specific!)\n\n    this.harvest = new Harvest(this.sharedContext);\n\n    // unload if EOL mechanism fires\n    subscribeToEOL(this.unload.bind(this));\n\n    /* Flush all buffered data if session resets and give up retries. This should be synchronous to ensure that the correct `session` value is sent.\n      Since session-reset generates a new session ID and the ID is grabbed at send-time, any delays or retries would cause the payload to be sent under\n      the wrong session ID. */\n    this.sharedContext?.ee.on(SESSION_EVENTS.RESET, () => this.runHarvest({\n      forceNoRetry: true\n    }));\n  }\n\n  /**\n   * This function is only meant for the last outgoing harvest cycle of a page. It trickles down to using sendBeacon, which should not be used\n   * to send payloads while the page is still active, due to limitations on how much data can be buffered in the API at any one time.\n   */\n  unload() {\n    if (this.aborted) return;\n    // If opts.onUnload is defined, these are special actions to execute before attempting to send the final payload.\n    if (this.opts.onUnload) this.opts.onUnload();\n    this.runHarvest({\n      unload: true\n    });\n  }\n  startTimer(interval, initialDelay) {\n    this.interval = interval;\n    this.started = true;\n    this.scheduleHarvest(initialDelay != null ? initialDelay : this.interval);\n  }\n  stopTimer() {\n    let permanently = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    this.aborted = permanently; // stopping permanently is same as aborting, but this function also cleans up the setTimeout loop\n    this.started = false;\n    if (this.timeoutHandle) {\n      clearTimeout(this.timeoutHandle);\n    }\n  }\n  scheduleHarvest(delay, opts) {\n    if (this.timeoutHandle) return;\n    if (delay == null) {\n      delay = this.interval;\n    }\n    this.timeoutHandle = setTimeout(() => {\n      this.timeoutHandle = null;\n      this.runHarvest(opts);\n    }, delay * 1000);\n  }\n  runHarvest(opts) {\n    if (this.aborted) return;\n\n    /**\n     * This is executed immediately after harvest sends the data via XHR, or if there's nothing to send. Note that this excludes on unloading / sendBeacon.\n     * @param {Object} result\n     */\n    const cbRanAfterSend = result => {\n      if (opts?.forceNoRetry) result.retry = false; // discard unsent data rather than re-queuing for next harvest attempt\n      this.onHarvestFinished(opts, result);\n    };\n    let harvests = [];\n    let submitMethod;\n    let payload;\n    if (this.opts.getPayload) {\n      // Ajax & PVT & SR features provide a callback function to get data for harvesting\n      submitMethod = submitData.getSubmitMethod({\n        isFinalHarvest: opts?.unload\n      });\n      if (!submitMethod) return false;\n      const retry = !opts?.unload && submitMethod === submitData.xhr;\n      payload = this.opts.getPayload({\n        retry,\n        opts\n      });\n      if (!payload) {\n        if (this.started) {\n          this.scheduleHarvest();\n        }\n        return;\n      }\n      payload = Object.prototype.toString.call(payload) === '[object Array]' ? payload : [payload];\n      harvests.push(...payload);\n    }\n\n    /** sendX is used for features that do not supply a preformatted payload via \"getPayload\" */\n    let send = args => this.harvest.sendX(args);\n    if (harvests.length) {\n      /** _send is the underlying method for sending in the harvest, if sending raw we can bypass the other helpers completely which format the payloads */\n      if (this.opts.raw) send = args => this.harvest._send(args);\n      /** send is used to formated the payloads from \"getPayload\" and obfuscate before sending */else send = args => this.harvest.send(args);\n    } else {\n      // force it to run at least once in sendX mode\n      harvests.push(undefined);\n    }\n    harvests.forEach(payload => {\n      send({\n        endpoint: this.endpoint,\n        payload,\n        opts,\n        submitMethod,\n        cbFinished: cbRanAfterSend,\n        customUrl: this.opts.customUrl,\n        raw: this.opts.raw\n      });\n    });\n    if (this.started) {\n      this.scheduleHarvest();\n    }\n  }\n  onHarvestFinished(opts, result) {\n    if (this.opts.onFinished) {\n      this.opts.onFinished(result);\n    }\n    if (result.sent && result.retry) {\n      const delay = result.delay || this.opts.retryDelay;\n      // reschedule next harvest if should be delayed longer\n      if (this.started && delay) {\n        clearTimeout(this.timeoutHandle);\n        this.timeoutHandle = null;\n        this.scheduleHarvest(delay, opts);\n      } else if (!this.started && delay) {\n        // if not running on a timer, schedule a single retry\n        this.scheduleHarvest(delay, opts);\n      }\n    }\n  }\n}","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { mapOwn } from '../util/map-own';\nimport { stringify } from '../util/stringify';\nimport { Obfuscator } from '../util/obfuscate';\nvar hasOwnProp = Object.prototype.hasOwnProperty;\nvar MAX_ATTRIBUTES = 64;\nexport function nullable(val, fn, comma) {\n  return val || val === 0 || val === '' ? fn(val) + (comma ? ',' : '') : '!';\n}\nexport function numeric(n, noDefault) {\n  if (noDefault) {\n    return Math.floor(n).toString(36);\n  }\n  return n === undefined || n === 0 ? '' : Math.floor(n).toString(36);\n}\nexport function getAddStringContext(agentIdentifier) {\n  // eslint-disable-next-line\n  var stringTable = Object.hasOwnProperty('create') ? Object.create(null) : {};\n  var stringTableIdx = 0;\n  return addString;\n  function addString(str) {\n    if (typeof str === 'undefined' || str === '') return '';\n    var obfuscator = new Obfuscator({\n      agentIdentifier\n    });\n    str = String(str);\n    if (obfuscator.shouldObfuscate()) str = obfuscator.obfuscateString(str);\n    if (hasOwnProp.call(stringTable, str)) {\n      return numeric(stringTable[str], true);\n    } else {\n      stringTable[str] = stringTableIdx++;\n      return quoteString(str);\n    }\n  }\n}\nexport function addCustomAttributes(attrs, addString) {\n  var attrParts = [];\n  mapOwn(attrs, function (key, val) {\n    if (attrParts.length >= MAX_ATTRIBUTES) return;\n    var type = 5;\n    var serializedValue;\n    // add key to string table first\n    key = addString(key);\n    switch (typeof val) {\n      case 'object':\n        if (val) {\n          // serialize objects to strings\n          serializedValue = addString(stringify(val));\n        } else {\n          // null attribute type\n          type = 9;\n        }\n        break;\n      case 'number':\n        type = 6;\n        // make sure numbers contain a `.` so they are parsed as doubles\n        serializedValue = val % 1 ? val : val + '.';\n        break;\n      case 'boolean':\n        type = val ? 7 : 8;\n        break;\n      case 'undefined':\n        // we treat undefined as a null attribute (since dirac does not have a concept of undefined)\n        type = 9;\n        break;\n      default:\n        serializedValue = addString(val);\n    }\n    attrParts.push([type, key + (serializedValue ? ',' + serializedValue : '')]);\n  });\n  return attrParts;\n}\nvar escapable = /([,\\\\;])/g;\nfunction quoteString(str) {\n  return \"'\" + str.replace(escapable, '\\\\$1');\n}","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// We don't use JSON.stringify directly on the performance timing data for these reasons:\n// * Chrome has extra data in the performance object that we don't want to send all the time (wasteful)\n// * Firefox fails to stringify the native object due to - http://code.google.com/p/v8/issues/detail?id=1223\n// * The variable names are long and wasteful to transmit\n\n// Add Performance Timing values to the given object.\n// * Values are written relative to an offset to reduce their length (i.e. number of characters).\n// * The offset is sent with the data\n// * 0's are not included unless the value is a 'relative zero'\n//\n\nvar START = 'Start';\nvar END = 'End';\nvar UNLOAD_EVENT = 'unloadEvent';\nvar REDIRECT = 'redirect';\nvar DOMAIN_LOOKUP = 'domainLookup';\nvar ONNECT = 'onnect';\nvar REQUEST = 'request';\nvar RESPONSE = 'response';\nvar LOAD_EVENT = 'loadEvent';\nvar DOM_CONTENT_LOAD_EVENT = 'domContentLoadedEvent';\nexport const navTimingValues = [];\nfunction getPntType(type) {\n  if (typeof type === 'number') return type;\n  const types = {\n    navigate: undefined,\n    reload: 1,\n    back_forward: 2,\n    prerender: 3\n  };\n  return types[type];\n}\nexport function addPT(offset, pt) {\n  let v = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let isL1Api = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  if (!pt) return;\n  v.of = offset;\n  handleValue(v.of, v, 'n', true);\n  handleValue(pt[UNLOAD_EVENT + START], v, 'u', isL1Api);\n  handleValue(pt[REDIRECT + START], v, 'r', isL1Api);\n  handleValue(pt[UNLOAD_EVENT + END], v, 'ue', isL1Api);\n  handleValue(pt[REDIRECT + END], v, 're', isL1Api);\n  handleValue(pt['fetch' + START], v, 'f', isL1Api);\n  handleValue(pt[DOMAIN_LOOKUP + START], v, 'dn', isL1Api);\n  handleValue(pt[DOMAIN_LOOKUP + END], v, 'dne', isL1Api);\n  handleValue(pt['c' + ONNECT + START], v, 'c', isL1Api);\n  handleValue(pt['secureC' + ONNECT + 'ion' + START], v, 's', isL1Api);\n  handleValue(pt['c' + ONNECT + END], v, 'ce', isL1Api);\n  handleValue(pt[REQUEST + START], v, 'rq', isL1Api);\n  handleValue(pt[RESPONSE + START], v, 'rp', isL1Api);\n  handleValue(pt[RESPONSE + END], v, 'rpe', isL1Api);\n  handleValue(pt.domLoading, v, 'dl', isL1Api);\n  handleValue(pt.domInteractive, v, 'di', isL1Api);\n  handleValue(pt[DOM_CONTENT_LOAD_EVENT + START], v, 'ds', isL1Api);\n  handleValue(pt[DOM_CONTENT_LOAD_EVENT + END], v, 'de', isL1Api);\n  handleValue(pt.domComplete, v, 'dc', isL1Api);\n  handleValue(pt[LOAD_EVENT + START], v, 'l', isL1Api);\n  handleValue(pt[LOAD_EVENT + END], v, 'le', isL1Api);\n  return v;\n}\n\n// Add Performance Navigation values to the given object\nexport function addPN(pn, v) {\n  handleValue(getPntType(pn.type), v, 'ty');\n  handleValue(pn.redirectCount, v, 'rc');\n  return v;\n}\n\n/**\n * By side effect, this modifies 'obj' with a mapping of the 'prop' provided to a 'value', and invalid values are not added.\n * On the other hand, the local navTimingValues array gets the value appended if valid and 'undefined' appended if invalid, regardless.\n */\nfunction handleValue(value, obj, prop, isOldApi) {\n  /*\n  For L2 Timing API, the value will already be a relative-to-previous-document DOMHighResTimeStamp.\n  For L1 (deprecated) Timing, the value is an UNIX epoch timestamp, which we will convert to a relative time using our offset.\n  PNT.type is reported as undefined, 1, 2, etc -- note that zero-value properties will be recorded as 'undefined', however DEM interprets undefined \"types\" as \"navigate\"\n  */\n  if (typeof value === 'number' && value > 0) {\n    // note that zero-value properties will be recorded as 'undefined'\n    if (isOldApi) {\n      const offset = obj?.of > 0 ? obj.of : 0; // expect an epoch timestamp, if called by addPT\n      value = Math.max(value - offset, 0);\n    }\n    value = Math.round(value);\n    obj[prop] = value;\n    navTimingValues.push(value);\n  } else navTimingValues.push(undefined);\n}","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { windowAddEventListener } from '../event-listener/event-listener-opts';\nimport { globalScope, isWorkerScope, isBrowserScope } from '../constants/runtime';\nimport { subscribeToVisibilityChange } from '../window/page-visibility';\nif (isWorkerScope) {\n  globalScope.cleanupTasks = []; // create new list on WorkerGlobalScope to track funcs to run before exiting thread\n\n  const origClose = globalScope.close;\n  globalScope.close = () => {\n    // on worker's EoL signal, execute all \"listeners\", e.g. final harvests\n    for (let task of globalScope.cleanupTasks) {\n      task();\n    }\n    origClose();\n  };\n}\n\n/**\n * Subscribes a provided callback to the time/event when the agent should treat it as end-of-life.\n * This is used, for example, to submit a final harvest and send all remaining data on best-effort.\n * @param {function} cb - func to run before or during the last reliable event or time of an env's life span\n */\nexport function subscribeToEOL(cb) {\n  if (isBrowserScope) {\n    subscribeToVisibilityChange(cb, true); // when user switches tab or hides window, esp. mobile scenario\n    windowAddEventListener('pagehide', cb); // when user navigates away, and because safari iOS v14.4- doesn't fully support vis change\n    // --this ought to be removed once support for version below 14.5 phases out\n  } else if (isWorkerScope) {\n    globalScope.cleanupTasks.push(cb); // close() should run these tasks before quitting thread\n  }\n  // By default (for other env), this fn has no effect.\n}","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar MAX_NODES = 128;\nvar lastId = 0;\nexport function InteractionNode(interaction, parent, type, timestamp) {\n  Object.defineProperty(this, 'interaction', {\n    value: interaction,\n    writable: true // enumerable: false -- by default, which hides this prop from obj (iterations)\n  });\n  this.parent = parent;\n  this.id = ++lastId;\n  this.type = type;\n  this.children = [];\n  this.end = null;\n  this.jsEnd = this.start = timestamp;\n  this.jsTime = 0;\n  this.attrs = {};\n  this.cancelled = false;\n}\nvar InteractionNodePrototype = InteractionNode.prototype;\n\n/**\n * @param {string} type\n * @param {number} timestamp\n * @param {string} name\n * @param {bool} dontWait - When true, the interaction will not immediately start waiting\n *                          for this node to complete. This is used when the creation of\n *                          the node and its start happen at different times (e.g. XHR).\n */\nInteractionNodePrototype.child = function child(type, timestamp, name, dontWait) {\n  var interaction = this.interaction;\n  if (interaction.end || interaction.nodes >= MAX_NODES) return null;\n  interaction.onNodeAdded(this);\n  var node = new InteractionNode(interaction, this, type, timestamp);\n  node.attrs.name = name;\n  interaction.nodes++;\n  if (!dontWait) {\n    interaction.remaining++;\n  }\n  return node;\n};\nInteractionNodePrototype.callback = function addCallbackTime(exclusiveTime, end) {\n  var node = this;\n  node.jsTime += exclusiveTime;\n  if (end > node.jsEnd) {\n    node.jsEnd = end;\n    node.interaction.lastCb = end;\n  }\n};\nInteractionNodePrototype.cancel = function cancel() {\n  this.cancelled = true;\n  var interaction = this.interaction;\n  interaction.remaining--;\n};\nInteractionNodePrototype.finish = function finish(timestamp) {\n  var node = this;\n  if (node.end) return;\n  node.end = timestamp;\n\n  // Find the next parent node that is not cancelled\n  let parent = node.parent;\n  while (parent?.cancelled) parent = parent.parent;\n\n  // Assign the node to the non-cancelled parent node\n  if (parent) parent.children.push(node);\n  node.parent = null;\n\n  // Update the interaction remaining counter\n  var interaction = this.interaction;\n  interaction.remaining--;\n  interaction.lastFinish = timestamp;\n  // check if interaction has finished, (this is needed for older browsers for unknown reasons)\n  interaction.checkFinish();\n};","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { getInfo, getRuntime, originals } from '../../../common/config/config';\nimport { mapOwn } from '../../../common/util/map-own';\nimport { ee } from '../../../common/event-emitter/contextual-ee';\nimport { InteractionNode } from './interaction-node';\nvar originalSetTimeout = originals.ST;\nvar originalClearTimeout = originals.CT;\nvar lastId = {};\nexport function Interaction(eventName, timestamp, url, routeName, onFinished, agentIdentifier) {\n  this.agentIdentifier = agentIdentifier;\n  this.ee = ee.get(agentIdentifier);\n  lastId[agentIdentifier] = 0;\n  this.id = ++lastId[agentIdentifier];\n  this.eventName = eventName;\n  this.nodes = 0;\n  this.remaining = 0;\n  this.finishTimer = null;\n  this.checkingFinish = false;\n  this.lastCb = this.lastFinish = timestamp;\n  this.handlers = [];\n  this.onFinished = onFinished;\n  this.done = false;\n  var root = this.root = new InteractionNode(this, null, 'interaction', timestamp);\n  var attrs = root.attrs;\n  attrs.trigger = eventName;\n  attrs.initialPageURL = getRuntime(agentIdentifier).origin;\n  attrs.oldRoute = routeName;\n  attrs.newURL = attrs.oldURL = url;\n  attrs.custom = {};\n  attrs.store = {};\n}\nvar InteractionPrototype = Interaction.prototype;\nInteractionPrototype.checkFinish = function checkFinish() {\n  var interaction = this;\n  if (interaction.remaining > 0) {\n    interaction._resetFinishCheck();\n    return;\n  }\n  if (interaction.checkingFinish) {\n    return;\n  }\n  if (interaction.root.end !== null) return;\n  interaction._resetFinishCheck();\n  interaction.checkingFinish = true;\n  interaction.finishTimer = originalSetTimeout(() => {\n    interaction.checkingFinish = false;\n    interaction.finishTimer = originalSetTimeout(() => {\n      interaction.finishTimer = null;\n      if (interaction.remaining <= 0) interaction.finish();\n    }, 1);\n  }, 0);\n};\nInteractionPrototype.setNewURL = function setNewURL(url) {\n  this.root.attrs.newURL = url;\n};\nInteractionPrototype.setNewRoute = function setNewRoute(route) {\n  this.root.attrs.newRoute = route;\n};\nInteractionPrototype.onNodeAdded = function onNodeAdded() {\n  this._resetFinishCheck();\n};\nInteractionPrototype._resetFinishCheck = function _resetFinishCheck() {\n  if (this.finishTimer) {\n    originalClearTimeout(this.finishTimer);\n    this.finishTimer = null;\n    this.checkingFinish = false;\n  }\n};\n\n// serialize report and remove nodes from map\nInteractionPrototype.finish = function finishInteraction() {\n  var interaction = this;\n  var root = interaction.root;\n  if (root.end !== null) return;\n  var endTimestamp = Math.max(interaction.lastCb, interaction.lastFinish);\n  var attrs = root.attrs;\n  var customAttrs = attrs.custom;\n  if (this.onFinished) {\n    this.onFinished(this);\n  }\n  mapOwn(getInfo(interaction.agentIdentifier).jsAttributes, function (attr, value) {\n    if (!(attr in customAttrs)) customAttrs[attr] = value;\n  });\n  root.end = endTimestamp;\n  interaction.ee.emit('interaction', [this]);\n};","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { cleanURL } from '../../../common/url/clean-url';\nimport { mapOwn } from '../../../common/util/map-own';\nimport { nullable, numeric, getAddStringContext, addCustomAttributes } from '../../../common/serialize/bel-serializer';\nimport { SharedContext } from '../../../common/context/shared-context';\nimport { getInfo } from '../../../common/config/config';\nexport class Serializer extends SharedContext {\n  constructor(parent) {\n    super(parent);\n\n    /**\n     * This variable is used to calculate an interactions ending offset when the\n     * harvest includes multiple interactions. This variable is set by the first\n     * interaction processed and used by subsequent interactions in the same harvest.\n     * See https://issues.newrelic.com/browse/NEWRELIC-5498\n     * @type {number|undefined}\n     */\n    this.firstTimestamp = undefined;\n  }\n  serializeMultiple(interactions, offset, navTiming) {\n    const info = getInfo(this.sharedContext.agentIdentifier);\n    var addString = getAddStringContext(this.sharedContext.agentIdentifier);\n    var serialized = 'bel.7';\n    interactions.forEach(interaction => {\n      serialized += ';' + this.serializeInteraction(interaction.root, offset, navTiming, interaction.routeChange, addString, info);\n    });\n    this.firstTimestamp = undefined;\n    return serialized;\n  }\n  serializeSingle(root, offset, navTiming, isRouteChange) {\n    const info = getInfo(this.sharedContext.agentIdentifier);\n    var addString = getAddStringContext(this.sharedContext.agentIdentifier);\n    var serialized = 'bel.7;' + this.serializeInteraction(root, offset, navTiming, isRouteChange, addString, info);\n    this.firstTimestamp = undefined;\n    return serialized;\n  }\n  serializeInteraction(root, offset, navTiming, isRouteChange, addString, info) {\n    offset = offset || 0;\n    var isInitialPage = root.attrs.trigger === 'initialPageLoad';\n    var typeIdsByName = {\n      interaction: 1,\n      ajax: 2,\n      customTracer: 4\n    };\n\n    // Include the hash fragment with all SPA data\n    var includeHashFragment = true;\n    const addNode = (node, nodeList) => {\n      if (node.type === 'customEnd') return nodeList.push([3, numeric(node.end - this.firstTimestamp)]);\n      var typeName = node.type;\n      var typeId = typeIdsByName[typeName];\n      var startTimestamp = node.start;\n      var childCount = node.children.length;\n      var attrCount = 0;\n      var apmAttributes = info.atts;\n      var hasNavTiming = isInitialPage && navTiming.length && typeId === 1;\n      var children = [];\n      var attrs = node.attrs;\n      var metrics = attrs.metrics;\n      var params = attrs.params;\n      var queueTime = info.queueTime;\n      var appTime = info.applicationTime;\n      if (typeof this.firstTimestamp === 'undefined') {\n        startTimestamp += offset;\n        this.firstTimestamp = startTimestamp;\n      } else {\n        startTimestamp -= this.firstTimestamp;\n      }\n      var fields = [numeric(startTimestamp), numeric(node.end - node.start), numeric(node.jsEnd - node.end), numeric(node.jsTime)];\n      switch (typeId) {\n        case 1:\n          fields[2] = numeric(node.jsEnd - this.firstTimestamp);\n          fields.push(addString(attrs.trigger), addString(cleanURL(attrs.initialPageURL, includeHashFragment)), addString(cleanURL(attrs.oldURL, includeHashFragment)), addString(cleanURL(attrs.newURL, includeHashFragment)), addString(attrs.customName), isInitialPage ? '' : isRouteChange ? 1 : 2, nullable(isInitialPage && queueTime, numeric, true) + nullable(isInitialPage && appTime, numeric, true) + nullable(attrs.oldRoute, addString, true) + nullable(attrs.newRoute, addString, true) + addString(attrs.id), addString(node.id), nullable(attrs.firstPaint, numeric, true) + nullable(attrs.firstContentfulPaint, numeric, false));\n          var attrParts = addCustomAttributes(attrs.custom, addString);\n          children = children.concat(attrParts);\n          attrCount = attrParts.length;\n          if (apmAttributes) {\n            childCount++;\n            children.push('a,' + addString(apmAttributes));\n          }\n          break;\n        case 2:\n          fields.push(addString(params.method), numeric(params.status), addString(params.host), addString(params.pathname), numeric(metrics.txSize), numeric(metrics.rxSize), attrs.isFetch ? 1 : attrs.isJSONP ? 2 : '', addString(node.id), nullable(node.dt && node.dt.spanId, addString, true) + nullable(node.dt && node.dt.traceId, addString, true) + nullable(node.dt && node.dt.timestamp, numeric, false));\n\n          // add params.gql here\n          if (Object.keys(params?.gql || {}).length) {\n            var ajaxAttrParts = addCustomAttributes(params.gql, addString);\n            children = children.concat(ajaxAttrParts);\n            attrCount = ajaxAttrParts.length;\n          }\n          break;\n        case 4:\n          var tracedTime = attrs.tracedTime;\n          fields.push(addString(attrs.name), nullable(tracedTime, numeric, true) + addString(node.id));\n          break;\n      }\n      for (var i = 0; i < node.children.length; i++) {\n        addNode(node.children[i], children);\n      }\n      fields.unshift(numeric(typeId), numeric(childCount += attrCount));\n      nodeList.push(fields);\n      if (childCount) {\n        nodeList.push(children.join(';'));\n      }\n      if (hasNavTiming) {\n        // this build up the navTiming node\n        // it for each navTiming value (pre aggregated in nav-timing.js):\n        // we initialize the seperator to ',' (seperates the nodeType id from the first value)\n        // we initialize the navTiming node to 'b' (the nodeType id)\n        // if the value is present:\n        //   we add the seperator followed by the value\n        // otherwise\n        //   we add null seperator ('!') to the navTimingNode\n        //   we set the seperator to an empty string since we already wrote it above\n        //   the reason for writing the null seperator instead of setting the seperator\n        //   is to ensure we still write it if the null is the last navTiming value.\n\n        var seperator = ',';\n        var navTimingNode = 'b';\n        var prev = 0;\n\n        // get all navTiming values except navigationStart\n        // (since its the same as interaction.start)\n        // and limit to just the first 20 values we know about\n        mapOwn(navTiming.slice(1, 21), function (i, v) {\n          if (v !== undefined) {\n            navTimingNode += seperator + numeric(v - prev);\n            seperator = ',';\n            prev = v;\n          } else {\n            navTimingNode += seperator + '!';\n            seperator = '';\n          }\n        });\n        nodeList.push(navTimingNode);\n      } else if (typeId === 1) {\n        nodeList.push('');\n      }\n      return nodeList;\n    };\n    return addNode(root, []).join(';');\n  }\n}","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n/* eslint no-undef: \"error\" */\nimport { registerHandler as register } from '../../../common/event-emitter/register-handler';\nimport { parseUrl } from '../../../common/url/parse-url';\nimport { shouldCollectEvent } from '../../../common/deny-list/deny-list';\nimport { mapOwn } from '../../../common/util/map-own';\nimport { navTimingValues as navTiming } from '../../../common/timing/nav-timing';\nimport { generateUuid } from '../../../common/ids/unique-id';\nimport { Interaction } from './interaction';\nimport { getConfigurationValue, getRuntime } from '../../../common/config/config';\nimport { eventListenerOpts } from '../../../common/event-listener/event-listener-opts';\nimport { HarvestScheduler } from '../../../common/harvest/harvest-scheduler';\nimport { Serializer } from './serializer';\nimport { ee } from '../../../common/event-emitter/contextual-ee';\nimport * as CONSTANTS from '../constants';\nimport { FEATURE_NAMES } from '../../../loaders/features/features';\nimport { AggregateBase } from '../../utils/aggregate-base';\nimport { firstContentfulPaint } from '../../../common/vitals/first-contentful-paint';\nimport { firstPaint } from '../../../common/vitals/first-paint';\nimport { bundleId } from '../../../common/ids/bundle-id';\nimport { loadedAsDeferredBrowserScript } from '../../../common/constants/runtime';\nimport { handle } from '../../../common/event-emitter/handle';\nimport { SUPPORTABILITY_METRIC_CHANNEL } from '../../metrics/constants';\nimport { deregisterDrain } from '../../../common/drain/drain';\nimport { warn } from '../../../common/util/console';\nconst {\n  FEATURE_NAME,\n  INTERACTION_EVENTS,\n  MAX_TIMER_BUDGET,\n  FN_START,\n  FN_END,\n  CB_START,\n  INTERACTION_API,\n  REMAINING,\n  INTERACTION,\n  SPA_NODE,\n  JSONP_NODE,\n  FETCH_START,\n  FETCH_DONE,\n  FETCH_BODY,\n  JSONP_END,\n  originalSetTimeout\n} = CONSTANTS;\nexport class Aggregate extends AggregateBase {\n  static featureName = FEATURE_NAME;\n  constructor(agentIdentifier, aggregator) {\n    super(agentIdentifier, aggregator, FEATURE_NAME);\n    const agentRuntime = getRuntime(agentIdentifier);\n    this.state = {\n      initialPageURL: agentRuntime.origin,\n      lastSeenUrl: agentRuntime.origin,\n      lastSeenRouteName: null,\n      timerMap: {},\n      timerBudget: MAX_TIMER_BUDGET,\n      currentNode: null,\n      prevNode: null,\n      nodeOnLastHashUpdate: null,\n      initialPageLoad: null,\n      pageLoaded: false,\n      childTime: 0,\n      depth: 0,\n      harvestTimeSeconds: getConfigurationValue(agentIdentifier, 'spa.harvestTimeSeconds') || 10,\n      interactionsToHarvest: [],\n      interactionsSent: [],\n      // The below feature flag is used to disable the SPA ajax fix for specific customers, see https://new-relic.atlassian.net/browse/NR-172169\n      disableSpaFix: (getConfigurationValue(agentIdentifier, 'feature_flags') || []).indexOf('disable-spa-fix') > -1\n    };\n    let scheduler;\n    this.serializer = new Serializer(this);\n    const {\n      state,\n      serializer\n    } = this;\n    const baseEE = ee.get(agentIdentifier); // <-- parent baseEE\n    const mutationEE = baseEE.get('mutation');\n    const promiseEE = baseEE.get('promise');\n    const historyEE = baseEE.get('history');\n    const eventsEE = baseEE.get('events'); // ajax --> ee(123).emit() ee()\n    const timerEE = baseEE.get('timer');\n    const fetchEE = baseEE.get('fetch');\n    const jsonpEE = baseEE.get('jsonp');\n    const xhrEE = baseEE.get('xhr');\n    const tracerEE = baseEE.get('tracer');\n\n    // childTime is used when calculating exclusive time for a cb duration.\n    //\n    // Exclusive time will be different than the total time for either callbacks\n    // which synchronously invoke a customTracer callback or, trigger a synchronous\n    // event (eg. onreadystate=1 or popstate).\n    //\n    // At fn-end, childTime will contain the total time of all timed callbacks and\n    // event handlers which executed as a child of the current callback. At the\n    // begining of every callback, childTime is saved to the event context (which at\n    // that time contains the sum of its preceeding siblings) and is reset to 0. The\n    // callback is then executed, and its children may increase childTime.  At the\n    // end of the callback, it reports its exclusive time as its\n    // execution time - exlcuded. childTime is then reset to its previous\n    // value, and the totalTime of the callback that just finished executing is\n    // added to the childTime time.\n    //                                    | clock | childTime | ctx.ct | totalTime | exclusive |\n    // click fn-start                     |   0   |    0     |    0   |           |           |\n    //  | click begining:                 |   5   |    0     |    0   |           |           |\n    //  |   | custom-1 fn-start           |   10  |    0     |    0   |           |           |\n    //  |   |   |  custom-1 begining      |   15  |    0     |    0   |           |           |\n    //  |   |   |    |  custom-2 fn-start |   20  |    0     |    0   |           |           |\n    //  |   |   |    |  | custom-2        |   25  |    0     |    0   |           |           |\n    //  |   |   |    |  custom-2 fn-end   |   30  |    10    |    0   |     10    |     10    |\n    //  |   |   |  custom-1 middle        |   35  |    10    |    0   |           |           |\n    //  |   |   |    |  custom-3 fn-start |   40  |    0     |    10  |           |           |\n    //  |   |   |    |  | custom-3        |   45  |    0     |    10  |           |           |\n    //  |   |   |    |  custom-3 fn-end   |   50  |    20    |    0   |     10    |     10    |\n    //  |   |   |  custom-1 ending        |   55  |    20    |    0   |           |           |\n    //  |     custom-1 fn-end             |   60  |    50    |    0   |     50    |     30    |\n    //  | click ending:                   |   65  |    50    |        |           |           |\n    // click fn-end                       |   70  |    0     |    0   |     70    |     20    |\n\n    this.waitForFlags(['spa']).then(_ref => {\n      let [spaFlag] = _ref;\n      if (spaFlag) {\n        scheduler = new HarvestScheduler('events', {\n          onFinished: onHarvestFinished,\n          retryDelay: state.harvestTimeSeconds\n        }, {\n          agentIdentifier,\n          ee: baseEE\n        });\n        scheduler.harvest.on('events', onHarvestStarted);\n        this.drain();\n      } else {\n        this.blocked = true;\n        deregisterDrain(this.agentIdentifier, this.featureName);\n      }\n    });\n    if (!isEnabled()) return;\n    state.initialPageLoad = new Interaction('initialPageLoad', 0, state.lastSeenUrl, state.lastSeenRouteName, onInteractionFinished, agentIdentifier);\n    state.initialPageLoad.save = true;\n    state.prevInteraction = state.initialPageLoad;\n    state.currentNode = state.initialPageLoad.root; // hint\n    // ensure that checkFinish calls are safe during initialPageLoad\n    state.initialPageLoad[REMAINING]++;\n    register(FN_START, callbackStart, this.featureName, baseEE);\n    register(CB_START, callbackStart, this.featureName, promiseEE);\n\n    // register plugins\n    var pluginApi = {\n      getCurrentNode,\n      setCurrentNode\n    };\n    register('spa-register', function (init) {\n      if (typeof init === 'function') {\n        init(pluginApi);\n      }\n    }, FEATURE_NAMES.spa, baseEE);\n    function callbackStart() {\n      state.depth++;\n      this.prevNode = state.currentNode;\n      this.ct = state.childTime;\n      state.childTime = 0;\n      state.timerBudget = MAX_TIMER_BUDGET;\n    }\n    register(FN_END, callbackEnd, this.featureName, baseEE);\n    register('cb-end', callbackEnd, this.featureName, promiseEE);\n    function callbackEnd() {\n      state.depth--;\n      var totalTime = this.jsTime || 0;\n      var exclusiveTime = totalTime - state.childTime;\n      state.childTime = this.ct + totalTime;\n      if (state.currentNode) {\n        // transfer accumulated callback time to the active interaction node\n        // run even if jsTime is 0 to update jsEnd\n        state.currentNode.callback(exclusiveTime, this[FN_END]);\n        if (this.isTraced) {\n          state.currentNode.attrs.tracedTime = exclusiveTime;\n        }\n      }\n      this.jsTime = state.currentNode ? 0 : exclusiveTime;\n      setCurrentNode(this.prevNode);\n      this.prevNode = null;\n      state.timerBudget = MAX_TIMER_BUDGET;\n    }\n    register(FN_START, function (args, eventSource) {\n      var ev = args[0];\n      var evName = ev.type;\n      var eventNode = ev[\"__nrNode:\".concat(bundleId)];\n      if (!state.pageLoaded && (evName === 'load' && eventSource === window || loadedAsDeferredBrowserScript)) {\n        state.pageLoaded = true;\n        // set to null so prevNode is set correctly\n        this.prevNode = state.currentNode = null;\n        if (state.initialPageLoad) {\n          eventNode = state.initialPageLoad.root;\n\n          // Even if initialPageLoad has remaining callbacks, force the initialPageLoad\n          // interaction to complete when the page load event occurs.\n          state.initialPageLoad[REMAINING] = 0;\n          originalSetTimeout(function () {\n            INTERACTION_EVENTS.push('popstate');\n          });\n        }\n      }\n      if (eventNode) {\n        // If we've already seen a previous handler for this specific event object,\n        // just restore that. We want multiple handlers for the same event to share\n        // a node.\n        setCurrentNode(eventNode);\n      } else if (evName === 'hashchange') {\n        setCurrentNode(state.nodeOnLastHashUpdate);\n        state.nodeOnLastHashUpdate = null;\n      } else if (eventSource instanceof XMLHttpRequest) {\n        // If this event was emitted by an XHR, restore the node ID associated with\n        // that XHR.\n        setCurrentNode(baseEE.context(eventSource).spaNode);\n      } else if (!state.currentNode && INTERACTION_EVENTS.indexOf(evName) !== -1) {\n        // Otherwise, if no interaction is currently active, create a new node ID,\n        // and let the aggregator know that we entered a new event handler callback\n        // so that it has a chance to possibly start an interaction.\n        var ixn = new Interaction(evName, this[FN_START], state.lastSeenUrl, state.lastSeenRouteName, onInteractionFinished, agentIdentifier);\n\n        // Store the interaction as prevInteraction in case it is prematurely discarded\n        state.prevInteraction = ixn;\n        setCurrentNode(ixn.root);\n        if (evName === 'click') {\n          var value = getActionText(ev.target);\n          if (value) {\n            state.currentNode.attrs.custom.actionText = value;\n          }\n        }\n      }\n      ev[\"__nrNode:\".concat(bundleId)] = state.currentNode;\n    }, this.featureName, eventsEE);\n\n    /**\n     * *** TIMERS ***\n     * setTimeout call needs to keep the interaction active in case a node is started\n     * in its callback.\n     */\n\n    // The context supplied to this callback will be shared with the fn-start/fn-end\n    // callbacks that fire around the callback passed to setTimeout originally.\n    register('setTimeout-end', function saveId(args, obj, timerId) {\n      if (!state.currentNode || state.timerBudget - this.timerDuration < 0) return;\n      if (args && !(args[0] instanceof Function)) return;\n      state.currentNode[INTERACTION][REMAINING]++;\n      this.timerId = timerId;\n      state.timerMap[timerId] = state.currentNode;\n      this.timerBudget = state.timerBudget - 50;\n    }, this.featureName, timerEE);\n    register('clearTimeout-start', function clear(args) {\n      var timerId = args[0];\n      var node = state.timerMap[timerId];\n      if (node) {\n        var interaction = node[INTERACTION];\n        interaction[REMAINING]--;\n        interaction.checkFinish();\n        delete state.timerMap[timerId];\n      }\n    }, this.featureName, timerEE);\n    register(FN_START, function () {\n      state.timerBudget = this.timerBudget || MAX_TIMER_BUDGET;\n      var id = this.timerId;\n      var node = state.timerMap[id];\n      setCurrentNode(node);\n      delete state.timerMap[id];\n      if (node) node[INTERACTION][REMAINING]--;\n    }, this.featureName, timerEE);\n\n    /**\n     * *** XHR ***\n     * - `new-xhr` event is fired when new instance of XHR is created. Here we create\n     *    a new node and store it on the XHR object.\n     * -  When the send method is called (`send-xhr-start` event), we tell the interaction\n     *    to wait for this XHR to complete.\n     * -  When any direct event handlers are invoked (`fn-start` on the `xhr` emitter),\n     *    we restore the node in case other child nodes are started here.\n     * -  Callbacks attached using `addEventListener` are handled using `fn-start` on the\n     *    `events` emitter.\n     * -  When `xhr-resolved` is emitted, we end the node. The node.finish() call also\n     *    instructs the interaction to stop waiting for this node.\n     */\n\n    // context is shared with new-xhr event, and is stored on the xhr iteself.\n    register(FN_START, function () {\n      setCurrentNode(this[SPA_NODE]);\n    }, this.featureName, xhrEE);\n\n    // context is stored on the xhr and is shared with all callbacks associated\n    // with the new xhr\n    register('new-xhr', function () {\n      if (!state.disableSpaFix && !state.currentNode && state.prevInteraction && !state.prevInteraction.ignored) {\n        /*\n         * The previous interaction was discarded before a route change. Restore the interaction\n         * in case this XHR is associated with a route change.\n         */\n        const interaction = state.prevInteraction;\n        state.currentNode = interaction.root;\n        interaction.root.end = null;\n      }\n      if (state.currentNode) {\n        this[SPA_NODE] = state.currentNode.child('ajax', null, null, true);\n      }\n    }, this.featureName, xhrEE);\n    register('send-xhr-start', function () {\n      var node = this[SPA_NODE];\n      if (node && !this.sent) {\n        this.sent = true;\n        node.dt = this.dt;\n        if (node.dt?.timestamp) {\n          node.dt.timestamp = agentRuntime.timeKeeper.correctAbsoluteTimestamp(node.dt.timestamp);\n        }\n        node.jsEnd = node.start = this.startTime;\n        node[INTERACTION][REMAINING]++;\n      }\n    }, this.featureName, xhrEE);\n    register('xhr-resolved', function () {\n      var node = this[SPA_NODE];\n      if (node) {\n        if (!shouldCollectEvent(this.params)) {\n          node.cancel();\n          return;\n        }\n        var attrs = node.attrs;\n        attrs.params = this.params;\n        attrs.metrics = this.metrics;\n        node.finish(this.endTime);\n        if (!!this.currentNode && !!this.currentNode.interaction) this.currentNode.interaction.checkFinish();\n      }\n    }, this.featureName, baseEE);\n\n    /**\n     * *** JSONP ***\n     *\n     */\n\n    register('new-jsonp', function (url) {\n      if (state.currentNode) {\n        var node = this[JSONP_NODE] = state.currentNode.child('ajax', this[FETCH_START]);\n        node.start = this['new-jsonp'];\n        this.url = url;\n        this.status = null;\n      }\n    }, this.featureName, jsonpEE);\n    register('cb-start', function (args) {\n      var node = this[JSONP_NODE];\n      if (node) {\n        setCurrentNode(node);\n        this.status = 200;\n      }\n    }, this.featureName, jsonpEE);\n    register('jsonp-error', function () {\n      var node = this[JSONP_NODE];\n      if (node) {\n        setCurrentNode(node);\n        this.status = 0;\n      }\n    }, this.featureName, jsonpEE);\n    register(JSONP_END, function () {\n      var node = this[JSONP_NODE];\n      if (node) {\n        // if no status is set then cb never fired - so it's not a valid JSONP\n        if (this.status === null) {\n          node.cancel();\n          return;\n        }\n        var attrs = node.attrs;\n        var params = attrs.params = {};\n        var parsed = parseUrl(this.url);\n        params.method = 'GET';\n        params.pathname = parsed.pathname;\n        params.host = parsed.hostname + ':' + parsed.port;\n        params.status = this.status;\n        attrs.metrics = {\n          txSize: 0,\n          rxSize: 0\n        };\n        attrs.isJSONP = true;\n        node.jsEnd = this[JSONP_END];\n        node.jsTime = this[CB_START] ? this[JSONP_END] - this[CB_START] : 0;\n        node.finish(node.jsEnd);\n      }\n    }, this.featureName, jsonpEE);\n    register(FETCH_START, function (fetchArguments, dtPayload) {\n      if (fetchArguments) {\n        if (!state.disableSpaFix && !state.currentNode && state.prevInteraction && !state.prevInteraction.ignored) {\n          /*\n           * The previous interaction was discarded before a route change. Restore the interaction\n           * in case this XHR is associated with a route change.\n           */\n          const interaction = state.prevInteraction;\n          state.currentNode = interaction.root;\n          interaction.root.end = null;\n        }\n        if (state.currentNode) {\n          this[SPA_NODE] = state.currentNode.child('ajax', this[FETCH_START]);\n          if (dtPayload && this[SPA_NODE]) {\n            this[SPA_NODE].dt = dtPayload;\n            if (this[SPA_NODE].dt?.timestamp) {\n              this[SPA_NODE].dt.timestamp = agentRuntime.timeKeeper.correctAbsoluteTimestamp(this[SPA_NODE].dt.timestamp);\n            }\n          }\n        }\n      }\n    }, this.featureName, fetchEE);\n    register(FETCH_BODY + 'start', function (args) {\n      if (state.currentNode) {\n        this[SPA_NODE] = state.currentNode;\n        state.currentNode[INTERACTION][REMAINING]++;\n      }\n    }, this.featureName, fetchEE);\n    register(FETCH_BODY + 'end', function (args, ctx, bodyPromise) {\n      var node = this[SPA_NODE];\n      if (node) node[INTERACTION][REMAINING]--;\n    }, this.featureName, fetchEE);\n    register(FETCH_DONE, function (err, res) {\n      var node = this[SPA_NODE];\n      if (node) {\n        if (err || !shouldCollectEvent(this.params)) {\n          node.cancel();\n          return;\n        }\n        var attrs = node.attrs;\n        attrs.params = this.params;\n        attrs.metrics = {\n          txSize: this.txSize,\n          rxSize: this.rxSize\n        };\n        attrs.isFetch = true;\n        node.finish(this[FETCH_DONE]);\n      }\n    }, this.featureName, fetchEE);\n    register('newURL', function (url, hashChangedDuringCb) {\n      if (state.currentNode) {\n        state.currentNode[INTERACTION].setNewURL(url);\n      } else if (state.prevInteraction && !state.prevInteraction.ignored) {\n        /*\n         * The previous interaction was discarded before the route was changed. This can happen in SPA\n         * frameworks when using lazy loading. We have also seen this in version 11+ of Nextjs where\n         * some route changes re-use cached resolved promises.\n         */\n        const interaction = state.prevInteraction;\n        interaction.setNewURL(url);\n        interaction.root.end = null;\n        setCurrentNode(interaction.root);\n      }\n      if (state.currentNode) {\n        if (state.lastSeenUrl !== url) {\n          state.currentNode[INTERACTION].routeChange = true;\n        }\n        if (hashChangedDuringCb) {\n          state.nodeOnLastHashUpdate = state.currentNode;\n        }\n      }\n      state.lastSeenUrl = url;\n    }, this.featureName, historyEE);\n\n    /**\n     * SCRIPTS\n     *   This is only needed to keep the interaction open while external scripts are being loaded.\n     *   The script that is loaded could continue the interaction by making additional AJAX\n     *   calls or changing the URL. The interaction context (currentNode) needs to be\n     *   restored somehow, but this differs based on the specific customer code. In some cases, we\n     *   could wrap a JSONP callback, in other cases we could wrap a higher-level API, and in\n     *   some cases we may not be able to restore context automatically (customer would need\n     *   to instrument their code manually).\n     *\n     * - We do not restore the original context in the load/error callbacks. This would not\n     *   work for the scripts themselves because by the time the load event fires, the\n     *   script content has already been executed.\n     */\n\n    // dom-start is emitted when appendChild or replaceChild are called. If the element being\n    // inserted is script and we are inside an interaction, we will keep the interaction open\n    // until the script is loaded.\n    jsonpEE.on('dom-start', function (args) {\n      if (!state.currentNode) return;\n      var el = args[0];\n      var isScript = el && el.nodeName === 'SCRIPT' && el.src !== '';\n      var interaction = state.currentNode.interaction;\n      if (isScript) {\n        // increase remaining count to keep the interaction open\n        interaction[REMAINING]++;\n        el.addEventListener('load', onload, eventListenerOpts(false));\n        el.addEventListener('error', onerror, eventListenerOpts(false));\n      }\n      function onload() {\n        // decrease remaining to allow interaction to finish\n        interaction[REMAINING]--;\n\n        // checkFinish is what initiates closing interaction, but is only called\n        // when setCurrentNode is called. Since we are not restoring a node here,\n        // we need to initiate the check manually.\n        // The reason we are not restoring the node here is because 1) this is not\n        // where the code of the external script runs (by the time the load event\n        // fires, it has already executed), and 2) it would require storing the context\n        // probably on the DOM node and restoring in all callbacks, which is a different\n        // use case than lazy loading.\n        interaction.checkFinish();\n      }\n      function onerror() {\n        interaction[REMAINING]--;\n        interaction.checkFinish();\n      }\n    });\n    register(FN_START, function () {\n      setCurrentNode(state.prevNode);\n    }, this.featureName, mutationEE);\n    register('resolve-start', resolvePromise, this.featureName, promiseEE);\n    register('executor-err', resolvePromise, this.featureName, promiseEE);\n    register('propagate', saveNode, this.featureName, promiseEE);\n    register(CB_START, function () {\n      var ctx = this.getCtx ? this.getCtx() : this;\n      setCurrentNode(ctx[SPA_NODE]);\n    }, this.featureName, promiseEE);\n    register(INTERACTION_API + 'get', function (t) {\n      var interaction;\n      if (state?.currentNode?.[INTERACTION]) interaction = this.ixn = state.currentNode[INTERACTION];else if (state?.prevNode?.end === null && state?.prevNode?.[INTERACTION]?.root?.[INTERACTION]?.eventName !== 'initialPageLoad') interaction = this.ixn = state.prevNode[INTERACTION];else interaction = this.ixn = new Interaction('api', t, state.lastSeenUrl, state.lastSeenRouteName, onInteractionFinished, agentIdentifier);\n      if (!state.currentNode) {\n        interaction.checkFinish();\n        if (state.depth) setCurrentNode(interaction.root);\n      }\n    }, this.featureName, baseEE);\n    register(INTERACTION_API + 'actionText', function (t, actionText) {\n      var customAttrs = this.ixn.root.attrs.custom;\n      if (actionText) customAttrs.actionText = actionText;\n    }, this.featureName, baseEE);\n    register(INTERACTION_API + 'setName', function (t, name, trigger) {\n      var attrs = this.ixn.root.attrs;\n      if (name) attrs.customName = name;\n      if (trigger) attrs.trigger = trigger;\n    }, this.featureName, baseEE);\n    register(INTERACTION_API + 'setAttribute', function (t, name, value) {\n      this.ixn.root.attrs.custom[name] = value;\n    }, this.featureName, baseEE);\n    register(INTERACTION_API + 'end', function (timestamp) {\n      var interaction = this.ixn;\n      var node = activeNodeFor(interaction);\n      setCurrentNode(null);\n      node.child('customEnd', timestamp).finish(timestamp);\n      interaction.finish();\n    }, this.featureName, baseEE);\n    register(INTERACTION_API + 'ignore', function (t) {\n      this.ixn.ignored = true;\n    }, this.featureName, baseEE);\n    register(INTERACTION_API + 'save', function (t) {\n      this.ixn.save = true;\n    }, this.featureName, baseEE);\n    register(INTERACTION_API + 'tracer', function (timestamp, name, store) {\n      var interaction = this.ixn;\n      var parent = activeNodeFor(interaction);\n      var ctx = baseEE.context(store);\n      if (!name) {\n        ctx.inc = ++interaction[REMAINING];\n        return ctx[SPA_NODE] = parent;\n      }\n      ctx[SPA_NODE] = parent.child('customTracer', timestamp, name);\n    }, this.featureName, baseEE);\n    register(FN_START, tracerDone, this.featureName, tracerEE);\n    register('no-' + FN_START, tracerDone, this.featureName, tracerEE);\n    function tracerDone(timestamp, interactionContext, hasCb) {\n      var node = this[SPA_NODE];\n      if (!node) return;\n      var interaction = node[INTERACTION];\n      var inc = this.inc;\n      this.isTraced = true;\n      if (inc) {\n        interaction[REMAINING]--;\n      } else if (node) {\n        node.finish(timestamp);\n      }\n      hasCb ? setCurrentNode(node) : interaction.checkFinish();\n    }\n    register(INTERACTION_API + 'getContext', function (t, cb) {\n      var store = this.ixn.root.attrs.store;\n      setTimeout(function () {\n        cb(store);\n      }, 0);\n    }, this.featureName, baseEE);\n    register(INTERACTION_API + 'onEnd', function (t, cb) {\n      this.ixn.handlers.push(cb);\n    }, this.featureName, baseEE);\n    register('api-routeName', function (t, currentRouteName) {\n      state.lastSeenRouteName = currentRouteName;\n      if (state.currentNode) state.currentNode[INTERACTION].setNewRoute(currentRouteName);\n    }, this.featureName, baseEE);\n    function activeNodeFor(interaction) {\n      return state.currentNode && state.currentNode[INTERACTION] === interaction ? state.currentNode : interaction.root;\n    }\n    function saveNode(val, overwrite) {\n      if (overwrite || !this[SPA_NODE]) this[SPA_NODE] = state.currentNode;\n    }\n    function resolvePromise() {\n      if (!this.resolved) {\n        this.resolved = true;\n        this[SPA_NODE] = state.currentNode;\n      }\n    }\n    function getCurrentNode() {\n      return state.currentNode;\n    }\n    function setCurrentNode(newNode) {\n      if (!state.pageLoaded && !newNode && state.initialPageLoad) newNode = state.initialPageLoad.root;\n      if (state.currentNode) {\n        state.currentNode[INTERACTION].checkFinish();\n      }\n      state.prevNode = state.currentNode;\n      state.currentNode = newNode && !newNode[INTERACTION].root.end ? newNode : null;\n    }\n    function onInteractionFinished(interaction) {\n      if (interaction === state.initialPageLoad) state.initialPageLoad = null;\n      var root = interaction.root;\n      var attrs = root.attrs;\n\n      // make sure that newrelic[INTERACTION]() works in end handler\n      state.currentNode = root;\n      mapOwn(interaction.handlers, function (i, cb) {\n        cb(attrs.store);\n      });\n      setCurrentNode(null);\n    }\n    const classThis = this;\n    function onHarvestStarted(options) {\n      if (state.interactionsToHarvest.length === 0 || classThis.blocked) return {};\n      var payload = serializer.serializeMultiple(state.interactionsToHarvest, 0, navTiming);\n      if (options.retry) {\n        state.interactionsToHarvest.forEach(function (interaction) {\n          state.interactionsSent.push(interaction);\n        });\n      }\n      state.interactionsToHarvest = [];\n      return {\n        body: {\n          e: payload\n        }\n      };\n    }\n    function onHarvestFinished(result) {\n      if (result.sent && result.retry && state.interactionsSent.length > 0) {\n        state.interactionsSent.forEach(function (interaction) {\n          state.interactionsToHarvest.unshift(interaction);\n        });\n        state.interactionsSent = [];\n      }\n    }\n    baseEE.on('errorAgg', function (type, name, params, metrics) {\n      if (!state.currentNode) return;\n      params._interactionId = state.currentNode.interaction.id;\n      // do not capture parentNodeId when in root node\n      if (state.currentNode.type && state.currentNode.type !== 'interaction') {\n        params._interactionNodeId = state.currentNode.id;\n      }\n    });\n    baseEE.on('interaction', saveInteraction);\n    function getActionText(node) {\n      var nodeType = node.tagName.toLowerCase();\n      var goodNodeTypes = ['a', 'button', 'input'];\n      var isGoodNode = goodNodeTypes.indexOf(nodeType) !== -1;\n      if (isGoodNode) {\n        return node.title || node.value || node.innerText;\n      }\n    }\n    function saveInteraction(interaction) {\n      if (interaction.ignored || !interaction.save && !interaction.routeChange) {\n        baseEE.emit('interactionDone', [interaction, false]);\n        return;\n      }\n      if (state.prevInteraction === interaction) {\n        // If the interaction is being saved, remove it from prevInteraction variable\n        // to prevent the interaction from possibly being sent twice or causing an internal\n        // recursive loop issue.\n        state.prevInteraction = null;\n      }\n\n      // assign unique id, this is serialized and used to link interactions with errors\n      interaction.root.attrs.id = generateUuid();\n      if (interaction.root.attrs.trigger === 'initialPageLoad') {\n        interaction.root.attrs.firstPaint = firstPaint.current.value;\n        interaction.root.attrs.firstContentfulPaint = firstContentfulPaint.current.value;\n      }\n      baseEE.emit('interactionDone', [interaction, true]);\n      state.interactionsToHarvest.push(interaction);\n      let smCategory;\n      if (interaction.root?.attrs?.trigger === 'initialPageLoad') smCategory = 'InitialPageLoad';else if (interaction.routeChange) smCategory = 'RouteChange';else smCategory = 'Custom';\n      handle(SUPPORTABILITY_METRIC_CHANNEL, [\"Spa/Interaction/\".concat(smCategory, \"/Duration/Ms\"), Math.max((interaction.root?.end || 0) - (interaction.root?.start || 0), 0)], undefined, FEATURE_NAMES.metrics, baseEE);\n      scheduler?.scheduleHarvest(0);\n      if (!scheduler) warn('SPA scheduler is not initialized. Saved interaction is not sent!');\n    }\n    function isEnabled() {\n      var enabled = getConfigurationValue(agentIdentifier, 'spa.enabled');\n      return enabled !== false;\n    }\n  }\n}"],"names":["denyList","shouldCollectEvent","params","length","undefined","hostname","i","parsed","domainMatchesPattern","comparePath","pathname","setDenyList","denyListConfig","url","indexOf","substring","firstSlash","host","_host$split","split","_slicedToArray","push","pattern","domain","path","HarvestScheduler","_SharedContext","endpoint","opts","parent","_this$sharedContext","_this","_classCallCheck","started","timeoutHandle","aborted","harvest","Harvest","sharedContext","subscribeToEOL","unload","bind","_assertThisInitialized","ee","on","SESSION_EVENTS","runHarvest","forceNoRetry","_inherits","_createClass","key","value","this","onUnload","interval","initialDelay","scheduleHarvest","permanently","arguments","clearTimeout","delay","_this2","setTimeout","_this3","submitMethod","payload","cbRanAfterSend","result","retry","onHarvestFinished","harvests","getPayload","submitData","isFinalHarvest","Object","prototype","toString","call","apply","_toConsumableArray","send","args","sendX","raw","_send","forEach","cbFinished","customUrl","onFinished","sent","retryDelay","SharedContext","hasOwnProp","hasOwnProperty","MAX_ATTRIBUTES","nullable","val","fn","comma","numeric","n","noDefault","Math","floor","getAddStringContext","agentIdentifier","stringTable","create","stringTableIdx","str","obfuscator","Obfuscator","String","shouldObfuscate","obfuscateString","replace","escapable","quoteString","addCustomAttributes","attrs","addString","attrParts","mapOwn","serializedValue","type","stringify","START","END","UNLOAD_EVENT","REDIRECT","DOMAIN_LOOKUP","ONNECT","REQUEST","RESPONSE","LOAD_EVENT","DOM_CONTENT_LOAD_EVENT","navTimingValues","addPT","offset","pt","v","isL1Api","of","handleValue","domLoading","domInteractive","domComplete","addPN","pn","navigate","reload","back_forward","prerender","redirectCount","obj","prop","isOldApi","max","round","isWorkerScope","globalScope","origClose","_step","_iterator","_createForOfIteratorHelper","s","done","task","err","e","f","cb","isBrowserScope","subscribeToVisibilityChange","windowAddEventListener","lastId","InteractionNode","interaction","timestamp","defineProperty","writable","id","children","end","jsEnd","start","jsTime","cancelled","InteractionNodePrototype","child","name","dontWait","nodes","onNodeAdded","node","remaining","callback","exclusiveTime","lastCb","cancel","finish","_parent","lastFinish","checkFinish","originalSetTimeout","originals","originalClearTimeout","Interaction","eventName","routeName","finishTimer","checkingFinish","handlers","root","trigger","initialPageURL","getRuntime","origin","oldRoute","newURL","oldURL","custom","store","InteractionPrototype","_resetFinishCheck","setNewURL","setNewRoute","route","newRoute","endTimestamp","customAttrs","getInfo","jsAttributes","attr","emit","Serializer","firstTimestamp","interactions","navTiming","info","serialized","serializeInteraction","routeChange","isRouteChange","isInitialPage","typeIdsByName","ajax","customTracer","includeHashFragment","addNode","nodeList","typeName","typeId","startTimestamp","childCount","attrCount","apmAttributes","atts","hasNavTiming","metrics","queueTime","appTime","applicationTime","fields","cleanURL","customName","firstPaint","firstContentfulPaint","concat","method","status","txSize","rxSize","isFetch","isJSONP","dt","spanId","traceId","keys","gql","ajaxAttrParts","tracedTime","unshift","join","seperator","navTimingNode","prev","slice","FEATURE_NAME","CONSTANTS","INTERACTION_EVENTS","MAX_TIMER_BUDGET","FN_START","FN_END","CB_START","INTERACTION_API","REMAINING","INTERACTION","SPA_NODE","JSONP_NODE","FETCH_START","FETCH_DONE","FETCH_BODY","JSONP_END","Aggregate","_AggregateBase","aggregator","scheduler","agentRuntime","state","lastSeenUrl","lastSeenRouteName","timerMap","timerBudget","currentNode","prevNode","nodeOnLastHashUpdate","initialPageLoad","pageLoaded","childTime","depth","harvestTimeSeconds","getConfigurationValue","interactionsToHarvest","interactionsSent","disableSpaFix","serializer","_assertThisInitialize","baseEE","mutationEE","get","promiseEE","historyEE","eventsEE","timerEE","fetchEE","jsonpEE","xhrEE","tracerEE","waitForFlags","then","_ref","onHarvestStarted","drain","blocked","deregisterDrain","featureName","_possibleConstructorReturn","onInteractionFinished","save","prevInteraction","register","callbackStart","pluginApi","getCurrentNode","setCurrentNode","ct","callbackEnd","totalTime","isTraced","tracerDone","interactionContext","hasCb","inc","activeNodeFor","resolvePromise","resolved","newNode","init","FEATURE_NAMES","eventSource","ev","evName","eventNode","bundleId","window","loadedAsDeferredBrowserScript","XMLHttpRequest","context","spaNode","ixn","nodeType","tagName","toLowerCase","title","innerText","getActionText","target","actionText","timerId","timerDuration","Function","ignored","_node$dt","timeKeeper","correctAbsoluteTimestamp","startTime","endTime","parseUrl","port","fetchArguments","dtPayload","_this$SPA_NODE$dt","ctx","bodyPromise","res","hashChangedDuringCb","el","isScript","nodeName","src","addEventListener","eventListenerOpts","overwrite","getCtx","t","_state$currentNode","_state$prevNode","_state$prevNode2","currentRouteName","classThis","options","serializeMultiple","body","_interactionId","_interactionNodeId","_interaction$root","_interaction$root2","_interaction$root3","_scheduler","smCategory","generateUuid","handle","SUPPORTABILITY_METRIC_CHANNEL","warn","AggregateBase","_defineProperty"],"sourceRoot":""}