{"version":3,"file":"static/js/session_replay-aggregate.825a63fd.chunk.js","mappings":"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","sources":["../node_modules/@newrelic/browser-agent/dist/esm/common/constants/shared-channel.js","../node_modules/@newrelic/browser-agent/dist/esm/common/harvest/harvest-scheduler.js","../node_modules/@newrelic/browser-agent/dist/esm/common/unload/eol.js","../node_modules/@newrelic/browser-agent/dist/esm/features/session_replay/aggregate/index.js","../node_modules/@newrelic/browser-agent/dist/esm/features/session_replay/shared/stylesheet-evaluator.js"],"sourcesContent":["/**\n * @file Keeps an object alive that is passed to all feature aggregate modules.\n * The purpose is to have a way for communication and signals to relay across features at runtime.\n * This object can hold any arbitrary values and should be treated as on-the-fly dynamic.\n */\n\nlet onReplayReady;\nconst sessionReplayInitialized = new Promise(resolve => {\n  onReplayReady = resolve;\n});\nexport const sharedChannel = Object.freeze({\n  onReplayReady,\n  sessionReplayInitialized\n});","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as submitData from '../util/submit-data';\nimport { SharedContext } from '../context/shared-context';\nimport { Harvest } from './harvest';\nimport { subscribeToEOL } from '../unload/eol';\nimport { SESSION_EVENTS } from '../session/constants';\n\n/**\n * Periodically invokes harvest calls and handles retries\n */\nexport class HarvestScheduler extends SharedContext {\n  /**\n     * Create a HarvestScheduler\n     * @param {string} endpoint - The base BAM endpoint name -- ex. 'events'\n     * @param {object} opts - The options used to configure the HarvestScheduler\n     * @param {Function} opts.onFinished - The callback to be fired when a harvest has finished\n     * @param {Function} opts.getPayload - A callback which can be triggered to return a payload for harvesting\n     * @param {number} opts.retryDelay - The number of seconds to wait before retrying after a network failure\n     * @param {boolean} opts.raw - Use a prefabricated payload shape as the harvest payload without the need for formatting\n     * @param {string} opts.customUrl - A custom url that falls outside of the shape of the standard BAM harvester url pattern.  Will use directly instead of concatenating various pieces\n     * @param {*} parent - The parent object, whose state can be passed into SharedContext\n     */\n  constructor(endpoint, opts, parent) {\n    super(parent); // gets any allowed properties from the parent and stores them in `sharedContext`\n    this.endpoint = endpoint;\n    this.opts = opts || {};\n    this.started = false;\n    this.timeoutHandle = null;\n    this.aborted = false; // this controls the per-interval and final harvests for the scheduler (currently per feature specific!)\n\n    this.harvest = new Harvest(this.sharedContext);\n\n    // unload if EOL mechanism fires\n    subscribeToEOL(this.unload.bind(this));\n\n    /* Flush all buffered data if session resets and give up retries. This should be synchronous to ensure that the correct `session` value is sent.\n      Since session-reset generates a new session ID and the ID is grabbed at send-time, any delays or retries would cause the payload to be sent under\n      the wrong session ID. */\n    this.sharedContext?.ee.on(SESSION_EVENTS.RESET, () => this.runHarvest({\n      forceNoRetry: true\n    }));\n  }\n\n  /**\n   * This function is only meant for the last outgoing harvest cycle of a page. It trickles down to using sendBeacon, which should not be used\n   * to send payloads while the page is still active, due to limitations on how much data can be buffered in the API at any one time.\n   */\n  unload() {\n    if (this.aborted) return;\n    // If opts.onUnload is defined, these are special actions to execute before attempting to send the final payload.\n    if (this.opts.onUnload) this.opts.onUnload();\n    this.runHarvest({\n      unload: true\n    });\n  }\n  startTimer(interval, initialDelay) {\n    this.interval = interval;\n    this.started = true;\n    this.scheduleHarvest(initialDelay != null ? initialDelay : this.interval);\n  }\n  stopTimer() {\n    let permanently = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    this.aborted = permanently; // stopping permanently is same as aborting, but this function also cleans up the setTimeout loop\n    this.started = false;\n    if (this.timeoutHandle) {\n      clearTimeout(this.timeoutHandle);\n    }\n  }\n  scheduleHarvest(delay, opts) {\n    if (this.timeoutHandle) return;\n    if (delay == null) {\n      delay = this.interval;\n    }\n    this.timeoutHandle = setTimeout(() => {\n      this.timeoutHandle = null;\n      this.runHarvest(opts);\n    }, delay * 1000);\n  }\n  runHarvest(opts) {\n    if (this.aborted) return;\n\n    /**\n     * This is executed immediately after harvest sends the data via XHR, or if there's nothing to send. Note that this excludes on unloading / sendBeacon.\n     * @param {Object} result\n     */\n    const cbRanAfterSend = result => {\n      if (opts?.forceNoRetry) result.retry = false; // discard unsent data rather than re-queuing for next harvest attempt\n      this.onHarvestFinished(opts, result);\n    };\n    let harvests = [];\n    let submitMethod;\n    let payload;\n    if (this.opts.getPayload) {\n      // Ajax & PVT & SR features provide a callback function to get data for harvesting\n      submitMethod = submitData.getSubmitMethod({\n        isFinalHarvest: opts?.unload\n      });\n      if (!submitMethod) return false;\n      const retry = !opts?.unload && submitMethod === submitData.xhr;\n      payload = this.opts.getPayload({\n        retry,\n        opts\n      });\n      if (!payload) {\n        if (this.started) {\n          this.scheduleHarvest();\n        }\n        return;\n      }\n      payload = Object.prototype.toString.call(payload) === '[object Array]' ? payload : [payload];\n      harvests.push(...payload);\n    }\n\n    /** sendX is used for features that do not supply a preformatted payload via \"getPayload\" */\n    let send = args => this.harvest.sendX(args);\n    if (harvests.length) {\n      /** _send is the underlying method for sending in the harvest, if sending raw we can bypass the other helpers completely which format the payloads */\n      if (this.opts.raw) send = args => this.harvest._send(args);\n      /** send is used to formated the payloads from \"getPayload\" and obfuscate before sending */else send = args => this.harvest.send(args);\n    } else {\n      // force it to run at least once in sendX mode\n      harvests.push(undefined);\n    }\n    harvests.forEach(payload => {\n      send({\n        endpoint: this.endpoint,\n        payload,\n        opts,\n        submitMethod,\n        cbFinished: cbRanAfterSend,\n        customUrl: this.opts.customUrl,\n        raw: this.opts.raw\n      });\n    });\n    if (this.started) {\n      this.scheduleHarvest();\n    }\n  }\n  onHarvestFinished(opts, result) {\n    if (this.opts.onFinished) {\n      this.opts.onFinished(result);\n    }\n    if (result.sent && result.retry) {\n      const delay = result.delay || this.opts.retryDelay;\n      // reschedule next harvest if should be delayed longer\n      if (this.started && delay) {\n        clearTimeout(this.timeoutHandle);\n        this.timeoutHandle = null;\n        this.scheduleHarvest(delay, opts);\n      } else if (!this.started && delay) {\n        // if not running on a timer, schedule a single retry\n        this.scheduleHarvest(delay, opts);\n      }\n    }\n  }\n}","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { windowAddEventListener } from '../event-listener/event-listener-opts';\nimport { globalScope, isWorkerScope, isBrowserScope } from '../constants/runtime';\nimport { subscribeToVisibilityChange } from '../window/page-visibility';\nif (isWorkerScope) {\n  globalScope.cleanupTasks = []; // create new list on WorkerGlobalScope to track funcs to run before exiting thread\n\n  const origClose = globalScope.close;\n  globalScope.close = () => {\n    // on worker's EoL signal, execute all \"listeners\", e.g. final harvests\n    for (let task of globalScope.cleanupTasks) {\n      task();\n    }\n    origClose();\n  };\n}\n\n/**\n * Subscribes a provided callback to the time/event when the agent should treat it as end-of-life.\n * This is used, for example, to submit a final harvest and send all remaining data on best-effort.\n * @param {function} cb - func to run before or during the last reliable event or time of an env's life span\n */\nexport function subscribeToEOL(cb) {\n  if (isBrowserScope) {\n    subscribeToVisibilityChange(cb, true); // when user switches tab or hides window, esp. mobile scenario\n    windowAddEventListener('pagehide', cb); // when user navigates away, and because safari iOS v14.4- doesn't fully support vis change\n    // --this ought to be removed once support for version below 14.5 phases out\n  } else if (isWorkerScope) {\n    globalScope.cleanupTasks.push(cb); // close() should run these tasks before quitting thread\n  }\n  // By default (for other env), this fn has no effect.\n}","/*\n * Copyright 2023 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * @file Records, aggregates, and harvests session replay data.\n *\n * NOTE: This code is under development and dormant. It will not download to instrumented pages or record any data.\n * It is not production ready, and is not intended to be imported or implemented in any build of the browser agent until\n * functionality is validated and a full user experience is curated.\n */\n\nimport { registerHandler } from '../../../common/event-emitter/register-handler';\nimport { HarvestScheduler } from '../../../common/harvest/harvest-scheduler';\nimport { ABORT_REASONS, FEATURE_NAME, MAX_PAYLOAD_SIZE, QUERY_PARAM_PADDING, RRWEB_EVENT_TYPES, SR_EVENT_EMITTER_TYPES } from '../constants';\nimport { getConfigurationValue, getInfo, getRuntime } from '../../../common/config/config';\nimport { AggregateBase } from '../../utils/aggregate-base';\nimport { sharedChannel } from '../../../common/constants/shared-channel';\nimport { obj as encodeObj } from '../../../common/url/encode';\nimport { warn } from '../../../common/util/console';\nimport { globalScope } from '../../../common/constants/runtime';\nimport { SUPPORTABILITY_METRIC_CHANNEL } from '../../metrics/constants';\nimport { handle } from '../../../common/event-emitter/handle';\nimport { FEATURE_NAMES } from '../../../loaders/features/features';\nimport { RRWEB_VERSION } from \"../../../common/constants/env.npm\";\nimport { MODE, SESSION_EVENTS, SESSION_EVENT_TYPES } from '../../../common/session/constants';\nimport { stringify } from '../../../common/util/stringify';\nimport { stylesheetEvaluator } from '../shared/stylesheet-evaluator';\nimport { deregisterDrain } from '../../../common/drain/drain';\nimport { now } from '../../../common/timing/now';\nexport class Aggregate extends AggregateBase {\n  static featureName = FEATURE_NAME;\n  // pass the recorder into the aggregator\n  constructor(agentIdentifier, aggregator, args) {\n    super(agentIdentifier, aggregator, FEATURE_NAME);\n    /** The interval to harvest at.  This gets overridden if the size of the payload exceeds certain thresholds */\n    this.harvestTimeSeconds = getConfigurationValue(this.agentIdentifier, 'session_replay.harvestTimeSeconds') || 60;\n    /** Set once the recorder has fully initialized after flag checks and sampling */\n    this.initialized = false;\n    /** Set once the feature has been \"aborted\" to prevent other side-effects from continuing */\n    this.blocked = false;\n    /** populated with the gzipper lib async */\n    this.gzipper = undefined;\n    /** populated with the u8 string lib async */\n    this.u8 = undefined;\n    /** the mode to start in.  Defaults to off */\n    const {\n      session\n    } = getRuntime(this.agentIdentifier);\n    this.mode = session.state.sessionReplayMode || MODE.OFF;\n\n    /** set by BCS response */\n    this.entitled = false;\n    /** set at BCS response, stored in runtime */\n    this.timeKeeper = undefined;\n    this.recorder = args?.recorder;\n    if (this.recorder) this.recorder.parent = this;\n    handle(SUPPORTABILITY_METRIC_CHANNEL, ['Config/SessionReplay/Enabled'], undefined, FEATURE_NAMES.metrics, this.ee);\n\n    // The SessionEntity class can emit a message indicating the session was cleared and reset (expiry, inactivity). This feature must abort and never resume if that occurs.\n    this.ee.on(SESSION_EVENTS.RESET, () => {\n      this.scheduler.runHarvest();\n      this.abort(ABORT_REASONS.RESET);\n    });\n\n    // The SessionEntity class can emit a message indicating the session was paused (visibility change). This feature must stop recording if that occurs.\n    this.ee.on(SESSION_EVENTS.PAUSE, () => {\n      this.recorder?.stopRecording();\n    });\n    // The SessionEntity class can emit a message indicating the session was resumed (visibility change). This feature must start running again (if already running) if that occurs.\n    this.ee.on(SESSION_EVENTS.RESUME, () => {\n      if (!this.recorder) return;\n      // if the mode changed on a different tab, it needs to update this instance to match\n      const {\n        session\n      } = getRuntime(this.agentIdentifier);\n      this.mode = session.state.sessionReplayMode;\n      if (!this.initialized || this.mode === MODE.OFF) return;\n      this.recorder?.startRecording();\n    });\n    this.ee.on(SESSION_EVENTS.UPDATE, (type, data) => {\n      if (!this.recorder || !this.initialized || this.blocked || type !== SESSION_EVENT_TYPES.CROSS_TAB) return;\n      if (this.mode !== MODE.OFF && data.sessionReplayMode === MODE.OFF) this.abort(ABORT_REASONS.CROSS_TAB);\n      this.mode = data.sessionReplay;\n    });\n\n    // Bespoke logic for blobs endpoint.\n    this.scheduler = new HarvestScheduler('browser/blobs', {\n      onFinished: this.onHarvestFinished.bind(this),\n      retryDelay: this.harvestTimeSeconds,\n      getPayload: this.prepareHarvest.bind(this),\n      raw: true\n    }, this);\n    registerHandler(SR_EVENT_EMITTER_TYPES.RECORD, () => {\n      // if it has aborted or BCS returned bad entitlements, do not allow\n      if (this.blocked || !this.entitled) return;\n      // if it isnt already (fully) initialized... initialize it\n      if (!this.recorder) this.initializeRecording(false, true, true);\n      // its been initialized and imported the recorder but its not recording (mode === off || error)\n      else if (this.mode !== MODE.FULL) this.switchToFull();\n      // if it gets all the way to here, that means a full session is already recording... do nothing\n    }, this.featureName, this.ee);\n    registerHandler(SR_EVENT_EMITTER_TYPES.PAUSE, () => {\n      this.forceStop(this.mode !== MODE.ERROR);\n    }, this.featureName, this.ee);\n\n    // Wait for an error to be reported.  This currently is wrapped around the \"Error\" feature.  This is a feature-feature dependency.\n    // This was to ensure that all errors, including those on the page before load and those handled with \"noticeError\" are accounted for. Needs evalulation\n    registerHandler('errorAgg', e => {\n      this.errorNoticed = true;\n      if (this.recorder) this.recorder.currentBufferTarget.hasError = true;\n      // run once\n      if (this.mode === MODE.ERROR && globalScope?.document.visibilityState === 'visible') {\n        this.switchToFull();\n      }\n    }, this.featureName, this.ee);\n    const {\n      error_sampling_rate,\n      sampling_rate,\n      autoStart,\n      block_selector,\n      mask_text_selector,\n      mask_all_inputs,\n      inline_stylesheet,\n      inline_images,\n      collect_fonts\n    } = getConfigurationValue(this.agentIdentifier, 'session_replay');\n    this.waitForFlags(['sr']).then(_ref => {\n      let [flagOn] = _ref;\n      this.entitled = flagOn;\n      if (!this.entitled) {\n        deregisterDrain(this.agentIdentifier, this.featureName);\n        if (this.recorder?.recording) {\n          this.abort(ABORT_REASONS.ENTITLEMENTS);\n          handle(SUPPORTABILITY_METRIC_CHANNEL, ['SessionReplay/EnabledNotEntitled/Detected'], undefined, FEATURE_NAMES.metrics, this.ee);\n        }\n        return;\n      }\n      this.drain();\n      this.initializeRecording(Math.random() * 100 < error_sampling_rate, Math.random() * 100 < sampling_rate);\n    }).then(() => {\n      if (this.mode === MODE.OFF) args?.recorder?.stopRecording(); // stop any conservative preload recording launched by instrument\n      sharedChannel.onReplayReady(this.mode); // notify watchers that replay started with the mode\n    });\n\n    /** Detect if the default configs have been altered and report a SM.  This is useful to evaluate what the reasonable defaults are across a customer base over time */\n    if (!autoStart) handle(SUPPORTABILITY_METRIC_CHANNEL, ['Config/SessionReplay/AutoStart/Modified'], undefined, FEATURE_NAMES.metrics, this.ee);\n    if (collect_fonts === true) handle(SUPPORTABILITY_METRIC_CHANNEL, ['Config/SessionReplay/CollectFonts/Modified'], undefined, FEATURE_NAMES.metrics, this.ee);\n    if (inline_stylesheet !== true) handle(SUPPORTABILITY_METRIC_CHANNEL, ['Config/SessionReplay/InlineStylesheet/Modified'], undefined, FEATURE_NAMES.metrics, this.ee);\n    if (inline_images === true) handle(SUPPORTABILITY_METRIC_CHANNEL, ['Config/SessionReplay/InlineImages/Modifed'], undefined, FEATURE_NAMES.metrics, this.ee);\n    if (mask_all_inputs !== true) handle(SUPPORTABILITY_METRIC_CHANNEL, ['Config/SessionReplay/MaskAllInputs/Modified'], undefined, FEATURE_NAMES.metrics, this.ee);\n    if (block_selector !== '[data-nr-block]') handle(SUPPORTABILITY_METRIC_CHANNEL, ['Config/SessionReplay/BlockSelector/Modified'], undefined, FEATURE_NAMES.metrics, this.ee);\n    if (mask_text_selector !== '*') handle(SUPPORTABILITY_METRIC_CHANNEL, ['Config/SessionReplay/MaskTextSelector/Modified'], undefined, FEATURE_NAMES.metrics, this.ee);\n    handle(SUPPORTABILITY_METRIC_CHANNEL, ['Config/SessionReplay/SamplingRate/Value', sampling_rate], undefined, FEATURE_NAMES.metrics, this.ee);\n    handle(SUPPORTABILITY_METRIC_CHANNEL, ['Config/SessionReplay/ErrorSamplingRate/Value', error_sampling_rate], undefined, FEATURE_NAMES.metrics, this.ee);\n  }\n  switchToFull() {\n    this.mode = MODE.FULL;\n    // if the error was noticed AFTER the recorder was already imported....\n    if (this.recorder && this.initialized) {\n      this.recorder.stopRecording();\n      this.recorder.startRecording();\n      this.scheduler.startTimer(this.harvestTimeSeconds);\n      this.syncWithSessionManager({\n        sessionReplayMode: this.mode\n      });\n    }\n  }\n\n  /**\n   * Evaluate entitlements and sampling before starting feature mechanics, importing and configuring recording library, and setting storage state\n   * @param {boolean} entitlements - the true/false state of the \"sr\" flag from RUM response\n   * @param {boolean} errorSample - the true/false state of the error sampling decision\n   * @param {boolean} fullSample - the true/false state of the full sampling decision\n   * @param {boolean} ignoreSession - whether to force the method to ignore the session state and use just the sample flags\n   * @returns {void}\n   */\n  async initializeRecording(errorSample, fullSample, ignoreSession) {\n    this.initialized = true;\n    if (!this.entitled) return;\n\n    // if theres an existing session replay in progress, there's no need to sample, just check the entitlements response\n    // if not, these sample flags need to be checked\n    // if this isnt the FIRST load of a session AND\n    // we are not actively recording SR... DO NOT import or run the recording library\n    // session replay samples can only be decided on the first load of a session\n    // session replays can continue if already in progress\n    const {\n      session,\n      timeKeeper\n    } = getRuntime(this.agentIdentifier);\n    this.timeKeeper = timeKeeper;\n    if (!session.isNew && !ignoreSession) {\n      // inherit the mode of the existing session\n      this.mode = session.state.sessionReplayMode;\n    } else {\n      // The session is new... determine the mode the new session should start in\n      if (fullSample) this.mode = MODE.FULL; // full mode has precedence over error mode\n      else if (errorSample) this.mode = MODE.ERROR;\n      // If neither are selected, then don't record (early return)\n      else {\n        return;\n      }\n    }\n    if (this.recorder?.getEvents().type === 'preloaded') {\n      this.prepUtils().then(() => {\n        this.scheduler.runHarvest();\n      });\n    }\n    if (!this.recorder) {\n      try {\n        // Do not change the webpackChunkName or it will break the webpack nrba-chunking plugin\n        const {\n          Recorder\n        } = await import( /* webpackChunkName: \"recorder\" */'../shared/recorder');\n        this.recorder = new Recorder(this);\n        this.recorder.currentBufferTarget.hasError = this.errorNoticed;\n      } catch (err) {\n        return this.abort(ABORT_REASONS.IMPORT);\n      }\n    }\n\n    // If an error was noticed before the mode could be set (like in the early lifecycle of the page), immediately set to FULL mode\n    if (this.mode === MODE.ERROR && this.errorNoticed) {\n      this.mode = MODE.FULL;\n    }\n\n    // FULL mode records AND reports from the beginning, while ERROR mode only records (but does not report).\n    // ERROR mode will do this until an error is thrown, and then switch into FULL mode.\n    // If an error happened in ERROR mode before we've gotten to this stage, it will have already set the mode to FULL\n    if (this.mode === MODE.FULL && !this.scheduler.started) {\n      // We only report (harvest) in FULL mode\n      this.scheduler.startTimer(this.harvestTimeSeconds);\n    }\n    await this.prepUtils();\n    if (!this.recorder.recording) this.recorder.startRecording();\n    this.syncWithSessionManager({\n      sessionReplayMode: this.mode\n    });\n  }\n  async prepUtils() {\n    try {\n      // Do not change the webpackChunkName or it will break the webpack nrba-chunking plugin\n      const {\n        gzipSync,\n        strToU8\n      } = await import( /* webpackChunkName: \"compressor\" */'fflate');\n      this.gzipper = gzipSync;\n      this.u8 = strToU8;\n    } catch (err) {\n      // compressor failed to load, but we can still record without compression as a last ditch effort\n    }\n  }\n  prepareHarvest() {\n    let {\n      opts\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!this.recorder || !this.timeKeeper?.ready) return;\n    const recorderEvents = this.recorder.getEvents();\n    // get the event type and use that to trigger another harvest if needed\n    if (!recorderEvents.events.length || this.mode !== MODE.FULL || this.blocked) return;\n    const payload = this.getHarvestContents(recorderEvents);\n    if (!payload.body.length) {\n      this.recorder.clearBuffer();\n      return;\n    }\n    let len = 0;\n    if (!!this.gzipper && !!this.u8) {\n      payload.body = this.gzipper(this.u8(\"[\".concat(payload.body.map(e => {\n        if (e.__serialized) return e.__serialized;\n        return stringify(e);\n      }).join(','), \"]\")));\n      len = payload.body.length;\n      this.scheduler.opts.gzip = true;\n    } else {\n      payload.body = payload.body.map(_ref2 => {\n        let {\n          __serialized,\n          ...node\n        } = _ref2;\n        return node;\n      });\n      len = stringify(payload.body).length;\n      this.scheduler.opts.gzip = false;\n    }\n    if (len > MAX_PAYLOAD_SIZE) {\n      this.abort(ABORT_REASONS.TOO_BIG);\n      return;\n    }\n    // TODO -- Gracefully handle the buffer for retries.\n    const {\n      session\n    } = getRuntime(this.agentIdentifier);\n    if (!session.state.sessionReplaySentFirstChunk) this.syncWithSessionManager({\n      sessionReplaySentFirstChunk: true\n    });\n    this.recorder.clearBuffer();\n    if (recorderEvents.type === 'preloaded') this.scheduler.runHarvest(opts);\n    return [payload];\n  }\n  getHarvestContents(recorderEvents) {\n    recorderEvents ??= this.recorder.getEvents();\n    let events = recorderEvents.events;\n    const agentRuntime = getRuntime(this.agentIdentifier);\n    const info = getInfo(this.agentIdentifier);\n    const endUserId = info.jsAttributes?.['enduser.id'];\n\n    // do not let the first node be a full snapshot node, since this NEEDS to be preceded by a meta node\n    // we will manually inject it if this happens\n    const payloadStartsWithFullSnapshot = events?.[0]?.type === RRWEB_EVENT_TYPES.FullSnapshot;\n    if (payloadStartsWithFullSnapshot && !!this.recorder.lastMeta) {\n      recorderEvents.hasMeta = true;\n      events.unshift(this.recorder.lastMeta); // --> pushed the meta from a previous payload into newer payload... but it still has old timestamps\n      this.recorder.lastMeta = undefined;\n    }\n\n    // do not let the last node be a meta node, since this NEEDS to precede a snapshot\n    // we will manually inject it later if we find a payload that is missing a meta node\n    const payloadEndsWithMeta = events[events.length - 1]?.type === RRWEB_EVENT_TYPES.Meta;\n    if (payloadEndsWithMeta) {\n      this.recorder.lastMeta = events[events.length - 1];\n      events = events.slice(0, events.length - 1);\n      recorderEvents.hasMeta = !!events.find(x => x.type === RRWEB_EVENT_TYPES.Meta);\n    }\n    const relativeNow = now();\n    const firstEventTimestamp = events[0]?.timestamp; // from rrweb node\n    const lastEventTimestamp = events[events.length - 1]?.timestamp; // from rrweb node\n    const firstTimestamp = firstEventTimestamp || this.timeKeeper.correctAbsoluteTimestamp(recorderEvents.cycleTimestamp); // from rrweb node || from when the harvest cycle started\n    const lastTimestamp = lastEventTimestamp || this.timeKeeper.convertRelativeTimestamp(relativeNow);\n    const agentMetadata = agentRuntime.appMetadata?.agents?.[0] || {};\n    return {\n      qs: {\n        browser_monitoring_key: info.licenseKey,\n        type: 'SessionReplay',\n        app_id: info.applicationID,\n        protocol_version: '0',\n        timestamp: firstTimestamp,\n        attributes: encodeObj({\n          // this section of attributes must be controllable and stay below the query param padding limit -- see QUERY_PARAM_PADDING\n          // if not, data could be lost to truncation at time of sending, potentially breaking parsing / API behavior in NR1\n          ...(!!this.gzipper && !!this.u8 && {\n            content_encoding: 'gzip'\n          }),\n          ...(agentMetadata.entityGuid && {\n            entityGuid: agentMetadata.entityGuid\n          }),\n          'replay.firstTimestamp': firstTimestamp,\n          'replay.lastTimestamp': lastTimestamp,\n          'replay.nodes': events.length,\n          'session.durationMs': agentRuntime.session.getDuration(),\n          agentVersion: agentRuntime.version,\n          session: agentRuntime.session.state.value,\n          rst: relativeNow,\n          hasMeta: recorderEvents.hasMeta || false,\n          hasSnapshot: recorderEvents.hasSnapshot || false,\n          hasError: recorderEvents.hasError || false,\n          isFirstChunk: agentRuntime.session.state.sessionReplaySentFirstChunk === false,\n          decompressedBytes: recorderEvents.payloadBytesEstimation,\n          invalidStylesheetsDetected: stylesheetEvaluator.invalidStylesheetsDetected,\n          inlinedAllStylesheets: recorderEvents.inlinedAllStylesheets,\n          'rrweb.version': RRWEB_VERSION,\n          // customer-defined data should go last so that if it exceeds the query param padding limit it will be truncated instead of important attrs\n          ...(endUserId && {\n            'enduser.id': endUserId\n          })\n          // The Query Param is being arbitrarily limited in length here.  It is also applied when estimating the size of the payload in getPayloadSize()\n        }, QUERY_PARAM_PADDING).substring(1) // remove the leading '&'\n      },\n      body: events\n    };\n  }\n  onHarvestFinished(result) {\n    // The mutual decision for now is to stop recording and clear buffers if ingest is experiencing 429 rate limiting\n    if (result.status === 429) {\n      this.abort(ABORT_REASONS.TOO_MANY);\n    }\n    if (this.blocked) this.scheduler.stopTimer(true);\n  }\n\n  /**\n   * Forces the agent into OFF mode so that changing tabs or navigating\n   * does not restart the recording. This is used when the customer calls\n   * the stopRecording API.\n   */\n  forceStop(forceHarvest) {\n    if (forceHarvest) this.scheduler.runHarvest();\n    this.mode = MODE.OFF;\n    this.recorder?.stopRecording?.();\n    this.syncWithSessionManager({\n      sessionReplayMode: this.mode\n    });\n  }\n\n  /** Abort the feature, once aborted it will not resume */\n  abort() {\n    let reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    warn(\"SR aborted -- \".concat(reason.message));\n    handle(SUPPORTABILITY_METRIC_CHANNEL, [\"SessionReplay/Abort/\".concat(reason.sm)], undefined, FEATURE_NAMES.metrics, this.ee);\n    this.blocked = true;\n    this.mode = MODE.OFF;\n    this.recorder?.stopRecording?.();\n    this.syncWithSessionManager({\n      sessionReplayMode: this.mode\n    });\n    this.recorder?.clearTimestamps?.();\n    this.ee.emit('REPLAY_ABORTED');\n    while (this.recorder?.getEvents().events.length) this.recorder?.clearBuffer?.();\n  }\n  syncWithSessionManager() {\n    let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      session\n    } = getRuntime(this.agentIdentifier);\n    session.write(state);\n  }\n}","import { originals } from '../../../common/config/config';\nimport { isBrowserScope } from '../../../common/constants/runtime';\nclass StylesheetEvaluator {\n  #evaluated = new WeakSet();\n  #fetchProms = [];\n  /**\n  * Flipped to true if stylesheets that cannot be natively inlined are detected by the stylesheetEvaluator class\n  * Used at harvest time to denote that all subsequent payloads are subject to this and customers should be advised to handle crossorigin decoration\n  * */\n  invalidStylesheetsDetected = false;\n  failedToFix = 0;\n\n  /**\n   * this works by checking (only ever once) each cssRules obj in the style sheets array. The try/catch will catch an error if the cssRules obj blocks access, triggering the module to try to \"fix\" the asset`. Returns the count of incomplete assets discovered.\n   * @returns {Number}\n   */\n  evaluate() {\n    let incompletes = 0;\n    if (isBrowserScope) {\n      for (let i = 0; i < Object.keys(document.styleSheets).length; i++) {\n        if (!this.#evaluated.has(document.styleSheets[i])) {\n          this.#evaluated.add(document.styleSheets[i]);\n          try {\n            // eslint-disable-next-line\n            const temp = document.styleSheets[i].cssRules;\n          } catch (err) {\n            if (!document.styleSheets[i].href) return;\n            incompletes++;\n            this.#fetchProms.push(this.#fetchAndOverride(document.styleSheets[i]));\n          }\n        }\n      }\n    }\n    if (incompletes) this.invalidStylesheetsDetected = true;\n    return incompletes;\n  }\n\n  /**\n   * Resolves promise once all stylesheets have been fetched and overridden\n   * @returns {Promise}\n   */\n  async fix() {\n    await Promise.all(this.#fetchProms);\n    this.#fetchProms = [];\n    const failedToFix = this.failedToFix;\n    this.failedToFix = 0;\n    return failedToFix;\n  }\n\n  /**\n  * Fetches stylesheet contents and overrides the target getters\n  * @param {*} target - The stylesheet object target - ex. document.styleSheets[0]\n  * @param {*} href - The asset href to fetch\n  * @returns {Promise}\n  */\n  async #fetchAndOverride(target) {\n    if (!target?.href) return;\n    try {\n      const stylesheetContents = await originals.FETCH.bind(window)(target.href);\n      if (!stylesheetContents.ok) {\n        this.failedToFix++;\n        return;\n      }\n      const stylesheetText = await stylesheetContents.text();\n      try {\n        const cssSheet = new CSSStyleSheet();\n        await cssSheet.replace(stylesheetText);\n        Object.defineProperty(target, 'cssRules', {\n          get() {\n            return cssSheet.cssRules;\n          }\n        });\n        Object.defineProperty(target, 'rules', {\n          get() {\n            return cssSheet.rules;\n          }\n        });\n      } catch (err) {\n        // cant make new dynamic stylesheets, browser likely doesn't support `.replace()`...\n        // this is appended in prep of forking rrweb\n        Object.defineProperty(target, 'cssText', {\n          get() {\n            return stylesheetText;\n          }\n        });\n        this.failedToFix++;\n      }\n    } catch (err) {\n      // failed to fetch\n      this.failedToFix++;\n    }\n  }\n}\nexport const stylesheetEvaluator = new StylesheetEvaluator();"],"names":["onReplayReady","sessionReplayInitialized","Promise","resolve","sharedChannel","Object","freeze","HarvestScheduler","_SharedContext","endpoint","opts","parent","_this$sharedContext","_this","_classCallCheck","started","timeoutHandle","aborted","harvest","Harvest","sharedContext","subscribeToEOL","unload","bind","_assertThisInitialized","ee","on","SESSION_EVENTS","runHarvest","forceNoRetry","_inherits","_createClass","key","value","this","onUnload","interval","initialDelay","scheduleHarvest","permanently","arguments","length","undefined","clearTimeout","delay","_this2","setTimeout","_this3","submitMethod","payload","cbRanAfterSend","result","retry","onHarvestFinished","harvests","getPayload","submitData","isFinalHarvest","prototype","toString","call","push","apply","_toConsumableArray","send","args","sendX","raw","_send","forEach","cbFinished","customUrl","onFinished","sent","retryDelay","SharedContext","isWorkerScope","globalScope","origClose","_step","_iterator","_createForOfIteratorHelper","s","n","done","task","err","e","f","cb","isBrowserScope","subscribeToVisibilityChange","windowAddEventListener","Aggregate","_AggregateBase","agentIdentifier","aggregator","FEATURE_NAME","harvestTimeSeconds","getConfigurationValue","initialized","blocked","gzipper","u8","session","getRuntime","mode","state","sessionReplayMode","MODE","entitled","timeKeeper","recorder","handle","SUPPORTABILITY_METRIC_CHANNEL","FEATURE_NAMES","scheduler","abort","ABORT_REASONS","_this$recorder","stopRecording","_this$recorder2","startRecording","type","data","SESSION_EVENT_TYPES","sessionReplay","prepareHarvest","registerHandler","SR_EVENT_EMITTER_TYPES","switchToFull","initializeRecording","featureName","forceStop","errorNoticed","currentBufferTarget","hasError","_getConfigurationValu","error_sampling_rate","sampling_rate","autoStart","block_selector","mask_text_selector","mask_all_inputs","inline_stylesheet","inline_images","collect_fonts","waitForFlags","then","_ref","_this$recorder3","flagOn","_slicedToArray","deregisterDrain","recording","drain","Math","random","_args$recorder","startTimer","syncWithSessionManager","_initializeRecording","_asyncToGenerator","_regeneratorRuntime","mark","_callee","errorSample","fullSample","ignoreSession","_this$recorder4","_getRuntime3","_yield$import","Recorder","wrap","_context","prev","next","abrupt","isNew","getEvents","prepUtils","t0","stop","_x","_x2","_x3","_prepUtils","_callee2","_yield$import2","gzipSync","strToU8","_context2","_this$timeKeeper","ready","recorderEvents","events","getHarvestContents","body","len","concat","map","__serialized","stringify","join","gzip","_ref2","_objectWithoutProperties","_excluded","MAX_PAYLOAD_SIZE","sessionReplaySentFirstChunk","clearBuffer","_recorderEvents","_info$jsAttributes","_events","_events2","_events$","_events3","_agentRuntime$appMeta","agentRuntime","info","getInfo","endUserId","jsAttributes","RRWEB_EVENT_TYPES","lastMeta","hasMeta","unshift","slice","find","x","relativeNow","now","firstEventTimestamp","timestamp","lastEventTimestamp","firstTimestamp","correctAbsoluteTimestamp","cycleTimestamp","lastTimestamp","convertRelativeTimestamp","agentMetadata","appMetadata","agents","qs","browser_monitoring_key","licenseKey","app_id","applicationID","protocol_version","attributes","encodeObj","_objectSpread","content_encoding","entityGuid","getDuration","agentVersion","version","rst","hasSnapshot","isFirstChunk","decompressedBytes","payloadBytesEstimation","invalidStylesheetsDetected","stylesheetEvaluator","inlinedAllStylesheets","RRWEB_VERSION","QUERY_PARAM_PADDING","substring","status","stopTimer","forceHarvest","_this$recorder5","_this$recorder5$stopR","_this$recorder6","_this$recorder6$stopR","_this$recorder7","_this$recorder7$clear","reason","warn","message","sm","clearTimestamps","emit","_this$recorder8","_this$recorder9","_this$recorder9$clear","_this$recorder10","write","AggregateBase","_defineProperty","_evaluated","WeakMap","_fetchProms","_fetchAndOverride","WeakSet","StylesheetEvaluator","_classPrivateMethodInitSpec","_classPrivateFieldInitSpec","writable","incompletes","i","keys","document","styleSheets","_classPrivateFieldGet","has","add","cssRules","href","_classPrivateMethodGet","_fetchAndOverride2","_fix","failedToFix","all","_classPrivateFieldSet","_fetchAndOverride3","target","stylesheetContents","stylesheetText","cssSheet","originals","window","ok","text","CSSStyleSheet","replace","defineProperty","get","rules","t1"],"sourceRoot":""}