{"version":3,"file":"static/js/2359.778516b0.chunk.js","mappings":"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,CAAA,CA/B2B,GAATA,EACJC,MAAoB,CAAC,C,sBCJtC,IA+FMU,EA/FgB,CACpB,OACA,gBACA,UACA,cACA,YACA,WACA,mBACA,eACA,UACA,QACA,cACA,UACA,oBACA,kBACA,mBACA,gBACA,kBACA,kBACA,oBACA,oBACA,cACA,mBACA,kBACA,sBACA,qBACA,uBACA,iBACA,cACA,mBACA,sBACA,kBACA,kBACA,mBACA,sBACA,gBACA,kBACA,qBACA,kBACA,oBACA,mBACA,mBACA,gBACA,mBACA,oBACA,kBACA,iBACA,qBACA,mBACA,kBACA,kBACA,mBACA,iBACA,mBACA,oBACA,sBACA,oBACA,oBACA,uBACA,mBACA,qBACA,iBACA,sBACA,mBACA,oBACA,oBACA,kBACA,oBACA,kBACA,mBACA,0BACA,uBACA,mBACA,sBACA,sBACA,sBACA,kBACA,mBACA,mBACA,mBACA,qBACA,mBACA,aACA,OACA,aACA,WACA,aACA,aACA,OACA,qBACA,YACA,YACA,UAG6BC,QAC7B,SAACC,EAAK3G,GAEJ,OADA2G,EAAI3G,IAAO,EACJ2G,CACT,GACA,CAAC,GAGH,K,0hBCtEA,IAEMC,EACJ,8HAuGWC,EAAgB,IAtGV,oBAAAC,KAAArF,EAAAA,EAAAA,GAAA,KAAAqF,GAAA,KACTC,sBAA8C,CAAC,EAAE,KACjDC,sBAAkC,GAAG,KACrCC,YAAa,EAAK,KAClBC,SAAqB,CAAC,CAAE,CA+F/B,OA/F8BxF,EAAAA,EAAAA,GAAAoF,EAAA,EAAA9G,IAAA,OAAAP,MAE/B,SAAK0H,GACH9F,KAAK4F,WAAaE,IAAYC,EAAAA,EAAAA,IAChC,GAAC,CAAApH,IAAA,uBAAAP,MAED,SACEyH,EACA5B,EACA+B,GAEA,IAAIhG,KAAK4F,WAAT,CACA,IAAMK,GAA0BC,EAAAA,EAAAA,IAAqBL,EAAU5B,GACzDkC,GAAsBC,EAAAA,EAAAA,IAC1BP,EACAvC,EAAAA,EAAAA,SACA0C,EACAjE,OAAOsE,KAAKJ,IAEdjG,KAAK0F,sBAAwBO,EAC7BjG,KAAK2F,sBAAwBQ,EAC7BnG,K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","sources":["constants/AppsmithActionConstants/ActionConstants.tsx","constants/BindingsConstants.ts","ee/entities/DataTree/types.ts","ce/workers/Evaluation/evalWorkerActions.ts","entities/AppsmithConsole/index.ts","entities/Replay/replayUtils.ts","utils/MessageUtil.ts","workers/Evaluation/JSObject/Collection.ts","workers/Evaluation/JSObject/jsPropertiesState.ts","workers/Evaluation/JSObject/utils.ts","workers/Evaluation/dataStore/index.ts","workers/Evaluation/domApis.ts","workers/Evaluation/errorModifier.ts","workers/Evaluation/evalTreeWithChanges.ts","workers/Evaluation/fns/overrides/console.ts","workers/Evaluation/fns/overrides/interval.ts","workers/Evaluation/fns/utils/fnGuard.ts","entities/Replay/ReplayEntity/ReplayCanvas.ts","ce/workers/common/DependencyMap/utils/getEntityDependenciesByType.ts","workers/common/DependencyMap/utils/getEntityDependencies.ts","entities/DependencyMap/DependencyMapUtils.ts","workers/Evaluation/handlers/evalTree.ts","workers/Evaluation/handlers/updateActionData.ts","workers/Evaluation/helpers.ts","workers/Evaluation/validations.ts","workers/common/DataTreeEvaluator/utils.ts","workers/common/DataTreeEvaluator/validationUtils.ts"],"sourcesContent":["import type { ErrorActionPayload } from \"sagas/ErrorSagas\";\nimport type { ActionResponse } from \"api/ActionAPI\";\nimport { PluginType } from \"entities/Action\";\nimport queryActionSettingsConfig from \"constants/AppsmithActionConstants/formConfig/QuerySettingsConfig\";\nimport apiActionSettingsConfig from \"constants/AppsmithActionConstants/formConfig/ApiSettingsConfig\";\nimport apiActionEditorConfig from \"constants/AppsmithActionConstants/formConfig/ApiEditorConfigs\";\nimport saasActionSettingsConfig from \"constants/AppsmithActionConstants/formConfig/GoogleSheetsSettingsConfig\";\nimport apiActionDependencyConfig from \"constants/AppsmithActionConstants/formConfig/ApiDependencyConfigs\";\nimport apiActionDatasourceFormButtonConfig from \"constants/AppsmithActionConstants/formConfig/ApiDatasourceFormsButtonConfig\";\nimport type { EntityTypeValue } from \"@appsmith/entities/DataTree/types\";\n\nexport interface ExecuteActionPayloadEvent {\n  type: EventType;\n  callback?: (result: ExecutionResult) => void;\n}\n\nexport interface ExecutionResult {\n  success: boolean;\n}\n\nexport interface TriggerSource {\n  id: string;\n  name: string;\n  entityType?: EntityTypeValue;\n  collectionId?: string;\n  isJSAction?: boolean;\n  actionId?: string;\n}\nexport enum TriggerKind {\n  EVENT_EXECUTION = \"EVENT_EXECUTION\", // Eg. Button onClick\n  JS_FUNCTION_EXECUTION = \"JS_FUNCTION_EXECUTION\", // Executing js function from jsObject page\n}\n\nexport interface ExecuteTriggerPayload {\n  dynamicString: string;\n  event: ExecuteActionPayloadEvent;\n  callbackData?: Array<any>;\n  triggerPropertyName?: string;\n  source?: TriggerSource;\n  widgetId?: string;\n  globalContext?: Record<string, unknown>;\n}\n\nexport type ContentType =\n  | \"application/json\"\n  | \"application/x-www-form-urlencoded\";\n\nexport interface APIHeaders {\n  \"Content-Type\": ContentType;\n  Accept?: string;\n}\n\nexport interface APIRequest {\n  requestId?: string;\n}\n\nexport enum EventType {\n  ON_RESET = \"ON_RESET\",\n  ON_PAGE_LOAD = \"ON_PAGE_LOAD\",\n  ON_PREV_PAGE = \"ON_PREV_PAGE\",\n  ON_NEXT_PAGE = \"ON_NEXT_PAGE\",\n  ON_PAGE_SIZE_CHANGE = \"ON_PAGE_SIZE_CHANGE\",\n  ON_ERROR = \"ON_ERROR\",\n  ON_SUCCESS = \"ON_SUCCESS\",\n  ON_ROW_SELECTED = \"ON_ROW_SELECTED\",\n  ON_SEARCH = \"ON_SEARCH\",\n  ON_CLICK = \"ON_CLICK\",\n  ON_DATA_POINT_CLICK = \"ON_DATA_POINT_CLICK\",\n  ON_FILES_SELECTED = \"ON_FILES_SELECTED\",\n  ON_HOVER = \"ON_HOVER\",\n  ON_TOGGLE = \"ON_TOGGLE\",\n  ON_LOAD = \"ON_LOAD\",\n  ON_MODAL_CLOSE = \"ON_MODAL_CLOSE\",\n  ON_MODAL_SUBMIT = \"ON_MODAL_SUBMIT\",\n  ON_TEXT_CHANGE = \"ON_TEXT_CHANGE\",\n  ON_SUBMIT = \"ON_SUBMIT\",\n  ON_CHECK_CHANGE = \"ON_CHECK_CHANGE\",\n  ON_SWITCH_CHANGE = \"ON_SWITCH_CHANGE\",\n  ON_SELECT = \"ON_SELECT\",\n  ON_DATE_SELECTED = \"ON_DATE_SELECTED\",\n  ON_DATE_RANGE_SELECTED = \"ON_DATE_RANGE_SELECTED\",\n  ON_DROPDOWN_OPEN = \"ON_DROPDOWN_OPEN\",\n  ON_DROPDOWN_CLOSE = \"ON_DROPDOWN_CLOSE\",\n  ON_OPTION_CHANGE = \"ON_OPTION_CHANGE\",\n  ON_FILTER_CHANGE = \"ON_FILTER_CHANGE\",\n  ON_FILTER_UPDATE = \"ON_FILTER_UPDATE\",\n  ON_MARKER_CLICK = \"ON_MARKER_CLICK\",\n  ON_CREATE_MARKER = \"ON_CREATE_MARKER\",\n  ON_TAB_CHANGE = \"ON_TAB_CHANGE\",\n  ON_VIDEO_START = \"ON_VIDEO_START\",\n  ON_VIDEO_END = \"ON_VIDEO_END\",\n  ON_VIDEO_PLAY = \"ON_VIDEO_PLAY\",\n  ON_VIDEO_PAUSE = \"ON_VIDEO_PAUSE\",\n  ON_AUDIO_START = \"ON_AUDIO_START\",\n  ON_AUDIO_END = \"ON_AUDIO_END\",\n  ON_AUDIO_PLAY = \"ON_AUDIO_PLAY\",\n  ON_AUDIO_PAUSE = \"ON_AUDIO_PAUSE\",\n  ON_RATE_CHANGED = \"ON_RATE_CHANGED\",\n  ON_IFRAME_URL_CHANGED = \"ON_IFRAME_URL_CHANGED\",\n  ON_IFRAME_SRC_DOC_CHANGED = \"ON_IFRAME_SRC_DOC_CHANGED\",\n  ON_IFRAME_MESSAGE_RECEIVED = \"ON_IFRAME_MESSAGE_RECEIVED\",\n  ON_SNIPPET_EXECUTE = \"ON_SNIPPET_EXECUTE\",\n  ON_SORT = \"ON_SORT\",\n  ON_CHECKBOX_GROUP_SELECTION_CHANGE = \"ON_CHECKBOX_GROUP_SELECTION_CHANGE\",\n  ON_LIST_PAGE_CHANGE = \"ON_LIST_PAGE_CHANGE\",\n  ON_RECORDING_START = \"ON_RECORDING_START\",\n  ON_RECORDING_COMPLETE = \"ON_RECORDING_COMPLETE\",\n  ON_SWITCH_GROUP_SELECTION_CHANGE = \"ON_SWITCH_GROUP_SELECTION_CHANGE\",\n  ON_JS_FUNCTION_EXECUTE = \"ON_JS_FUNCTION_EXECUTE\",\n  ON_CAMERA_IMAGE_CAPTURE = \"ON_CAMERA_IMAGE_CAPTURE\",\n  ON_CAMERA_IMAGE_SAVE = \"ON_CAMERA_IMAGE_SAVE\",\n  ON_CAMERA_VIDEO_RECORDING_START = \"ON_CAMERA_VIDEO_RECORDING_START\",\n  ON_CAMERA_VIDEO_RECORDING_STOP = \"ON_CAMERA_VIDEO_RECORDING_STOP\",\n  ON_CAMERA_VIDEO_RECORDING_SAVE = \"ON_CAMERA_VIDEO_RECORDING_SAVE\",\n  ON_ENTER_KEY_PRESS = \"ON_ENTER_KEY_PRESS\",\n  ON_BLUR = \"ON_BLUR\",\n  ON_FOCUS = \"ON_FOCUS\",\n  ON_BULK_SAVE = \"ON_BULK_SAVE\",\n  ON_BULK_DISCARD = \"ON_BULK_DISCARD\",\n  ON_ROW_SAVE = \"ON_ROW_SAVE\",\n  ON_ROW_DISCARD = \"ON_ROW_DISCARD\",\n  ON_CODE_DETECTED = \"ON_CODE_DETECTED\",\n  ON_ADD_NEW_ROW_SAVE = \"ON_ADD_NEW_ROW_SAVE\",\n  ON_ADD_NEW_ROW_DISCARD = \"ON_ADD_NEW_ROW_DISCARD\",\n  CUSTOM_WIDGET_EVENT = \"CUSTOM_WIDGET_EVENT\",\n}\n\nexport interface PageAction {\n  id: string;\n  pluginType: PluginType;\n  name: string;\n  jsonPathKeys: string[];\n  timeoutInMillisecond: number;\n  clientSideExecution?: boolean;\n  collectionId?: string;\n}\n\nexport interface ExecuteErrorPayload extends ErrorActionPayload {\n  actionId: string;\n  isPageLoad?: boolean;\n  data: ActionResponse;\n}\n\nexport interface LayoutOnLoadActionErrors {\n  errorType: string;\n  code: number;\n  message: string;\n}\n\n// Group 1 = datasource (https://www.domain.com)\n// Group 2 = path (/nested/path)\n// Group 3 = params (?param=123&param2=12)\nexport const DATASOURCE_URL_EXACT_MATCH_REGEX =\n  /^(https?:\\/{2}\\S+?)(\\/[\\s\\S]*?)?(\\?(?![^{]*})[\\s\\S]*)?$/;\n\nexport const EXECUTION_PARAM_KEY = \"executionParams\";\nexport const EXECUTION_PARAM_REFERENCE_REGEX = /this.params|this\\?.params/g;\nexport const THIS_DOT_PARAMS_KEY = \"$params\";\n\nexport const RESP_HEADER_DATATYPE = \"X-APPSMITH-DATATYPE\";\nexport const API_REQUEST_HEADERS: APIHeaders = {\n  \"Content-Type\": \"application/json\",\n};\nexport const POSTMAN = \"POSTMAN\";\nexport const CURL = \"CURL\";\nexport const Swagger = \"Swagger\";\n\nexport const defaultActionSettings: Record<PluginType, any> = {\n  [PluginType.API]: apiActionSettingsConfig,\n  [PluginType.DB]: queryActionSettingsConfig,\n  [PluginType.SAAS]: saasActionSettingsConfig,\n  [PluginType.REMOTE]: saasActionSettingsConfig,\n  [PluginType.JS]: [],\n  [PluginType.AI]: saasActionSettingsConfig,\n  [PluginType.INTERNAL]: saasActionSettingsConfig,\n};\n\nexport const defaultActionEditorConfigs: Record<PluginType, any> = {\n  [PluginType.API]: apiActionEditorConfig,\n  [PluginType.DB]: [],\n  [PluginType.SAAS]: [],\n  [PluginType.REMOTE]: [],\n  [PluginType.JS]: [],\n  [PluginType.AI]: [],\n  [PluginType.INTERNAL]: [],\n};\n\nexport const defaultActionDependenciesConfig: Record<\n  PluginType,\n  Record<string, string[]>\n> = {\n  [PluginType.API]: apiActionDependencyConfig,\n  [PluginType.DB]: {},\n  [PluginType.SAAS]: {},\n  [PluginType.REMOTE]: {},\n  [PluginType.JS]: {},\n  [PluginType.AI]: {},\n  [PluginType.INTERNAL]: {},\n};\n\nexport const defaultDatasourceFormButtonConfig: Record<PluginType, string[]> = {\n  [PluginType.API]: apiActionDatasourceFormButtonConfig.API,\n  [PluginType.DB]: apiActionDatasourceFormButtonConfig.DB,\n  [PluginType.SAAS]: apiActionDatasourceFormButtonConfig.SAAS,\n  [PluginType.REMOTE]: apiActionDatasourceFormButtonConfig.REMOTE,\n  [PluginType.JS]: [],\n  [PluginType.AI]: apiActionDatasourceFormButtonConfig.AI,\n  [PluginType.INTERNAL]: [],\n};\n","export const DATA_BIND_REGEX = /{{([\\s\\S]*?)}}/;\nexport const DATA_BIND_REGEX_GLOBAL = /{{([\\s\\S]*?)}}/g;\nexport const AUTOCOMPLETE_MATCH_REGEX = /{{\\s*.*?\\s*}}/g;\nexport const QUOTED_BINDING_REGEX = /[\"']({{[\\s\\S]*?}})[\"']/g;\n","export * from \"ce/entities/DataTree/types\";\nimport { ENTITY_TYPE as CE_ENTITY_TYPE } from \"ce/entities/DataTree/types\";\n\nexport const ENTITY_TYPE = {\n  ...CE_ENTITY_TYPE,\n  MODULE_INPUT: \"MODULE_INPUT\",\n  MODULE_INSTANCE: \"MODULE_INSTANCE\",\n} as const;\n\ntype ValueOf<T> = T[keyof T];\nexport type EntityTypeValue = ValueOf<typeof ENTITY_TYPE>;\n","export enum EVAL_WORKER_SYNC_ACTION {\n  SETUP = \"SETUP\",\n  EVAL_TREE = \"EVAL_TREE\",\n  EVAL_ACTION_BINDINGS = \"EVAL_ACTION_BINDINGS\",\n  CLEAR_CACHE = \"CLEAR_CACHE\",\n  VALIDATE_PROPERTY = \"VALIDATE_PROPERTY\",\n  UNDO = \"undo\",\n  REDO = \"redo\",\n  UPDATE_REPLAY_OBJECT = \"UPDATE_REPLAY_OBJECT\",\n  SET_EVALUATION_VERSION = \"SET_EVALUATION_VERSION\",\n  INIT_FORM_EVAL = \"INIT_FORM_EVAL\",\n  UNINSTALL_LIBRARY = \"UNINSTALL_LIBRARY\",\n  LINT_TREE = \"LINT_TREE\",\n  UPDATE_ACTION_DATA = \"UPDATE_ACTION_DATA\",\n}\n\nexport enum EVAL_WORKER_ASYNC_ACTION {\n  EVAL_TRIGGER = \"EVAL_TRIGGER\",\n  EVAL_EXPRESSION = \"EVAL_EXPRESSION\",\n  LOAD_LIBRARIES = \"LOAD_LIBRARIES\",\n  INSTALL_LIBRARY = \"INSTALL_LIBRARY\",\n}\n\nexport const EVAL_WORKER_ACTIONS = {\n  ...EVAL_WORKER_SYNC_ACTION,\n  ...EVAL_WORKER_ASYNC_ACTION,\n};\n\nexport enum MAIN_THREAD_ACTION {\n  PROCESS_TRIGGER = \"PROCESS_TRIGGER\",\n  PROCESS_BATCHED_TRIGGERS = \"PROCESS_BATCHED_TRIGGERS\",\n  PROCESS_STORE_UPDATES = \"PROCESS_STORE_UPDATES\",\n  PROCESS_LOGS = \"PROCESS_LOGS\",\n  LINT_TREE = \"LINT_TREE\",\n  PROCESS_JS_FUNCTION_EXECUTION = \"PROCESS_JS_FUNCTION_EXECUTION\",\n  UPDATE_DATATREE = \"UPDATE_DATATREE\",\n  SET_META_PROP_FROM_SETTER = \"SET_META_PROP_FROM_SETTER\",\n}\n","import type { ReduxAction } from \"@appsmith/constants/ReduxActionConstants\";\nimport type LOG_TYPE from \"./logtype\";\nimport type { PropertyEvaluationErrorType } from \"utils/DynamicBindingUtils\";\nimport type { PluginType } from \"entities/Action\";\nimport type { HTTP_METHOD } from \"constants/ApiEditorConstants/CommonApiConstants\";\nimport type {\n  ENTITY_TYPE,\n  PLATFORM_ERROR,\n} from \"@appsmith/entities/AppsmithConsole/utils\";\n\nexport type Methods =\n  | \"log\"\n  | \"debug\"\n  | \"info\"\n  | \"warn\"\n  | \"error\"\n  | \"table\"\n  | \"clear\"\n  | \"time\"\n  | \"timeEnd\"\n  | \"count\"\n  | \"assert\";\n\nexport interface LogObject {\n  method: Methods | \"result\";\n  data: any[];\n  timestamp: string;\n  id: string;\n  severity: Severity;\n  source: SourceEntity;\n}\n\nexport type ErrorType = PropertyEvaluationErrorType | PLATFORM_ERROR;\n\nexport enum Severity {\n  // Everything, irrespective of what the user should see or not\n  // DEBUG = \"debug\",\n  // Something the dev user should probably know about\n  INFO = \"info\",\n  // Doesn't break the app, but can cause slowdowns / ux issues/ unexpected behaviour\n  WARNING = \"warning\",\n  // Can cause an error in some cases/ single widget, app will work in other cases\n  ERROR = \"error\",\n  // Makes the app unusable, can't progress without fixing this.\n  // CRITICAL = \"critical\",\n}\n\nexport interface UserAction {\n  // Label is used to display the\n  label: string;\n  // As there can be multiple errors of the same base type at the same time\n  // and we need to be able to tell the difference,\n  // these action types should have a dynamic `id` associated with them\n  // or we should use JS callback functions instead\n  reduxAction: ReduxAction<unknown>;\n}\n\nexport interface SourceEntity {\n  type: ENTITY_TYPE;\n  // Widget or action name\n  name: string;\n  // Id of the widget or action\n  id: string;\n  // property path of the child\n  propertyPath?: string;\n  // plugin type of the action or type of widget\n  pluginType?: PluginType | string;\n  // http method of the api. (Only for api actions)\n  httpMethod?: HTTP_METHOD;\n}\n\nexport enum LOG_CATEGORY {\n  USER_GENERATED = \"USER_GENERATED\",\n  PLATFORM_GENERATED = \"PLATFORM_GENERATED\",\n}\n\nexport interface LogActionPayload {\n  // Log id, used for updating or deleting\n  id?: string;\n  // icon id, used in finding appropriate icons.\n  iconId?: string;\n  // What is the log about. Is it a datasource update, widget update, eval error etc.\n  logType?: LOG_TYPE;\n  // This is the preview of the log that the user sees.\n  text: string;\n  // The environment in which the log was generated.\n  environmentName?: string;\n  // Number of times this log has been repeated\n  occurrenceCount?: number;\n  // Deconstructed data of the log, this includes the whole nested objects/arrays/strings etc.\n  logData?: any[];\n  // messages associated with this event\n  messages?: Array<Message>;\n  // Time taken for the event to complete\n  timeTaken?: string;\n  // \"where\" source entity and propertyPsath.\n  source?: SourceEntity;\n  // Snapshot KV pair of scope variables or state associated with this event.\n  state?: Record<string, any>;\n  // Any other data required for analytics\n  analytics?: Record<string, any>;\n  // plugin error details if any (only for plugin errors).\n  pluginErrorDetails?: any;\n  meta?: Record<string, any>;\n}\n\nexport interface Message {\n  // More contextual message than `text`\n  message: Error;\n  type?: ErrorType;\n  subType?: string;\n  lineNumber?: number;\n  character?: number;\n  // The section of code being referred to\n  // codeSegment?: string;\n}\n\nexport interface Log extends LogActionPayload {\n  severity: Severity;\n  // Is the log system generated or user generated\n  category: LOG_CATEGORY;\n  // \"when\" did this event happen\n  timestamp: string;\n  // expanded state of the log.\n  isExpanded: boolean;\n}\n\n/**\n * Example:\n * \"Api timed out\"\n * {\n *   type: ActionError.EXECUTION_TIMEOUT,\n *   timeoutMs: 10000,\n *   severity: Severity.ERROR,\n *   message: \"Action execution timedout after 10 seconds\",\n *   source: {\n *     type: ENTITY_TYPE.ACTION,\n *     name: \"Api1\",\n *     id: \"a12345\",\n *     propertyPath: \"run\",\n *   },\n *   timestamp: new Date(),\n *   state: {},\n *   userActions: [\n *     {\n *       label: \"Increase timeout by 5 seconds\",\n *       reduxAction: {\n *         type: \"ACTION_INCREASE_TIMEOUT\",\n *         payload: { actionId: \"abcdef\", value: 5000 },\n *       },\n *     },\n *   ]\n * }\n */\n","import type { Diff } from \"deep-diff\";\nimport { get, isArray, isEmpty, set } from \"lodash\";\nexport const UPDATES = \"propertyUpdates\";\nexport const REPLAY_DELAY = 300;\nexport const REPLAY_FOCUS_DELAY = 100;\nexport const TOASTS = \"toasts\";\nexport const FOCUSES = \"needsFocus\";\nexport const WIDGETS = \"widgets\";\n\n/**\n * checks the existing value and sets he propertyUpdate if required\n *\n * @param replay\n * @param path\n * @param value\n * @returns\n */\nexport function setPropertyUpdate(\n  replay: any,\n  path: string[],\n  value: string[],\n) {\n  const existingPathValue = get(replay, path);\n\n  if (!existingPathValue || existingPathValue.length > 2) {\n    set(replay, path, value);\n    set(replay, UPDATES, true);\n  }\n}\n\n/**\n * pushes value to array element in array of objects\n *\n * @param obj\n * @param key\n * @param value\n * @returns\n */\nexport function addToArray(obj: any, key: string, value: any) {\n  if (!obj) return;\n\n  if (obj[key] && Array.isArray(obj[key])) {\n    obj[key].push(value);\n  } else {\n    obj[key] = [value];\n  }\n}\n\n/**\n * creates paths changed from diffs  array\n *\n * @param diffs\n * @returns\n */\nexport function getPathsFromDiff(diffs: Array<Diff<any, any>>) {\n  const paths = [];\n\n  for (const diff of diffs) {\n    if (!diff.path || !Array.isArray(diff.path)) continue;\n    paths.push(diff.path.join(\".\"));\n  }\n\n  return paths;\n}\n\n/**\n * creates paths changed from diffs  array\n *\n * @param path\n * @returns\n */\nexport function pathArrayToString(path?: string[]) {\n  let stringPath = \"\";\n  if (!path || path.length === 0) return stringPath;\n  stringPath = path[0];\n  for (let i = 1; i < path.length; i++) {\n    stringPath += isNaN(parseInt(path[i])) ? `.${path[i]}` : `[${path[i]}]`;\n  }\n  return stringPath;\n}\n\n/**\n * Retrieves field config and parent section using the config property\n *\n * @param config\n * @param field\n * @param parentSection\n * @returns\n */\nexport function findFieldInfo(\n  config: Array<any>,\n  field: string,\n  parentSection = \"\",\n) {\n  let result = {};\n  if (!config || !isArray(config)) return result;\n  for (const conf of config) {\n    if (conf.configProperty === field) {\n      result = { conf, parentSection };\n      break;\n    } else if (conf.children) {\n      parentSection = conf.sectionName || parentSection;\n      result = findFieldInfo(conf.children, field, parentSection);\n      if (!isEmpty(result)) break;\n    }\n  }\n  return result;\n}\n","/**\n * This file contains the utility function to send and receive messages from the worker.\n * TRequestMessage<TBody> is used to send a request to/from the worker.\n * TResponseMessage<TBody> is used to send a response to/from the worker.\n * TDefaultMessage<TBody> is used to send a message to/from worker. Does not expect a response.\n */\n\nexport enum MessageType {\n  REQUEST = \"REQUEST\",\n  RESPONSE = \"RESPONSE\",\n  DEFAULT = \"DEFAULT\",\n}\n\ninterface TRequestMessage<TBody> {\n  body: TBody;\n  messageId: string;\n  messageType: MessageType.REQUEST;\n}\n\ninterface TResponseMessage<TBody> {\n  body: TBody;\n  messageId: string;\n  messageType: MessageType.RESPONSE;\n}\n\nexport interface TDefaultMessage<TBody> {\n  messageId?: string;\n  body: TBody;\n  messageType: MessageType.DEFAULT;\n}\n\nexport type TMessage<TBody> =\n  | TRequestMessage<TBody>\n  | TResponseMessage<TBody>\n  | TDefaultMessage<TBody>;\n\n/** Avoid from using postMessage directly.\n * This function should be used to send messages to the worker and back.\n * Purpose: To have some standardization in the messages that are transferred.\n * TODO: Add support for window postMessage options\n * TODO: Add support for transferable objects.\n */\nexport function sendMessage(\n  this: Worker | typeof globalThis,\n  message: TMessage<unknown>,\n) {\n  this.postMessage(message);\n}\n","import { getEntityNameAndPropertyPath } from \"@appsmith/workers/Evaluation/evaluationUtils\";\nimport { klona } from \"klona/full\";\nimport { get, set } from \"lodash\";\nimport TriggerEmitter, { BatchKey } from \"../fns/utils/TriggerEmitter\";\nimport ExecutionMetaData from \"../fns/utils/ExecutionMetaData\";\nimport type { JSActionEntity } from \"@appsmith/entities/DataTree/types\";\n\nexport enum PatchType {\n  \"SET\" = \"SET\",\n  \"GET\" = \"GET\",\n}\n\nexport interface Patch {\n  path: string;\n  method: PatchType;\n  value?: unknown;\n}\n\nexport type VariableState = Record<string, Record<string, any>>;\n\ntype CurrentJSCollectionState = Record<string, any>;\ntype ResolvedFunctions = Record<string, any>;\n\nexport default class JSObjectCollection {\n  private static resolvedFunctions: ResolvedFunctions = {};\n  private static unEvalState: CurrentJSCollectionState = {};\n  private static variableState: VariableState = {};\n  private static prevUnEvalState: CurrentJSCollectionState = {};\n\n  static setResolvedFunctions(resolvedFunctions: ResolvedFunctions) {\n    this.resolvedFunctions = resolvedFunctions;\n  }\n\n  static updateResolvedFunctions(path: string, value: any) {\n    set(this.resolvedFunctions, path, value);\n  }\n\n  static deleteResolvedFunction(entityName: string) {\n    delete this.resolvedFunctions[entityName];\n  }\n\n  static getResolvedFunctions() {\n    return this.resolvedFunctions;\n  }\n\n  static updateUnEvalState(path: string, value: any) {\n    set(this.unEvalState, path, value);\n  }\n\n  static deleteUnEvalState(entityName: string) {\n    delete this.unEvalState[entityName];\n  }\n\n  static getUnEvalState() {\n    return this.unEvalState;\n  }\n\n  static setPrevUnEvalState({\n    fullPath,\n    unEvalValue,\n  }: {\n    fullPath: string;\n    unEvalValue: unknown;\n  }) {\n    set(this.prevUnEvalState, fullPath, unEvalValue);\n  }\n\n  static getPrevUnEvalState({ fullPath }: { fullPath: string }) {\n    return get(this.prevUnEvalState, fullPath);\n  }\n\n  static setVariableValue(variableValue: unknown, fullPropertyPath: string) {\n    const { entityName, propertyPath } =\n      getEntityNameAndPropertyPath(fullPropertyPath);\n    const newVarState = { ...this.variableState[entityName] };\n    newVarState[propertyPath] = variableValue;\n    this.variableState[entityName] = newVarState;\n    JSObjectCollection.clearCachedVariablesForEvaluationContext(entityName);\n  }\n\n  static getVariableState(\n    JSObjectName?: string,\n  ): VariableState | Record<string, any> {\n    if (!JSObjectName || !this.variableState) return klona(this.variableState);\n    return this.variableState[JSObjectName];\n  }\n\n  static removeVariable(fullPath: string) {\n    const { entityName, propertyPath } = getEntityNameAndPropertyPath(fullPath);\n    const jsObject = this.variableState[entityName];\n    if (jsObject && jsObject[propertyPath] !== undefined)\n      delete jsObject[propertyPath];\n  }\n\n  /**Map<JSObjectName, Map<variableName, variableValue> */\n  static cachedJSVariablesByEntityName: Record<string, JSActionEntity> = {};\n\n  /**Computes  Map<JSObjectName, Map<variableName, variableValue> with getters & setters to track JS mutations\n   * We cache and reuse this map. We recreate only when the JSObject's content changes or when any of the variables\n   * gets evaluated\n   */\n  static getVariablesForEvaluationContext(entityName: string) {\n    if (JSObjectCollection.cachedJSVariablesByEntityName[entityName])\n      return JSObjectCollection.cachedJSVariablesByEntityName[entityName];\n    const varState = JSObjectCollection.getVariableState(entityName);\n    const variables = Object.entries(varState);\n    const newJSObject = {} as JSActionEntity;\n\n    for (const [varName, varValue] of variables) {\n      let variable = varValue;\n      Object.defineProperty(newJSObject, varName, {\n        enumerable: true,\n        configurable: true,\n        get() {\n          TriggerEmitter.emit(BatchKey.process_js_variable_updates, {\n            path: `${entityName}.${varName}`,\n            method: PatchType.GET,\n          });\n          return variable;\n        },\n        set(value) {\n          TriggerEmitter.emit(BatchKey.process_js_variable_updates, {\n            path: `${entityName}.${varName}`,\n            method: PatchType.SET,\n            value,\n          });\n          variable = value;\n        },\n      });\n    }\n    ExecutionMetaData.setExecutionMetaData({\n      enableJSVarUpdateTracking: true,\n    });\n    JSObjectCollection.cachedJSVariablesByEntityName[entityName] = newJSObject;\n    return JSObjectCollection.cachedJSVariablesByEntityName[entityName];\n  }\n\n  static clearCachedVariablesForEvaluationContext(entityName: string) {\n    delete JSObjectCollection.cachedJSVariablesByEntityName[entityName];\n  }\n\n  static clear() {\n    this.variableState = {};\n    this.unEvalState = {};\n    this.prevUnEvalState = {};\n    this.resolvedFunctions = {};\n  }\n}\n","import type { JSPropertyPosition, TParsedJSProperty } from \"@shared/ast\";\nimport { isJSFunctionProperty } from \"@shared/ast\";\nimport { set } from \"lodash\";\n\nclass JsPropertiesState {\n  private jsPropertiesState: TJSPropertiesState = {};\n\n  delete(jsObjectName: string) {\n    delete this.jsPropertiesState[`${jsObjectName}`];\n  }\n\n  update(jsObjectName: string, properties: TParsedJSProperty[]) {\n    for (const jsObjectProperty of properties) {\n      const { key, position, rawContent, type } = jsObjectProperty;\n      if (isJSFunctionProperty(jsObjectProperty)) {\n        set(\n          this.jsPropertiesState,\n          `[${jsObjectName}.${jsObjectProperty.key}]`,\n          {\n            position: position,\n            value: rawContent,\n            isMarkedAsync: jsObjectProperty.isMarkedAsync,\n          },\n        );\n      } else if (type !== \"literal\") {\n        set(this.jsPropertiesState, `[${jsObjectName}.${key}]`, {\n          position: position,\n          value: rawContent,\n        });\n      }\n    }\n  }\n\n  getMap() {\n    return this.jsPropertiesState;\n  }\n}\n\nexport const jsPropertiesState = new JsPropertiesState();\n\nexport interface TBasePropertyState {\n  value: string;\n  position: JSPropertyPosition;\n}\nexport interface TJSFunctionPropertyState extends TBasePropertyState {\n  isMarkedAsync: boolean;\n}\n\nexport type TJSpropertyState = TBasePropertyState | TJSFunctionPropertyState;\n\nexport type TJSPropertiesState = Record<\n  string,\n  Record<string, TJSpropertyState>\n>;\n","import type {\n  JSActionEntityConfig,\n  JSActionEntity,\n} from \"@appsmith/entities/DataTree/types\";\nimport type {\n  ConfigTree,\n  DataTree,\n  DataTreeEntity,\n} from \"entities/DataTree/dataTreeTypes\";\nimport { EvaluationSubstitutionType } from \"entities/DataTree/dataTreeFactory\";\nimport type { ParsedBody, ParsedJSSubAction } from \"utils/JSPaneUtils\";\nimport { unset, set, get, find } from \"lodash\";\nimport type {\n  BatchedJSExecutionData,\n  BatchedJSExecutionErrors,\n  JSCollectionData,\n  JSExecutionData,\n  JSExecutionError,\n} from \"@appsmith/reducers/entityReducers/jsActionsReducer\";\nimport { select } from \"redux-saga/effects\";\nimport type { JSAction } from \"entities/JSCollection\";\nimport { getAllJSCollections } from \"@appsmith/selectors/entitiesSelector\";\nimport {\n  getEntityNameAndPropertyPath,\n  isJSAction,\n} from \"@appsmith/workers/Evaluation/evaluationUtils\";\nimport JSObjectCollection from \"./Collection\";\n\n/**\n * here we add/remove the properties (variables and actions) which got added/removed from the JSObject parsedBody.\n  NOTE: For other entity below logic is maintained in DataTreeFactory, for JSObject we handle it inside evaluations\n * \n * @param parsedBody \n * @param jsCollection \n * @param unEvalTree \n * @returns \n */\nexport const updateJSCollectionInUnEvalTree = (\n  parsedBody: ParsedBody,\n  jsCollection: JSActionEntity,\n  unEvalTree: DataTree,\n  configTree: ConfigTree,\n  entityName: string,\n) => {\n  // jsCollection here means unEvalTree JSObject\n  const modifiedUnEvalTree = unEvalTree;\n  const functionsList: Array<string> = [];\n  const jsEntityConfig = configTree[entityName] as JSActionEntityConfig;\n  const varList: Array<string> | undefined = jsEntityConfig?.variables;\n  Object.keys(jsEntityConfig?.meta).forEach((action) => {\n    functionsList.push(action);\n  });\n  const oldConfig = jsEntityConfig;\n\n  if (parsedBody.actions && parsedBody.actions.length > 0) {\n    for (let i = 0; i < parsedBody.actions.length; i++) {\n      const action = parsedBody.actions[i];\n      if (jsCollection.hasOwnProperty(action.name)) {\n        if (jsCollection[action.name] !== action.body) {\n          const data = get(\n            modifiedUnEvalTree,\n            `${entityName}.${action.name}.data`,\n            {},\n          );\n          set(\n            modifiedUnEvalTree,\n            `${entityName}.${action.name}`,\n            new String(action.body),\n          );\n\n          set(modifiedUnEvalTree, `${entityName}.${action.name}.data`, data);\n        }\n      } else {\n        const reactivePaths = oldConfig.reactivePaths;\n\n        reactivePaths[action.name] =\n          EvaluationSubstitutionType.SMART_SUBSTITUTE;\n        reactivePaths[`${action.name}.data`] =\n          EvaluationSubstitutionType.TEMPLATE;\n\n        const dynamicBindingPathList = oldConfig.dynamicBindingPathList;\n        dynamicBindingPathList.push({ key: action.name });\n\n        const dependencyMap = oldConfig.dependencyMap;\n        dependencyMap[\"body\"].push(action.name);\n\n        const meta = oldConfig.meta;\n        meta[action.name] = {\n          arguments: action.arguments,\n          confirmBeforeExecute: false,\n        };\n\n        const data = get(\n          modifiedUnEvalTree,\n          `${entityName}.${action.name}.data`,\n          {},\n        );\n        set(\n          modifiedUnEvalTree,\n          `${entityName}.${action.name}`,\n          new String(action.body.toString()),\n        );\n        set(modifiedUnEvalTree, `${entityName}.${action.name}.data`, data);\n      }\n    }\n  }\n  if (functionsList && functionsList.length > 0) {\n    for (let i = 0; i < functionsList.length; i++) {\n      const oldActionName = functionsList[i];\n      const existed = parsedBody.actions.find(\n        (js: ParsedJSSubAction) => js.name === oldActionName,\n      );\n      if (!existed) {\n        const reactivePaths = oldConfig.reactivePaths;\n        delete reactivePaths[oldActionName];\n\n        oldConfig.dynamicBindingPathList =\n          oldConfig.dynamicBindingPathList.filter(\n            (path: any) => path[\"key\"] !== oldActionName,\n          );\n\n        const dependencyMap = oldConfig.dependencyMap[\"body\"];\n        const removeIndex = dependencyMap.indexOf(oldActionName);\n        if (removeIndex > -1) {\n          oldConfig.dependencyMap[\"body\"] = dependencyMap.filter(\n            (item: any) => item !== oldActionName,\n          );\n        }\n        const meta = oldConfig.meta;\n        delete meta[oldActionName];\n\n        unset(modifiedUnEvalTree[entityName], oldActionName);\n        unset(modifiedUnEvalTree[entityName], `${oldActionName}.data`);\n      }\n    }\n  }\n  if (parsedBody.variables.length && varList) {\n    for (let i = 0; i < parsedBody.variables.length; i++) {\n      const newVar = parsedBody.variables[i];\n      const existedVar = varList.indexOf(newVar.name);\n      if (existedVar > -1) {\n        const existedVarVal = jsCollection[newVar.name];\n        if (\n          (!!existedVarVal && existedVarVal.toString()) !==\n            (newVar.value && newVar.value.toString()) ||\n          (!existedVarVal && !!newVar)\n        ) {\n          set(modifiedUnEvalTree, `${entityName}.${newVar.name}`, newVar.value);\n          // When user updates the JSObject all the variable's reset's to initial value\n          JSObjectCollection.removeVariable(`${entityName}.${newVar.name}`);\n        }\n      } else {\n        varList.push(newVar.name);\n        const reactivePaths = oldConfig.reactivePaths;\n        reactivePaths[newVar.name] =\n          EvaluationSubstitutionType.SMART_SUBSTITUTE;\n\n        const dynamicBindingPathList = oldConfig.dynamicBindingPathList;\n        dynamicBindingPathList.push({ key: newVar.name });\n\n        set(configTree, `${entityName}.variables`, varList);\n        set(modifiedUnEvalTree, `${entityName}.${newVar.name}`, newVar.value);\n        // When user updates the JSObject all the variable's reset's to initial value\n        JSObjectCollection.removeVariable(`${entityName}.${newVar.name}`);\n      }\n    }\n    let newVarList: Array<string> = varList;\n    for (let i = 0; i < varList.length; i++) {\n      const varListItem = varList[i];\n      const existsInParsed = parsedBody.variables.find(\n        (item) => item.name === varListItem,\n      );\n      if (!existsInParsed) {\n        const reactivePaths = oldConfig.reactivePaths;\n        delete reactivePaths[varListItem];\n\n        oldConfig.dynamicBindingPathList =\n          oldConfig.dynamicBindingPathList.filter(\n            (path: any) => path[\"key\"] !== varListItem,\n          );\n\n        newVarList = newVarList.filter((item) => item !== varListItem);\n        unset(modifiedUnEvalTree[entityName], varListItem);\n      }\n    }\n    if (newVarList.length) {\n      set(configTree, `${entityName}.variables`, newVarList);\n    }\n  }\n  return modifiedUnEvalTree;\n};\n\n/**\n * When JSObject parseBody is empty we remove all variables and actions from unEvalTree\n * this will lead to removal of properties from the dataTree\n * @param unEvalTree\n * @param entity\n * @returns\n */\nexport const removeFunctionsAndVariableJSCollection = (\n  unEvalTree: DataTree,\n  entity: JSActionEntity,\n  entityName: string,\n  configTree: ConfigTree,\n) => {\n  const oldConfig = configTree[entityName] as JSActionEntityConfig;\n  const modifiedDataTree: DataTree = unEvalTree;\n  const functionsList: Array<string> = [];\n  Object.keys(oldConfig.meta).forEach((action) => {\n    functionsList.push(action);\n  });\n  //removed variables\n  const varList: Array<string> | undefined = oldConfig.variables;\n  set(oldConfig, `${entityName}.variables`, []);\n  if (varList) {\n    for (let i = 0; i < varList.length; i++) {\n      const varName = varList[i];\n      unset(modifiedDataTree[entityName], varName);\n      // When user updates the JSObject all the variable's reset's to initial value\n      JSObjectCollection.removeVariable(`${entityName}.${varName}`);\n    }\n  }\n\n  //remove functions\n  const reactivePaths = entity.reactivePaths;\n  const meta = entity.meta;\n\n  for (let i = 0; i < functionsList.length; i++) {\n    const actionName = functionsList[i];\n    delete reactivePaths[actionName];\n    delete meta[actionName];\n    unset(modifiedDataTree[entityName], actionName);\n\n    oldConfig.dynamicBindingPathList = oldConfig.dynamicBindingPathList.filter(\n      (path: any) => path[\"key\"] !== actionName,\n    );\n\n    oldConfig.dependencyMap[\"body\"] = entity.dependencyMap[\"body\"].filter(\n      (item: any) => item !== actionName,\n    );\n  }\n\n  return modifiedDataTree;\n};\n\nexport function isJSObjectFunction(\n  dataTree: DataTree,\n  jsObjectName: string,\n  key: string,\n  configTree: ConfigTree,\n) {\n  const entityConfig = configTree[jsObjectName] as JSActionEntityConfig;\n  const entity = dataTree[jsObjectName];\n  if (isJSAction(entity)) {\n    return entityConfig.meta.hasOwnProperty(key);\n  }\n  return false;\n}\n\nexport function isJSObjectVariable(\n  jsObjectName: string,\n  key: string,\n  configTree: ConfigTree,\n) {\n  const entityConfig = configTree[jsObjectName] as JSActionEntityConfig;\n  if (!entityConfig) return false;\n  const entity = configTree[jsObjectName];\n  const variables = entityConfig.variables;\n  return (\n    isJSAction(entity as unknown as DataTreeEntity) && variables?.includes(key)\n  );\n}\n\nexport function isPromise(value: any): value is Promise<unknown> {\n  return Boolean(value && typeof value.then === \"function\");\n}\n\nfunction updateJSExecutionError(\n  errors: BatchedJSExecutionErrors,\n  executionError: JSExecutionError,\n) {\n  const { collectionId } = executionError;\n  if (errors[collectionId]) {\n    errors[collectionId].push(executionError);\n  } else {\n    errors[collectionId] = [executionError];\n  }\n}\n\nfunction updateJSExecutionData(\n  sortedData: BatchedJSExecutionData,\n  executionData: JSExecutionData,\n) {\n  const { collectionId } = executionData;\n  if (sortedData[collectionId]) {\n    sortedData[collectionId].push(executionData);\n  } else {\n    sortedData[collectionId] = [executionData];\n  }\n}\n\nfunction getJSActionFromJSCollections(\n  jsCollections: JSCollectionData[],\n  jsfuncFullName: string,\n) {\n  const { entityName: collectionName, propertyPath: functionName } =\n    getEntityNameAndPropertyPath(jsfuncFullName);\n\n  const jsCollection = find(\n    jsCollections,\n    (collection) => collection.config.name === collectionName,\n  );\n  if (!jsCollection) return;\n\n  const jsAction: JSAction | undefined = find(\n    jsCollection.config.actions,\n    (action) => action.name === functionName,\n  );\n  return jsAction;\n}\n\nexport function* sortJSExecutionDataByCollectionId(\n  data: Record<string, unknown>,\n  errors: Record<string, unknown>,\n) {\n  // Sorted data by collectionId\n  const sortedData: BatchedJSExecutionData = {};\n  // Sorted errors by collectionId\n  const sortedErrors: BatchedJSExecutionErrors = {};\n\n  const JSCollectionsForCurrentPage: JSCollectionData[] =\n    yield select(getAllJSCollections);\n\n  for (const jsfuncFullName of Object.keys(data)) {\n    const jsAction = getJSActionFromJSCollections(\n      JSCollectionsForCurrentPage,\n      jsfuncFullName,\n    );\n    if (!(jsAction && jsAction.collectionId)) continue;\n    const { collectionId, id: actionId } = jsAction;\n\n    if (errors[jsfuncFullName]) {\n      updateJSExecutionError(sortedErrors, {\n        collectionId,\n        isDirty: true,\n        actionId,\n      });\n    }\n\n    updateJSExecutionData(sortedData, {\n      collectionId,\n      actionId,\n      data: get(data, jsfuncFullName),\n    });\n  }\n\n  return { sortedData, sortedErrors };\n}\n","import { convertPathToString } from \"@appsmith/workers/Evaluation/evaluationUtils\";\nimport type { Diff } from \"deep-diff\";\nimport type { DataTree } from \"entities/DataTree/dataTreeTypes\";\nimport { get, set, unset } from \"lodash\";\n\nexport type TDataStore = Record<string, Record<string, unknown>>;\nexport default class DataStore {\n  private static store: TDataStore = {};\n\n  static setActionData(fullPath: string, value: unknown) {\n    set(DataStore.store, fullPath, value);\n  }\n\n  static getActionData(fullPath: string): unknown | undefined {\n    return get(DataStore.store, fullPath, undefined);\n  }\n  static getDataStore() {\n    return DataStore.store;\n  }\n  static deleteActionData(fullPath: string) {\n    unset(DataStore.store, fullPath);\n  }\n  static clear() {\n    DataStore.store = {};\n  }\n\n  static replaceDataStore(store: TDataStore) {\n    DataStore.store = store;\n  }\n\n  static update(dataTreeDiff: Diff<DataTree, DataTree>[]) {\n    const deleteDiffs = dataTreeDiff.filter((diff) => diff.kind === \"D\");\n    deleteDiffs.forEach((diff) => {\n      const deletedPath = diff.path || [];\n      const deletedPathString = convertPathToString(deletedPath);\n      DataStore.deleteActionData(deletedPathString);\n    });\n  }\n}\n","// This is a hard-coded list of DOM APIs that linkedom provides. Were hardcoding it instead of deriving it\n// from documentMock because domApiNames are used in the main thread, and deriving them from linkedom\n// will keep linkedom in the main threads bundle.\nconst DOM_API_NAMES = [\n  \"Attr\",\n  \"CharacterData\",\n  \"Comment\",\n  \"CustomEvent\",\n  \"DOMParser\",\n  \"Document\",\n  \"DocumentFragment\",\n  \"DocumentType\",\n  \"Element\",\n  \"Event\",\n  \"EventTarget\",\n  \"Facades\",\n  \"HTMLAnchorElement\",\n  \"HTMLAreaElement\",\n  \"HTMLAudioElement\",\n  \"HTMLBRElement\",\n  \"HTMLBaseElement\",\n  \"HTMLBodyElement\",\n  \"HTMLButtonElement\",\n  \"HTMLCanvasElement\",\n  \"HTMLClasses\",\n  \"HTMLDListElement\",\n  \"HTMLDataElement\",\n  \"HTMLDataListElement\",\n  \"HTMLDetailsElement\",\n  \"HTMLDirectoryElement\",\n  \"HTMLDivElement\",\n  \"HTMLElement\",\n  \"HTMLEmbedElement\",\n  \"HTMLFieldSetElement\",\n  \"HTMLFontElement\",\n  \"HTMLFormElement\",\n  \"HTMLFrameElement\",\n  \"HTMLFrameSetElement\",\n  \"HTMLHRElement\",\n  \"HTMLHeadElement\",\n  \"HTMLHeadingElement\",\n  \"HTMLHtmlElement\",\n  \"HTMLIFrameElement\",\n  \"HTMLImageElement\",\n  \"HTMLInputElement\",\n  \"HTMLLIElement\",\n  \"HTMLLabelElement\",\n  \"HTMLLegendElement\",\n  \"HTMLLinkElement\",\n  \"HTMLMapElement\",\n  \"HTMLMarqueeElement\",\n  \"HTMLMediaElement\",\n  \"HTMLMenuElement\",\n  \"HTMLMetaElement\",\n  \"HTMLMeterElement\",\n  \"HTMLModElement\",\n  \"HTMLOListElement\",\n  \"HTMLObjectElement\",\n  \"HTMLOptGroupElement\",\n  \"HTMLOptionElement\",\n  \"HTMLOutputElement\",\n  \"HTMLParagraphElement\",\n  \"HTMLParamElement\",\n  \"HTMLPictureElement\",\n  \"HTMLPreElement\",\n  \"HTMLProgressElement\",\n  \"HTMLQuoteElement\",\n  \"HTMLScriptElement\",\n  \"HTMLSelectElement\",\n  \"HTMLSlotElement\",\n  \"HTMLSourceElement\",\n  \"HTMLSpanElement\",\n  \"HTMLStyleElement\",\n  \"HTMLTableCaptionElement\",\n  \"HTMLTableCellElement\",\n  \"HTMLTableElement\",\n  \"HTMLTableRowElement\",\n  \"HTMLTemplateElement\",\n  \"HTMLTextAreaElement\",\n  \"HTMLTimeElement\",\n  \"HTMLTitleElement\",\n  \"HTMLTrackElement\",\n  \"HTMLUListElement\",\n  \"HTMLUnknownElement\",\n  \"HTMLVideoElement\",\n  \"InputEvent\",\n  \"Node\",\n  \"NodeFilter\",\n  \"NodeList\",\n  \"SVGElement\",\n  \"ShadowRoot\",\n  \"Text\",\n  \"illegalConstructor\",\n  \"parseHTML\",\n  \"parseJSON\",\n  \"toJSON\",\n] as const;\n\nconst DOM_APIS = DOM_API_NAMES.reduce(\n  (acc, key) => {\n    acc[key] = true;\n    return acc;\n  },\n  {} as Record<string, true | undefined>,\n);\n\nexport default DOM_APIS;\n","import type { ConfigTree, DataTree } from \"entities/DataTree/dataTreeTypes\";\nimport { getAllAsyncFunctions } from \"@appsmith/workers/Evaluation/Actions\";\nimport type { EvaluationError } from \"utils/DynamicBindingUtils\";\nimport { PropertyEvaluationErrorCategory } from \"utils/DynamicBindingUtils\";\nimport type DependencyMap from \"entities/DependencyMap\";\nimport {\n  getAllAsyncJSFunctions,\n  isDataField,\n} from \"workers/common/DataTreeEvaluator/utils\";\nimport { jsPropertiesState } from \"./JSObject/jsPropertiesState\";\nimport { get, isEmpty, toPath } from \"lodash\";\nimport { APP_MODE } from \"entities/App\";\nimport { isAction } from \"@appsmith/workers/Evaluation/evaluationUtils\";\nimport log from \"loglevel\";\nimport * as Sentry from \"@sentry/react\";\nimport { getMemberExpressionObjectFromProperty } from \"@shared/ast\";\n\ninterface ErrorMetaData {\n  userScript: string;\n  source: string;\n}\n\ninterface ExtraData {\n  tree: DataTree;\n  asynFns: Record<string, true>;\n  isViewMode: boolean;\n}\ntype Modifier = (\n  error: any,\n  metaData: ErrorMetaData & ExtraData,\n) => Partial<{\n  errorMessage: ReturnType<typeof getErrorMessage>;\n  errorCategory: PropertyEvaluationErrorCategory;\n  rootcause: string;\n}>;\n\nconst FOUND_ACTION_IN_DATA_FIELD_EVAL_MESSAGE =\n  \"Found an action invocation during evaluation. Data fields cannot execute actions.\";\nconst UNDEFINED_ACTION_IN_SYNC_EVAL_ERROR =\n  \"Please remove any direct/indirect references to {{actionName}} and try again. Data fields cannot execute framework actions.\";\nclass ErrorModifier {\n  private asyncFunctionsNameMap: Record<string, true> = {};\n  private asyncJSFunctionsNames: string[] = [];\n  private isViewMode = true;\n  private dataTree: DataTree = {};\n\n  init(appMode?: APP_MODE) {\n    this.isViewMode = appMode !== APP_MODE.EDIT;\n  }\n\n  updateAsyncFunctions(\n    dataTree: DataTree,\n    configTree: ConfigTree,\n    dependencyMap: DependencyMap,\n  ) {\n    if (this.isViewMode) return;\n    const allAsyncEntityFunctions = getAllAsyncFunctions(dataTree, configTree);\n    const allAsyncJSFunctions = getAllAsyncJSFunctions(\n      dataTree,\n      jsPropertiesState.getMap(),\n      dependencyMap,\n      Object.keys(allAsyncEntityFunctions),\n    );\n    this.asyncFunctionsNameMap = allAsyncEntityFunctions;\n    this.asyncJSFunctionsNames = allAsyncJSFunctions;\n    this.dataTree = dataTree;\n  }\n  run(\n    error: any,\n    metaData: ErrorMetaData,\n    modifiers: Modifier[],\n  ): {\n    errorMessage: ReturnType<typeof getErrorMessage>;\n    errorCategory?: PropertyEvaluationErrorCategory;\n    rootcause?: string;\n  } {\n    const { source, userScript } = metaData;\n    const result: {\n      errorMessage: ReturnType<typeof getErrorMessage>;\n      errorCategory?: PropertyEvaluationErrorCategory;\n      rootcause?: string;\n    } = {\n      errorMessage: getErrorMessage(error),\n      errorCategory: undefined,\n      rootcause: undefined,\n    };\n\n    for (const errorModifier of modifiers) {\n      const { errorCategory, errorMessage, rootcause } = errorModifier(error, {\n        tree: this.dataTree,\n        asynFns: this.asyncFunctionsNameMap,\n        source,\n        userScript,\n        isViewMode: this.isViewMode,\n      });\n      result.errorMessage = errorMessage || result.errorMessage;\n      result.errorCategory = errorCategory || result.errorCategory;\n      result.rootcause = rootcause || result.rootcause;\n    }\n    return result;\n  }\n\n  setAsyncInvocationErrorsRootcause(\n    errors: EvaluationError[],\n    asyncFunc: string,\n  ) {\n    return errors.map((error) => {\n      if (isActionInvokedInDataField(error)) {\n        error.errorMessage.message = FOUND_ACTION_IN_DATA_FIELD_EVAL_MESSAGE;\n        error.kind = {\n          category:\n            PropertyEvaluationErrorCategory.ACTION_INVOCATION_IN_DATA_FIELD,\n          rootcause: asyncFunc,\n        };\n      }\n      return error;\n    });\n  }\n  addRootcauseToAsyncInvocationErrors(\n    fullPropertyPath: string,\n    configTree: ConfigTree,\n    errors: EvaluationError[],\n    dependencyMap: DependencyMap,\n  ) {\n    if (this.isViewMode) return errors;\n    let updatedErrors = errors;\n    if (isDataField(fullPropertyPath, configTree)) {\n      const reachableAsyncJSFunctions = dependencyMap.getAllReachableNodes(\n        fullPropertyPath,\n        this.asyncJSFunctionsNames,\n      );\n\n      if (!isEmpty(reachableAsyncJSFunctions))\n        updatedErrors = errorModifier.setAsyncInvocationErrorsRootcause(\n          errors,\n          reachableAsyncJSFunctions[0],\n        );\n    }\n    return updatedErrors;\n  }\n}\n\nexport const errorModifier = new ErrorModifier();\n\nconst FOUND_PROMISE_IN_SYNC_EVAL_MESSAGE =\n  \"Found a Promise() during evaluation. Data fields cannot execute asynchronous code.\";\n\nexport class FoundPromiseInSyncEvalError extends Error {\n  constructor() {\n    super();\n    this.name = \"\";\n    this.message = FOUND_PROMISE_IN_SYNC_EVAL_MESSAGE;\n  }\n}\n\nexport class ActionCalledInSyncFieldError extends Error {\n  constructor(actionName: string) {\n    super(actionName);\n\n    if (!actionName) {\n      this.message = \"Async function called in a data field\";\n      return;\n    }\n\n    this.name = \"\";\n    this.message = UNDEFINED_ACTION_IN_SYNC_EVAL_ERROR.replaceAll(\n      \"{{actionName}}\",\n      actionName + \"()\",\n    );\n  }\n}\n\nexport const getErrorMessage = (error: Error, name = \"ValidationError\") => {\n  return error.name\n    ? {\n        name: error.name,\n        message: error.message,\n      }\n    : {\n        name,\n        message: error.message,\n      };\n};\n\nexport const getErrorMessageWithType = (error: Error) => {\n  return error.name ? `${error.name}: ${error.message}` : error.message;\n};\n\nfunction isActionInvokedInDataField(error: EvaluationError) {\n  return (\n    error.kind?.category ===\n    PropertyEvaluationErrorCategory.ACTION_INVOCATION_IN_DATA_FIELD\n  );\n}\nconst UNDEFINED_TYPE_ERROR_REGEX =\n  /Cannot read properties of undefined \\(reading '([^\\s]+)'/;\n\nexport function convertAllDataTypesToString(e: any) {\n  // Functions do not get converted properly with JSON.stringify\n  // So using String fot functions\n  // Types like [], {} get converted to \"\" using String\n  // hence using JSON.stringify for the rest\n  if (typeof e === \"function\") {\n    return String(e);\n  } else {\n    try {\n      return JSON.stringify(e);\n    } catch (error) {\n      log.debug(error);\n      Sentry.captureException(error);\n    }\n  }\n}\n\nexport const ActionInDataFieldErrorModifier: Modifier = (\n  error,\n  { asynFns, isViewMode },\n) => {\n  if (isViewMode) return {};\n  const errorMessage = getErrorMessage(error);\n  if (\n    error instanceof FoundPromiseInSyncEvalError ||\n    error instanceof ActionCalledInSyncFieldError\n  ) {\n    return {\n      errorMessage,\n      errorCategory:\n        PropertyEvaluationErrorCategory.ACTION_INVOCATION_IN_DATA_FIELD,\n    };\n  }\n  if (![\"ReferenceError\", \"TypeError\"].includes(error.name)) return {};\n\n  for (const asyncFunctionFullPath of Object.keys(asynFns)) {\n    const functionNameWithWhiteSpace = \" \" + asyncFunctionFullPath + \" \";\n    if (getErrorMessageWithType(error).match(functionNameWithWhiteSpace)) {\n      return {\n        errorMessage: {\n          name: \"ValidationError\",\n          message: UNDEFINED_ACTION_IN_SYNC_EVAL_ERROR.replaceAll(\n            \"{{actionName}}\",\n            asyncFunctionFullPath + \"()\",\n          ),\n        },\n        errorCategory:\n          PropertyEvaluationErrorCategory.ACTION_INVOCATION_IN_DATA_FIELD,\n      };\n    }\n  }\n  return {};\n};\n\nexport const TypeErrorModifier: Modifier = (\n  error,\n  { isViewMode, source, tree, userScript },\n) => {\n  if (isViewMode) return {};\n  const errorMessage = getErrorMessage(error);\n  if (\n    error.name === \"TypeError\" &&\n    errorMessage.message.startsWith(\n      \"Cannot read properties of undefined (reading\",\n    )\n  ) {\n    const matchedString = errorMessage.message.match(\n      UNDEFINED_TYPE_ERROR_REGEX,\n    );\n    if (!matchedString) return {};\n    const undefinedProperty = matchedString[1];\n    const allMemberExpressionObjects = getMemberExpressionObjectFromProperty(\n      undefinedProperty,\n      userScript,\n    );\n    if (isEmpty(allMemberExpressionObjects)) return {};\n    const possibleCauses = new Set<string>();\n    for (const objectString of allMemberExpressionObjects) {\n      const paths = toPath(objectString);\n      const topLevelEntity = tree[paths[0]];\n      if (\n        paths.at(1) === \"data\" &&\n        isAction(topLevelEntity) &&\n        !get(self, `${paths[0]}.data`, undefined)\n      ) {\n        errorMessage.message = `Cannot read data from ${paths[0]}. Please re-run your query.`;\n        return {\n          errorMessage,\n          rootcause: `${paths[0]}`,\n        };\n      }\n\n      if (!get(self, objectString, undefined)) {\n        possibleCauses.add(`\"${objectString}\"`);\n      }\n    }\n    if (isEmpty(possibleCauses)) return {};\n    const possibleCausesArr = Array.from(possibleCauses);\n    errorMessage.message = `${\n      possibleCausesArr.length === 1\n        ? `${possibleCausesArr[0]} is undefined`\n        : `${Array.from(possibleCauses).join(\", \")} could be undefined`\n    } . Please fix ${source || \"the binding\"}.`;\n\n    return {\n      errorMessage,\n      rootcause: source,\n    };\n  }\n  return {};\n};\n\nexport const PrimitiveErrorModifier: Modifier = (error) => {\n  if (error instanceof Error) {\n    const errorMessage = getErrorMessage(error);\n    return { errorMessage };\n  } else {\n    // this covers cases where any primitive value is thrown\n    // for eg., throw \"error\";\n    // These types of errors might have a name/message but are not an instance of Error class\n    const message = convertAllDataTypesToString(error);\n    const errorMessage = {\n      name: error?.name || \"Error\",\n      message: error?.message || message,\n    };\n    return { errorMessage };\n  }\n};\n","import { dataTreeEvaluator } from \"./handlers/evalTree\";\nimport type { EvalMetaUpdates } from \"@appsmith/workers/common/DataTreeEvaluator/types\";\nimport { makeEntityConfigsAsObjProperties } from \"@appsmith/workers/Evaluation/dataTreeUtils\";\nimport type { EvalTreeResponseData, UpdateTreeResponse } from \"./types\";\nimport { MessageType, sendMessage } from \"utils/MessageUtil\";\nimport { MAIN_THREAD_ACTION } from \"@appsmith/workers/Evaluation/evalWorkerActions\";\nimport type { UpdateDataTreeMessageData } from \"sagas/EvalWorkerActionSagas\";\nimport {\n  generateOptimisedUpdatesAndSetPrevState,\n  getNewDataTreeUpdates,\n  uniqueOrderUpdatePaths,\n} from \"./helpers\";\nimport type DataTreeEvaluator from \"workers/common/DataTreeEvaluator\";\nimport type { DataTreeDiff } from \"@appsmith/workers/Evaluation/evaluationUtils\";\n\nconst getDefaultEvalResponse = (): EvalTreeResponseData => ({\n  updates: \"[]\",\n  dependencies: {},\n  errors: [],\n  evalMetaUpdates: [],\n  evaluationOrder: [],\n  jsUpdates: {},\n  logs: [],\n  unEvalUpdates: [],\n  isCreateFirstTree: false,\n  staleMetaIds: [],\n  removedPaths: [],\n  isNewWidgetAdded: false,\n  undefinedEvalValuesMap: {},\n  jsVarsCreatedEvent: [],\n});\n\nexport function evalTreeWithChanges(\n  updatedValuePaths: string[][],\n  metaUpdates: EvalMetaUpdates = [],\n) {\n  let setupUpdateTreeResponse = {} as UpdateTreeResponse;\n  if (dataTreeEvaluator) {\n    setupUpdateTreeResponse =\n      dataTreeEvaluator.setupUpdateTreeWithDifferences(updatedValuePaths);\n  }\n\n  const setterAndLocalStorageUpdatePaths = uniqueOrderUpdatePaths(\n    updatedValuePaths.map((val) => val.join(\".\")),\n  );\n\n  evaluateAndPushResponse(\n    dataTreeEvaluator,\n    setupUpdateTreeResponse,\n    metaUpdates,\n    setterAndLocalStorageUpdatePaths,\n  );\n}\n\nexport const pushResponseToMainThread = (data: UpdateDataTreeMessageData) => {\n  sendMessage.call(self, {\n    messageType: MessageType.DEFAULT,\n    body: {\n      data,\n      method: MAIN_THREAD_ACTION.UPDATE_DATATREE,\n    },\n  });\n};\n\nexport const getAffectedNodesInTheDataTree = (\n  unEvalUpdates: DataTreeDiff[],\n  evalOrder: string[],\n) => {\n  const allUnevalUpdates = unEvalUpdates.map(\n    (update) => update.payload.propertyPath,\n  );\n  // merge unevalUpdate paths and evalOrder paths\n  return uniqueOrderUpdatePaths([...allUnevalUpdates, ...evalOrder]);\n};\n\nexport const evaluateAndPushResponse = (\n  dataTreeEvaluator: DataTreeEvaluator | undefined,\n  setupUpdateTreeResponse: UpdateTreeResponse,\n  metaUpdates: EvalMetaUpdates,\n  additionalPathsAddedAsUpdates: string[],\n) => {\n  const response = evaluateAndGenerateResponse(\n    dataTreeEvaluator,\n    setupUpdateTreeResponse,\n    metaUpdates,\n    additionalPathsAddedAsUpdates,\n  );\n  return pushResponseToMainThread(response);\n};\n\nexport const evaluateAndGenerateResponse = (\n  dataTreeEvaluator: DataTreeEvaluator | undefined,\n  setupUpdateTreeResponse: UpdateTreeResponse,\n  metaUpdates: EvalMetaUpdates,\n  additionalPathsAddedAsUpdates: string[],\n): UpdateDataTreeMessageData => {\n  // generate default response first and later add updates to it\n  const defaultResponse = getDefaultEvalResponse();\n\n  if (!dataTreeEvaluator) {\n    const updates = generateOptimisedUpdatesAndSetPrevState(\n      {},\n      dataTreeEvaluator,\n      [],\n    );\n    defaultResponse.updates = updates;\n    defaultResponse.evalMetaUpdates = [...(metaUpdates || [])];\n    return {\n      workerResponse: defaultResponse,\n      unevalTree: {},\n    };\n  }\n\n  const { evalOrder, jsUpdates, unEvalUpdates } = setupUpdateTreeResponse;\n  defaultResponse.evaluationOrder = evalOrder;\n  defaultResponse.unEvalUpdates = unEvalUpdates;\n  defaultResponse.jsUpdates = jsUpdates;\n\n  const updateResponse = dataTreeEvaluator.evalAndValidateSubTree(\n    evalOrder,\n    dataTreeEvaluator.oldConfigTree,\n    unEvalUpdates,\n  );\n\n  const dataTree = makeEntityConfigsAsObjProperties(\n    dataTreeEvaluator.evalTree,\n    {\n      evalProps: dataTreeEvaluator.evalProps,\n    },\n  );\n\n  /** Make sure evalMetaUpdates is sanitized to prevent postMessage failure */\n  defaultResponse.evalMetaUpdates = JSON.parse(\n    JSON.stringify([...(metaUpdates || []), ...updateResponse.evalMetaUpdates]),\n  );\n\n  defaultResponse.staleMetaIds = updateResponse.staleMetaIds;\n  const unevalTree = dataTreeEvaluator.getOldUnevalTree();\n\n  // when additional paths are required to be added as updates, we extract the updates from the data tree using these paths.\n  const additionalUpdates = getNewDataTreeUpdates(\n    additionalPathsAddedAsUpdates,\n    dataTree,\n  );\n  // the affected paths is a combination of the eval order and the uneval updates\n  // we use this collection to limit the diff between the old and new data tree\n  const affectedNodePaths = getAffectedNodesInTheDataTree(\n    unEvalUpdates,\n    evalOrder,\n  );\n\n  defaultResponse.updates = generateOptimisedUpdatesAndSetPrevState(\n    dataTree,\n    dataTreeEvaluator,\n    affectedNodePaths,\n    additionalUpdates,\n  );\n  dataTreeEvaluator.undefinedEvalValuesMap =\n    dataTreeEvaluator.undefinedEvalValuesMap || {};\n\n  return {\n    workerResponse: defaultResponse,\n    unevalTree,\n  };\n};\n","import { uuid4 } from \"@sentry/utils\";\nimport type {\n  LogObject,\n  Methods,\n  SourceEntity,\n} from \"entities/AppsmithConsole\";\nimport { Severity } from \"entities/AppsmithConsole\";\nimport { ENTITY_TYPE } from \"@appsmith/entities/AppsmithConsole/utils\";\nimport { klona } from \"klona/lite\";\nimport moment from \"moment\";\nimport type { TriggerMeta } from \"@appsmith/sagas/ActionExecution/ActionExecutionSagas\";\nimport TriggerEmitter from \"../utils/TriggerEmitter\";\nimport type { EventEmitter } from \"events\";\nimport ExecutionMetaData from \"../utils/ExecutionMetaData\";\n\nclass UserLog {\n  private isEnabled = true;\n  enable() {\n    this.isEnabled = true;\n  }\n  disable() {\n    this.isEnabled = false;\n  }\n  private emitter?: EventEmitter;\n\n  private saveLog(method: Methods, data: any[]) {\n    const parsed = this.parseLogs(method, data);\n    this.emitter?.emit(\"process_logs\", parsed);\n  }\n\n  public overrideConsoleAPI() {\n    this.emitter = TriggerEmitter;\n    const { debug, error, info, log, table, warn } = console;\n    console = {\n      ...console,\n      table: (...args: any) => {\n        if (!this.isEnabled) return;\n        table.call(this, args);\n        this.saveLog(\"table\", args);\n      },\n      error: (...args: any) => {\n        if (!this.isEnabled) return;\n        error.apply(this, args);\n        this.saveLog(\"error\", args);\n      },\n      log: (...args: any) => {\n        if (!this.isEnabled) return;\n        log.apply(this, args);\n        this.saveLog(\"log\", args);\n      },\n      debug: (...args: any) => {\n        if (!this.isEnabled) return;\n        debug.apply(this, args);\n        this.saveLog(\"debug\", args);\n      },\n      warn: (...args: any) => {\n        if (!this.isEnabled) return;\n        warn.apply(this, args);\n        this.saveLog(\"warn\", args);\n      },\n      info: (...args: any) => {\n        if (!this.isEnabled) return;\n        info.apply(this, args);\n        this.saveLog(\"info\", args);\n      },\n    };\n  }\n  private replaceFunctionWithNamesFromObjects(data: any) {\n    if (typeof data === \"function\") return `func() ${data.name}`;\n    if (!data || typeof data !== \"object\") return data;\n    if (data instanceof Promise) return \"Promise\";\n    const acc: any =\n      Object.prototype.toString.call(data) === \"[object Array]\" ? [] : {};\n    return Object.keys(data).reduce((acc, key) => {\n      acc[key] = this.replaceFunctionWithNamesFromObjects(data[key]);\n      return acc;\n    }, acc);\n  }\n  // iterates over the data and if data is object/array, then it will remove any functions from it\n  private sanitizeData(data: any): any {\n    try {\n      const returnData = this.replaceFunctionWithNamesFromObjects(data);\n      return returnData;\n    } catch (e) {\n      return [`There was some error: ${e} ${JSON.stringify(data)}`];\n    }\n  }\n\n  private getSource = (triggerMeta?: TriggerMeta): SourceEntity => {\n    const type = triggerMeta?.source?.entityType || ENTITY_TYPE.JSACTION;\n    const name =\n      triggerMeta?.source?.name || triggerMeta?.triggerPropertyName || \"\";\n    const propertyPath = triggerMeta?.triggerPropertyName || \"\";\n    const id = triggerMeta?.source?.id || \"\";\n    //@ts-expect-error : we are not using the source entity in the console\n    return { type, name, id, propertyPath };\n  };\n\n  // parses the incoming log and converts it to the log object\n  private parseLogs(method: Methods, data: any[]): LogObject {\n    // Create an ID\n    const id = uuid4();\n    const timestamp = moment().format(\"HH:mm:ss\");\n    // Parse the methods\n    let output = data;\n    // For logs UI we only keep 3 levels of severity, info, warn, error\n    let severity = Severity.INFO;\n    if (method === \"error\") {\n      severity = Severity.ERROR;\n      output = data.map((error) => {\n        return error?.stack || error;\n      });\n    } else if (method === \"warn\") {\n      severity = Severity.WARNING;\n    }\n\n    const { triggerMeta } = ExecutionMetaData.getExecutionMetaData();\n    return {\n      method,\n      id,\n      data: this.sanitizeData(klona(output)),\n      timestamp,\n      severity,\n      source: this.getSource(triggerMeta),\n    };\n  }\n}\n\nconst userLogs = new UserLog();\n\nexport default userLogs;\n","import ExecutionMetaData from \"../utils/ExecutionMetaData\";\n\nconst _internalSetInterval = self.setInterval;\nconst _internalClearInterval = self.clearInterval;\n\nconst intervalIdMap = new Map<number | string, number>();\n\nexport function clearAllIntervals() {\n  intervalIdMap.forEach((intervalId) => _internalClearInterval(intervalId));\n  intervalIdMap.clear();\n}\n\nexport function clearInterval(intervalId: number | string) {\n  const runningIntervalId = intervalIdMap.get(intervalId);\n  intervalIdMap.delete(intervalId);\n  return _internalClearInterval(runningIntervalId);\n}\n\nexport function setInterval(\n  callback: (...args: any[]) => void,\n  delay = 300,\n  ...args: any[]\n) {\n  const metaData = ExecutionMetaData.getExecutionMetaData();\n  const runningIntervalId = intervalIdMap.get(args[0]);\n  if (runningIntervalId) {\n    _internalClearInterval(runningIntervalId);\n    intervalIdMap.delete(args[0]);\n  }\n  const _internalIntervalId = _internalSetInterval(\n    (...args: any[]) => {\n      self[\"$isDataField\"] = false;\n      ExecutionMetaData.setExecutionMetaData(metaData);\n      typeof callback === \"function\" && callback(...args);\n    },\n    delay,\n    ...args,\n  );\n  const customIntervalId = args[0] || _internalIntervalId;\n  intervalIdMap.set(customIntervalId, _internalIntervalId);\n  return _internalIntervalId;\n}\n","import { ActionCalledInSyncFieldError } from \"workers/Evaluation/errorModifier\";\n\ntype FnGuard = (fn: (...args: any[]) => unknown, fnName: string) => unknown;\n\nexport function addFn(\n  ctx: any,\n  fnName: string,\n  fn: (...args: any[]) => any,\n  fnGuards = [isAsyncGuard],\n) {\n  Object.defineProperty(ctx, fnName, {\n    value: function (...args: any[]) {\n      const fnWithGuards = getFnWithGuards(fn, fnName, fnGuards);\n      return fnWithGuards(...args);\n    },\n    enumerable: false,\n    writable: true,\n    configurable: true,\n  });\n}\n\nexport function isAsyncGuard<P extends ReadonlyArray<unknown>>(\n  fn: (...args: P) => unknown,\n  fnName: string,\n) {\n  if (self.$isDataField) {\n    self[\"$isAsync\"] = true;\n    throw new ActionCalledInSyncFieldError(fnName);\n  }\n}\n\nexport function getFnWithGuards(\n  fn: (...args: any[]) => unknown,\n  fnName: string,\n  fnGuards: FnGuard[],\n) {\n  return (...args: any[]) => {\n    for (const guard of fnGuards) {\n      guard(fn, fnName);\n    }\n    return fn(...args);\n  };\n}\n","import type { Diff } from \"deep-diff\";\nimport type { CanvasWidgetsReduxState } from \"reducers/entityReducers/canvasWidgetsReducer\";\nimport ReplayEntity from \"../index\";\nimport { set } from \"lodash\";\nimport {\n  addToArray,\n  FOCUSES,\n  setPropertyUpdate,\n  TOASTS,\n  UPDATES,\n  WIDGETS,\n} from \"../replayUtils\";\nimport type { AppTheme } from \"entities/AppTheming\";\nimport { ENTITY_TYPE } from \"@appsmith/entities/AppsmithConsole/utils\";\n\nexport interface Canvas {\n  widgets: CanvasWidgetsReduxState;\n  theme: AppTheme;\n}\nexport type CanvasDiff = Diff<Canvas, Canvas>;\nexport type DSLDiff = Diff<CanvasWidgetsReduxState, CanvasWidgetsReduxState>;\n\nconst positionProps = [\n  \"leftColumn\",\n  \"rightColumn\",\n  \"topRow\",\n  \"bottomRow\",\n  \"minHeight\",\n  \"parentColumnSpace\",\n  \"parentRowSpace\",\n  \"children\",\n  \"parentId\",\n  \"renderMode\",\n  \"detachFromLayout\",\n  \"noContainerOffset\",\n  \"isCanvas\",\n  \"height\",\n];\n\n/**\n * checks property changed is a positional property\n *\n * @param widgetProperty\n * @returns\n */\nfunction isPositionUpdate(widgetProperty: string) {\n  return positionProps.indexOf(widgetProperty) !== -1;\n}\nexport default class ReplayCanvas extends ReplayEntity<Canvas> {\n  public constructor(entity: Canvas) {\n    super(entity, ENTITY_TYPE.WIDGET);\n  }\n\n  /**\n   * process the diff\n   *\n   * @param diff\n   * @param replay\n   * @param isUndo\n   * @returns\n   */\n  public processDiff(diff: CanvasDiff, replay: any, isUndo: boolean) {\n    if (!diff || !diff.path || !diff.path.length || diff.path[1] === \"0\")\n      return;\n\n    if (diff.path.indexOf(\"widgets\") > -1) {\n      return this.processDiffForWidgets(diff, replay, isUndo);\n    }\n\n    if (diff.path.indexOf(\"theme\") > -1) {\n      return this.processDiffForTheme(diff, replay);\n    }\n  }\n\n  /**\n   * process diff related to app theming\n   *\n   * @param diff\n   * @param replay\n   * @param isUndo\n   */\n  public processDiffForTheme(diff: CanvasDiff, replay: any) {\n    if (!diff || !diff.path || !diff.path.length || diff.path[1] === \"0\")\n      return;\n\n    set(replay, \"theme\", true);\n\n    if (diff.path.join(\".\") === \"theme.name\") {\n      set(replay, \"themeChanged\", true);\n    }\n  }\n\n  /**\n   * process diffs related to DSL ( widgets )\n   *\n   * @param diff\n   * @param replay\n   * @param isUndo\n   * @returns\n   */\n  public processDiffForWidgets(diff: CanvasDiff, replay: any, isUndo: boolean) {\n    if (!diff || !diff.path || !diff.path.length || diff.path[1] === \"0\")\n      return;\n\n    const widgetId = diff.path[1];\n\n    switch (diff.kind) {\n      // new elements is added in dsl\n      case \"N\":\n        if (diff.path.length == 2) {\n          const toast = this.createToast(\n            diff.rhs,\n            this.entity.widgets[widgetId],\n            widgetId,\n            isUndo,\n            !isUndo,\n          );\n          addToArray(replay, TOASTS, toast);\n        } else {\n          setPropertyUpdate(replay, [WIDGETS, widgetId, UPDATES], diff.path);\n        }\n        break;\n      // element is deleted in dsl\n      case \"D\":\n        if (diff.path.length == 2) {\n          const toast = this.createToast(\n            diff.lhs,\n            this.entity.widgets[widgetId],\n            widgetId,\n            isUndo,\n            isUndo,\n          );\n          addToArray(replay, TOASTS, toast);\n        } else {\n          setPropertyUpdate(replay, [WIDGETS, widgetId, UPDATES], diff.path);\n        }\n        break;\n      // element is edited\n      case \"E\":\n        if (isPositionUpdate(diff.path[diff.path.length - 2])) {\n          set(replay, [WIDGETS, widgetId, FOCUSES], true);\n        } else {\n          setPropertyUpdate(replay, [WIDGETS, widgetId, UPDATES], diff.path);\n        }\n        break;\n      default:\n        break;\n    }\n  }\n\n  private createToast(\n    diffWidget: any,\n    dslWidget: CanvasWidgetsReduxState | undefined,\n    widgetId: string,\n    isUndo: boolean,\n    isCreated: boolean,\n  ) {\n    const widgetName = isCreated\n      ? diffWidget.widgetName\n      : dslWidget?.widgetName;\n    return {\n      isCreated,\n      isUndo,\n      widgetName,\n      widgetId,\n    };\n  }\n}\n","import {\n  addWidgetPropertyDependencies,\n  getEntityNameAndPropertyPath,\n  isATriggerPath,\n} from \"@appsmith/workers/Evaluation/evaluationUtils\";\nimport { ENTITY_TYPE } from \"entities/DataTree/dataTreeFactory\";\nimport type {\n  ActionEntity,\n  ActionEntityConfig,\n  JSActionEntity,\n  JSActionEntityConfig,\n  DataTreeEntityConfig,\n  WidgetEntity,\n  WidgetEntityConfig,\n} from \"@appsmith/entities/DataTree/types\";\nimport type { DataTreeEntity } from \"entities/DataTree/dataTreeTypes\";\nimport { find, union } from \"lodash\";\nimport { getEntityDynamicBindingPathList } from \"utils/DynamicBindingUtils\";\nimport type { DataTreeEntityObject } from \"@appsmith/entities/DataTree/types\";\nimport { getDependencyFromEntityPath } from \"workers/common/DependencyMap/utils/getEntityDependencies\";\n\nexport const getDependencies = {\n  [ENTITY_TYPE.ACTION]: (\n    entity: DataTreeEntityObject,\n    entityConfig: DataTreeEntityConfig,\n    allKeys: Record<string, true>,\n  ) => {\n    return getActionDependencies(\n      entity as ActionEntity,\n      entityConfig as ActionEntityConfig,\n      allKeys,\n    );\n  },\n  [ENTITY_TYPE.JSACTION]: (\n    entity: DataTreeEntityObject,\n    entityConfig: DataTreeEntityConfig,\n    allKeys: Record<string, true>,\n  ) => {\n    return getJSDependencies(\n      entity as JSActionEntity,\n      entityConfig as JSActionEntityConfig,\n      allKeys,\n    );\n  },\n  [ENTITY_TYPE.WIDGET]: (\n    entity: DataTreeEntityObject,\n    entityConfig: DataTreeEntityConfig,\n  ) => {\n    return getWidgetDependencies(\n      entity as WidgetEntity,\n      entityConfig as WidgetEntityConfig,\n    );\n  },\n};\n\nexport function getWidgetDependencies(\n  widgetEntity: WidgetEntity,\n  widgetConfig: WidgetEntityConfig,\n): Record<string, string[]> {\n  let dependencies: Record<string, string[]> = {};\n  const widgetName = widgetEntity.widgetName;\n  const widgetInternalDependencies = addWidgetPropertyDependencies({\n    widgetConfig,\n    widgetName,\n  });\n\n  dependencies = { ...widgetInternalDependencies };\n\n  const dependencyMap = widgetConfig.dependencyMap;\n\n  for (const source in dependencyMap) {\n    if (!dependencyMap.hasOwnProperty(source)) continue;\n    const targetPaths = dependencyMap[source];\n    const fullPropertyPath = `${widgetName}.${source}`;\n    dependencies[fullPropertyPath] = dependencies[fullPropertyPath] || [];\n    dependencies[fullPropertyPath].push(\n      ...targetPaths.map((p) => `${widgetName}.${p}`),\n    );\n  }\n\n  const dynamicBindingPathList = getEntityDynamicBindingPathList(widgetConfig);\n  const dynamicTriggerPathList = widgetConfig.dynamicTriggerPathList || [];\n\n  for (const { key } of dynamicTriggerPathList) {\n    dependencies[`${widgetName}.${key}`] = [];\n  }\n\n  for (const bindingPath of dynamicBindingPathList) {\n    const propertyPath = bindingPath.key;\n    const fullPropertyPath = `${widgetName}.${propertyPath}`;\n    const dynamicPathDependencies = getDependencyFromEntityPath(\n      propertyPath,\n      widgetEntity,\n    );\n    const existingDeps = dependencies[fullPropertyPath] || [];\n    const newDeps = union(existingDeps, dynamicPathDependencies);\n    dependencies = { ...dependencies, [fullPropertyPath]: newDeps };\n  }\n\n  return dependencies;\n}\nexport function getJSDependencies(\n  jsEntity: JSActionEntity,\n  jsActionConfig: JSActionEntityConfig,\n  allKeys: Record<string, true>,\n): Record<string, string[]> {\n  let dependencies: Record<string, string[]> = {};\n  const jsActionReactivePaths = jsActionConfig.reactivePaths || {};\n  const jsActionDependencyMap = jsActionConfig.dependencyMap || {};\n  const jsObjectName = jsActionConfig.name || \"\";\n\n  for (const [propertyPath, pathDeps] of Object.entries(\n    jsActionDependencyMap,\n  )) {\n    const fullPropertyPath = `${jsObjectName}.${propertyPath}`;\n    const propertyPathDependencies: string[] = pathDeps\n      .map((dependentPath) => `${jsObjectName}.${dependentPath}`)\n      .filter((path) => allKeys.hasOwnProperty(path));\n    dependencies[fullPropertyPath] = propertyPathDependencies;\n  }\n\n  for (const reactivePath of Object.keys(jsActionReactivePaths)) {\n    const fullPropertyPath = `${jsObjectName}.${reactivePath}`;\n    const reactivePathDependencies = getDependencyFromEntityPath(\n      reactivePath,\n      jsEntity,\n    );\n    const existingDeps = dependencies[fullPropertyPath] || [];\n    const newDeps = union(existingDeps, reactivePathDependencies);\n    dependencies = { ...dependencies, [fullPropertyPath]: newDeps };\n  }\n\n  return dependencies;\n}\nexport function getActionDependencies(\n  actionEntity: ActionEntity,\n  actionConfig: ActionEntityConfig,\n  allKeys: Record<string, true>,\n): Record<string, string[]> {\n  let dependencies: Record<string, string[]> = {};\n  const actionName = actionConfig.name;\n  const actionDependencyMap = actionConfig.dependencyMap || {};\n  const dynamicBindingPathList = getEntityDynamicBindingPathList(actionConfig);\n\n  for (const [propertyPath, pathDeps] of Object.entries(actionDependencyMap)) {\n    const fullPropertyPath = `${actionName}.${propertyPath}`;\n    const propertyPathDependencies: string[] = pathDeps\n      .map((dependentPath) => `${actionName}.${dependentPath}`)\n      .filter((path) => allKeys.hasOwnProperty(path));\n    dependencies[fullPropertyPath] = propertyPathDependencies;\n  }\n\n  for (const dynamicPath of dynamicBindingPathList) {\n    const propertyPath = dynamicPath.key;\n    const fullPropertyPath = `${actionName}.${propertyPath}`;\n    const dynamicPathDependencies = getDependencyFromEntityPath(\n      propertyPath,\n      actionEntity,\n    );\n    const existingDeps = dependencies[fullPropertyPath] || [];\n    const newDependencies = union(existingDeps, dynamicPathDependencies);\n    dependencies = { ...dependencies, [fullPropertyPath]: newDependencies };\n  }\n\n  return dependencies;\n}\n\nexport const getPathDependencies = {\n  [ENTITY_TYPE.ACTION]: (\n    entity: DataTreeEntity,\n    entityConfig: DataTreeEntityConfig,\n    fullPropertyPath: string,\n    allKeys: Record<string, true>,\n  ) => {\n    return getActionPropertyPathDependencies(\n      entity as ActionEntity,\n      entityConfig as ActionEntityConfig,\n      fullPropertyPath,\n      allKeys,\n    );\n  },\n  [ENTITY_TYPE.JSACTION]: (\n    entity: DataTreeEntity,\n    entityConfig: DataTreeEntityConfig,\n    fullPropertyPath: string,\n    allKeys: Record<string, true>,\n  ) => {\n    return getJSPropertyPathDependencies(\n      entity as JSActionEntity,\n      entityConfig as JSActionEntityConfig,\n      fullPropertyPath,\n      allKeys,\n    );\n  },\n  [ENTITY_TYPE.WIDGET]: (\n    entity: DataTreeEntity,\n    entityConfig: DataTreeEntityConfig,\n    fullPropertyPath: string,\n  ) => {\n    return getWidgetPropertyPathDependencies(\n      entity as WidgetEntity,\n      entityConfig as WidgetEntityConfig,\n      fullPropertyPath,\n    );\n  },\n};\n\nfunction getWidgetPropertyPathDependencies(\n  widgetEntity: WidgetEntity,\n  widgetConfig: WidgetEntityConfig,\n  fullPropertyPath: string,\n) {\n  let dependencies: string[] = [];\n  const { propertyPath } = getEntityNameAndPropertyPath(fullPropertyPath);\n  const dynamicBindingPathList = getEntityDynamicBindingPathList(widgetConfig);\n  const bindingPaths = widgetConfig.bindingPaths || {};\n  const widgetInternalDependencies = addWidgetPropertyDependencies({\n    widgetConfig,\n    widgetName: widgetEntity.widgetName,\n  });\n  const widgetPathInternalDependencies =\n    widgetInternalDependencies[fullPropertyPath];\n\n  dependencies = union(dependencies, widgetPathInternalDependencies);\n  if (isATriggerPath(widgetConfig, propertyPath)) return dependencies;\n  const isPathADynamicPath =\n    bindingPaths.hasOwnProperty(propertyPath) ||\n    find(dynamicBindingPathList, { key: propertyPath });\n\n  if (!isPathADynamicPath) return dependencies;\n\n  const dynamicPathDependencies = getDependencyFromEntityPath(\n    propertyPath,\n    widgetEntity,\n  );\n  dependencies = union(dependencies, dynamicPathDependencies);\n\n  return dependencies;\n}\nfunction getJSPropertyPathDependencies(\n  jsEntity: JSActionEntity,\n  jsActionConfig: JSActionEntityConfig,\n  fullPropertyPath: string,\n  allKeys: Record<string, true>,\n) {\n  const { propertyPath } = getEntityNameAndPropertyPath(fullPropertyPath);\n  const jsActionReactivePaths = jsActionConfig.reactivePaths || {};\n  let dependencies: string[] = [];\n  const jsInternalDependencyMap = jsActionConfig.dependencyMap || {};\n  const jsPathInternalDependencies =\n    jsInternalDependencyMap[propertyPath]\n      ?.map((dep) => `${jsActionConfig.name}.${dep}`)\n      ?.filter((path) => allKeys.hasOwnProperty(path)) || [];\n\n  dependencies = union(dependencies, jsPathInternalDependencies);\n\n  if (jsActionReactivePaths.hasOwnProperty(propertyPath)) {\n    const propertyPathDependencies = getDependencyFromEntityPath(\n      propertyPath,\n      jsEntity,\n    );\n    dependencies = union(dependencies, propertyPathDependencies);\n  }\n  return dependencies;\n}\nfunction getActionPropertyPathDependencies(\n  actionEntity: ActionEntity,\n  actionConfig: ActionEntityConfig,\n  fullPropertyPath: string,\n  allKeys: Record<string, true>,\n) {\n  let actionPathDependencies: string[] = [];\n  const { propertyPath } = getEntityNameAndPropertyPath(fullPropertyPath);\n  const actionInternalDependencyMap = actionConfig.dependencyMap || {};\n  const actionPathInternalDependencies =\n    actionInternalDependencyMap[propertyPath]\n      ?.map((dep) => `${actionConfig.name}.${dep}`)\n      .filter((path) => allKeys.hasOwnProperty(path)) || [];\n  actionPathDependencies = union(\n    actionPathDependencies,\n    actionPathInternalDependencies,\n  );\n\n  const dynamicBindingPathList = getEntityDynamicBindingPathList(actionConfig);\n  const bindingPaths = actionConfig.bindingPaths;\n\n  const isADynamicPath =\n    bindingPaths.hasOwnProperty(propertyPath) ||\n    find(dynamicBindingPathList, { key: propertyPath });\n\n  if (!isADynamicPath) return actionPathDependencies;\n\n  const dynamicPathDependencies = getDependencyFromEntityPath(\n    propertyPath,\n    actionEntity,\n  );\n  actionPathDependencies = union(\n    actionPathDependencies,\n    dynamicPathDependencies,\n  );\n\n  return actionPathDependencies;\n}\n","import type { DataTreeEntity } from \"entities/DataTree/dataTreeTypes\";\nimport { get } from \"lodash\";\nimport { getDynamicBindings } from \"utils/DynamicBindingUtils\";\nimport { isWidgetActionOrJsObject } from \"@appsmith/entities/DataTree/utils\";\nimport type { DataTreeEntityObject } from \"@appsmith/entities/DataTree/types\";\nimport {\n  getDependencies,\n  getPathDependencies,\n} from \"@appsmith/workers/common/DependencyMap/utils/getEntityDependenciesByType\";\nimport type { DataTreeEntityConfig } from \"@appsmith/entities/DataTree/types\";\n\nexport function getEntityDependencies(\n  entity: DataTreeEntityObject,\n  entityConfig: DataTreeEntityConfig,\n  allKeys: Record<string, true>,\n): Record<string, string[]> {\n  if (!isWidgetActionOrJsObject(entity)) return {};\n  return (\n    getDependencies[entity.ENTITY_TYPE](\n      entity as DataTreeEntityObject,\n      entityConfig as DataTreeEntityConfig,\n      allKeys as Record<string, true>,\n    ) || {}\n  );\n}\n\nexport function getEntityPathDependencies(\n  entity: DataTreeEntity,\n  entityConfig: DataTreeEntityConfig,\n  fullPropertyPath: string,\n  allKeys: Record<string, true>,\n) {\n  if (!isWidgetActionOrJsObject(entity)) return [];\n  return (\n    getPathDependencies[entity.ENTITY_TYPE](\n      entity as DataTreeEntity,\n      entityConfig as DataTreeEntityConfig,\n      fullPropertyPath as string,\n      allKeys as Record<string, true>,\n    ) || []\n  );\n}\n\nexport function getDependencyFromEntityPath(\n  propertyPath: string,\n  entity: DataTreeEntity,\n) {\n  const unevalPropValue = get(entity, propertyPath, \"\").toString();\n  const { jsSnippets } = getDynamicBindings(unevalPropValue, entity);\n  const validJSSnippets = jsSnippets.filter((jsSnippet) => !!jsSnippet);\n\n  return validJSSnippets;\n}\n","import toposort from \"toposort\";\nimport type DependencyMap from \".\";\nimport { IMMEDIATE_PARENT_REGEX } from \"@appsmith/workers/Evaluation/evaluationUtils\";\n\ntype SortDependencies =\n  | {\n      success: true;\n      sortedDependencies: string[];\n    }\n  | { success: false; cyclicNode: string; error: unknown };\n\nexport class DependencyMapUtils {\n  // inspired by https://www.npmjs.com/package/toposort#sorting-dependencies\n  static sortDependencies(dependencyMap: DependencyMap): SortDependencies {\n    const dependencyTree: Array<[string, string | undefined]> = [];\n    const dependencies = dependencyMap.rawDependencies;\n    for (const [node, deps] of dependencies.entries()) {\n      if (deps.size) {\n        deps.forEach((dep) => dependencyTree.push([node, dep]));\n      } else {\n        // Set no dependency\n        dependencyTree.push([node, undefined]);\n      }\n    }\n\n    try {\n      const sortedDependencies = toposort(dependencyTree)\n        .reverse()\n        .filter((edge) => !!edge);\n      return { success: true, sortedDependencies };\n    } catch (error) {\n      // Cyclic dependency found. Extract node\n      const cyclicNodes = (error as Error).message.match(\n        new RegExp('Cyclic dependency, node was:\"(.*)\"'),\n      );\n      const node = cyclicNodes ? cyclicNodes[1] : \"\";\n      return { success: false, cyclicNode: node, error };\n    }\n  }\n\n  static makeParentsDependOnChildren(dependencyMap: DependencyMap) {\n    const dependencies = dependencyMap.rawDependencies;\n    for (const [node, deps] of dependencies.entries()) {\n      this.makeParentsDependOnChild(dependencyMap, node);\n      deps.forEach((dep) => {\n        this.makeParentsDependOnChild(dependencyMap, dep);\n      });\n    }\n    return dependencyMap;\n  }\n\n  static makeParentsDependOnChild = (\n    dependencyMap: DependencyMap,\n    child: string,\n  ) => {\n    let curKey = child;\n    let matches: string[] | null;\n\n    while ((matches = curKey.match(IMMEDIATE_PARENT_REGEX)) !== null) {\n      const immediateParent = matches[1];\n      const existingImmediateParentDeps =\n        dependencyMap.getDirectDependencies(immediateParent) || [];\n      const existingImmediateParentDepsSet = new Set(\n        existingImmediateParentDeps,\n      );\n      // Add child to immediate parent's dependencies if not already present\n      // don't perform addDependency unnecessarily\n      if (!existingImmediateParentDepsSet.has(curKey)) {\n        existingImmediateParentDeps.push(curKey);\n        dependencyMap.addDependency(\n          immediateParent,\n          existingImmediateParentDeps,\n        );\n      }\n      curKey = immediateParent;\n    }\n  };\n}\n","import type { ConfigTree, DataTree } from \"entities/DataTree/dataTreeTypes\";\nimport type ReplayEntity from \"entities/Replay\";\nimport ReplayCanvas from \"entities/Replay/ReplayEntity/ReplayCanvas\";\nimport { isEmpty } from \"lodash\";\nimport type { DependencyMap, EvalError } from \"utils/DynamicBindingUtils\";\nimport { EvalErrorTypes } from \"utils/DynamicBindingUtils\";\nimport type { JSUpdate } from \"utils/JSPaneUtils\";\nimport DataTreeEvaluator from \"workers/common/DataTreeEvaluator\";\nimport type { EvalMetaUpdates } from \"@appsmith/workers/common/DataTreeEvaluator/types\";\nimport { makeEntityConfigsAsObjProperties } from \"@appsmith/workers/Evaluation/dataTreeUtils\";\nimport type { DataTreeDiff } from \"@appsmith/workers/Evaluation/evaluationUtils\";\nimport { serialiseToBigInt } from \"@appsmith/workers/Evaluation/evaluationUtils\";\nimport {\n  CrashingError,\n  getSafeToRenderDataTree,\n} from \"@appsmith/workers/Evaluation/evaluationUtils\";\nimport type {\n  EvalTreeRequestData,\n  EvalTreeResponseData,\n  EvalWorkerSyncRequest,\n} from \"../types\";\nimport { clearAllIntervals } from \"../fns/overrides/interval\";\nimport JSObjectCollection from \"workers/Evaluation/JSObject/Collection\";\nimport { getJSVariableCreatedEvents } from \"../JSObject/JSVariableEvents\";\nimport { errorModifier } from \"../errorModifier\";\nimport {\n  generateOptimisedUpdatesAndSetPrevState,\n  uniqueOrderUpdatePaths,\n} from \"../helpers\";\nimport DataStore from \"../dataStore\";\nimport type { TransmissionErrorHandler } from \"../fns/utils/Messenger\";\nimport { MessageType, sendMessage } from \"utils/MessageUtil\";\nimport {\n  profileFn,\n  newWebWorkerSpanData,\n} from \"UITelemetry/generateWebWorkerTraces\";\nimport type { SpanAttributes } from \"UITelemetry/generateTraces\";\nimport type { CanvasWidgetsReduxState } from \"reducers/entityReducers/canvasWidgetsReducer\";\nimport type { MetaWidgetsReduxState } from \"reducers/entityReducers/metaWidgetsReducer\";\n\nexport let replayMap: Record<string, ReplayEntity<any>> | undefined;\nexport let dataTreeEvaluator: DataTreeEvaluator | undefined;\nexport const CANVAS = \"canvas\";\nexport let canvasWidgetsMeta: Record<string, any>;\nexport let metaWidgetsCache: MetaWidgetsReduxState;\nexport let canvasWidgets: CanvasWidgetsReduxState;\n\nexport function evalTree(request: EvalWorkerSyncRequest) {\n  const { data, webworkerTelemetry } = request;\n  webworkerTelemetry[\"transferDataToWorkerThread\"].endTime = Date.now();\n\n  let evalOrder: string[] = [];\n  let jsUpdates: Record<string, JSUpdate> = {};\n  let unEvalUpdates: DataTreeDiff[] = [];\n  let isCreateFirstTree = false;\n  let dataTree: DataTree = {};\n  let errors: EvalError[] = [];\n  let logs: any[] = [];\n  let dependencies: DependencyMap = {};\n  let evalMetaUpdates: EvalMetaUpdates = [];\n  let configTree: ConfigTree = {};\n  let staleMetaIds: string[] = [];\n  let removedPaths: Array<{ entityId: string; fullpath: string }> = [];\n  let isNewWidgetAdded = false;\n\n  const {\n    affectedJSObjects,\n    allActionValidationConfig,\n    appMode,\n    forceEvaluation,\n    metaWidgets,\n    shouldReplay,\n    shouldRespondWithLogs,\n    theme,\n    unevalTree: __unevalTree__,\n    widgets,\n    widgetsMeta,\n    widgetTypeConfigMap,\n  } = data as EvalTreeRequestData;\n\n  const unevalTree = __unevalTree__.unEvalTree;\n  configTree = __unevalTree__.configTree as ConfigTree;\n  canvasWidgets = widgets;\n  canvasWidgetsMeta = widgetsMeta;\n  metaWidgetsCache = metaWidgets;\n  let isNewTree = false;\n\n  try {\n    (webworkerTelemetry.__spanAttributes as SpanAttributes)[\"firstEvaluation\"] =\n      !dataTreeEvaluator;\n\n    if (!dataTreeEvaluator) {\n      isCreateFirstTree = true;\n      replayMap = replayMap || {};\n      replayMap[CANVAS] = new ReplayCanvas({ widgets, theme });\n      errorModifier.init(appMode);\n      dataTreeEvaluator = new DataTreeEvaluator(\n        widgetTypeConfigMap,\n        allActionValidationConfig,\n      );\n\n      const setupFirstTreeResponse = profileFn(\n        \"setupFirstTree\",\n        { description: \"during initialisation\" },\n        webworkerTelemetry,\n        () =>\n          dataTreeEvaluator?.setupFirstTree(\n            unevalTree,\n            configTree,\n            webworkerTelemetry,\n          ),\n      );\n\n      evalOrder = setupFirstTreeResponse.evalOrder;\n      jsUpdates = setupFirstTreeResponse.jsUpdates;\n\n      const dataTreeResponse = profileFn(\n        \"evalAndValidateFirstTree\",\n        { description: \"during initialisation\" },\n        webworkerTelemetry,\n        () => dataTreeEvaluator?.evalAndValidateFirstTree(),\n      );\n\n      dataTree = makeEntityConfigsAsObjProperties(dataTreeResponse.evalTree, {\n        evalProps: dataTreeEvaluator.evalProps,\n      });\n      staleMetaIds = dataTreeResponse.staleMetaIds;\n      isNewTree = true;\n    } else if (dataTreeEvaluator.hasCyclicalDependency || forceEvaluation) {\n      if (dataTreeEvaluator && !isEmpty(allActionValidationConfig)) {\n        //allActionValidationConfigs may not be set in dataTreeEvaluator. Therefore, set it explicitly via setter method\n        dataTreeEvaluator.setAllActionValidationConfig(\n          allActionValidationConfig,\n        );\n      }\n      if (shouldReplay && replayMap) {\n        replayMap[CANVAS]?.update({ widgets, theme });\n      }\n      dataTreeEvaluator = new DataTreeEvaluator(\n        widgetTypeConfigMap,\n        allActionValidationConfig,\n      );\n      if (dataTreeEvaluator && !isEmpty(allActionValidationConfig)) {\n        dataTreeEvaluator.setAllActionValidationConfig(\n          allActionValidationConfig,\n        );\n      }\n\n      const setupFirstTreeResponse = profileFn(\n        \"setupFirstTree\",\n        { description: \"non-initialisation\" },\n        webworkerTelemetry,\n        () => dataTreeEvaluator?.setupFirstTree(unevalTree, configTree),\n      );\n      isCreateFirstTree = true;\n      evalOrder = setupFirstTreeResponse.evalOrder;\n      jsUpdates = setupFirstTreeResponse.jsUpdates;\n\n      const dataTreeResponse = profileFn(\n        \"evalAndValidateFirstTree\",\n        { description: \"non-initialisation\" },\n        webworkerTelemetry,\n        () => dataTreeEvaluator?.evalAndValidateFirstTree(),\n      );\n\n      dataTree = makeEntityConfigsAsObjProperties(dataTreeResponse.evalTree, {\n        evalProps: dataTreeEvaluator.evalProps,\n      });\n      staleMetaIds = dataTreeResponse.staleMetaIds;\n    } else {\n      if (dataTreeEvaluator && !isEmpty(allActionValidationConfig)) {\n        dataTreeEvaluator.setAllActionValidationConfig(\n          allActionValidationConfig,\n        );\n      }\n      isCreateFirstTree = false;\n      if (shouldReplay && replayMap) {\n        replayMap[CANVAS]?.update({ widgets, theme });\n      }\n\n      const setupUpdateTreeResponse = profileFn(\n        \"setupUpdateTree\",\n        undefined,\n        webworkerTelemetry,\n        () =>\n          dataTreeEvaluator?.setupUpdateTree(\n            unevalTree,\n            configTree,\n            webworkerTelemetry,\n            affectedJSObjects,\n          ),\n      );\n\n      evalOrder = setupUpdateTreeResponse.evalOrder;\n      jsUpdates = setupUpdateTreeResponse.jsUpdates;\n      unEvalUpdates = setupUpdateTreeResponse.unEvalUpdates;\n      removedPaths = setupUpdateTreeResponse.removedPaths;\n      isNewWidgetAdded = setupUpdateTreeResponse.isNewWidgetAdded;\n\n      const updateResponse = profileFn(\n        \"evalAndValidateSubTree\",\n        undefined,\n        webworkerTelemetry,\n        () =>\n          dataTreeEvaluator?.evalAndValidateSubTree(\n            evalOrder,\n            configTree,\n            unEvalUpdates,\n            Object.keys(metaWidgets),\n          ),\n      );\n\n      dataTree = makeEntityConfigsAsObjProperties(dataTreeEvaluator.evalTree, {\n        evalProps: dataTreeEvaluator.evalProps,\n      });\n\n      evalMetaUpdates = JSON.parse(\n        JSON.stringify(updateResponse.evalMetaUpdates),\n      );\n      staleMetaIds = updateResponse.staleMetaIds;\n    }\n    dependencies = dataTreeEvaluator.inverseDependencies;\n    errors = dataTreeEvaluator.errors;\n    dataTreeEvaluator.clearErrors();\n    logs = dataTreeEvaluator.logs;\n    if (shouldReplay && replayMap) {\n      if (replayMap[CANVAS]?.logs) logs = logs.concat(replayMap[CANVAS]?.logs);\n      replayMap[CANVAS]?.clearLogs();\n    }\n\n    dataTreeEvaluator.clearLogs();\n  } catch (error) {\n    if (dataTreeEvaluator !== undefined) {\n      errors = dataTreeEvaluator.errors;\n      logs = dataTreeEvaluator.logs;\n    }\n    if (!(error instanceof CrashingError)) {\n      errors.push({\n        type: EvalErrorTypes.UNKNOWN_ERROR,\n        message: (error as Error).message,\n      });\n      // eslint-disable-next-line\n      console.error(error);\n    }\n    dataTree = getSafeToRenderDataTree(\n      makeEntityConfigsAsObjProperties(unevalTree, {\n        sanitizeDataTree: false,\n        evalProps: dataTreeEvaluator?.evalProps,\n      }),\n      widgetTypeConfigMap,\n      configTree,\n    );\n    unEvalUpdates = [];\n    isNewTree = true;\n  }\n\n  const jsVarsCreatedEvent = getJSVariableCreatedEvents(jsUpdates);\n\n  const updates = profileFn(\n    \"diffAndGenerateSerializeUpdates\",\n    undefined,\n    webworkerTelemetry,\n    () => {\n      let updates;\n      if (isNewTree) {\n        try {\n          //for new tree send the whole thing, don't diff at all\n          updates = serialiseToBigInt([{ kind: \"newTree\", rhs: dataTree }]);\n          dataTreeEvaluator?.setPrevState(dataTree);\n        } catch (e) {\n          updates = \"[]\";\n        }\n        isNewTree = false;\n      } else {\n        const allUnevalUpdates = unEvalUpdates.map(\n          (update) => update.payload.propertyPath,\n        );\n\n        const completeEvalOrder = uniqueOrderUpdatePaths([\n          ...allUnevalUpdates,\n          ...evalOrder,\n        ]);\n\n        updates = generateOptimisedUpdatesAndSetPrevState(\n          dataTree,\n          dataTreeEvaluator,\n          completeEvalOrder,\n        );\n      }\n      return updates;\n    },\n  );\n\n  const evalTreeResponse: EvalTreeResponseData = {\n    updates,\n    dependencies,\n    errors,\n    evalMetaUpdates,\n    evaluationOrder: evalOrder,\n    jsUpdates,\n    webworkerTelemetry,\n    // be weary of the payload size of logs it can be huge and contribute to transmission overhead\n    // we are only sending logs in local debug mode\n    logs: shouldRespondWithLogs ? logs : [],\n    unEvalUpdates,\n    isCreateFirstTree,\n    staleMetaIds,\n    removedPaths,\n    isNewWidgetAdded,\n    undefinedEvalValuesMap: dataTreeEvaluator?.undefinedEvalValuesMap || {},\n    jsVarsCreatedEvent,\n  };\n\n  webworkerTelemetry[\"transferDataToMainThread\"] = newWebWorkerSpanData(\n    \"transferDataToMainThread\",\n    {},\n  );\n\n  return evalTreeResponse;\n}\n\nexport const evalTreeTransmissionErrorHandler: TransmissionErrorHandler = (\n  messageId: string,\n  startTime: number,\n  endTime: number,\n  responseData: unknown,\n) => {\n  const sanitizedData = JSON.parse(JSON.stringify(responseData));\n  sendMessage.call(self, {\n    messageId,\n    messageType: MessageType.RESPONSE,\n    body: { data: sanitizedData, startTime, endTime },\n  });\n};\n\nexport function clearCache() {\n  dataTreeEvaluator = undefined;\n  clearAllIntervals();\n  JSObjectCollection.clear();\n  DataStore.clear();\n  return true;\n}\n","import { dataTreeEvaluator } from \"./evalTree\";\nimport type { EvalWorkerSyncRequest } from \"../types\";\nimport set from \"lodash/set\";\nimport { evalTreeWithChanges } from \"../evalTreeWithChanges\";\nimport DataStore from \"../dataStore\";\n\nexport interface UpdateActionProps {\n  entityName: string;\n  dataPath: string;\n  data: unknown;\n  dataPathRef?: string;\n}\nexport default function (request: EvalWorkerSyncRequest) {\n  const actionsDataToUpdate: UpdateActionProps[] = request.data;\n  handleActionsDataUpdate(actionsDataToUpdate);\n  return true;\n}\n\nexport function handleActionsDataUpdate(actionsToUpdate: UpdateActionProps[]) {\n  if (!dataTreeEvaluator) {\n    return {};\n  }\n  const evalTree = dataTreeEvaluator.getEvalTree();\n\n  for (const actionToUpdate of actionsToUpdate) {\n    const { dataPath, dataPathRef, entityName } = actionToUpdate;\n    let { data } = actionToUpdate;\n\n    if (dataPathRef) {\n      data = DataStore.getActionData(dataPathRef);\n      DataStore.deleteActionData(dataPathRef);\n    }\n    // update the evaltree\n    set(evalTree, `${entityName}.[${dataPath}]`, data);\n    // Update context\n    set(self, `${entityName}.[${dataPath}]`, data);\n    // Update the datastore\n    DataStore.setActionData(`${entityName}.${dataPath}`, data);\n  }\n  const updatedProperties: string[][] = actionsToUpdate.map(\n    ({ dataPath, entityName }) => [entityName, dataPath],\n  );\n  evalTreeWithChanges(updatedProperties, []);\n}\n","import { serialiseToBigInt } from \"@appsmith/workers/Evaluation/evaluationUtils\";\nimport type { WidgetEntity } from \"@appsmith//entities/DataTree/types\";\nimport type { Diff } from \"deep-diff\";\nimport { diff } from \"deep-diff\";\nimport type { DataTree } from \"entities/DataTree/dataTreeTypes\";\nimport equal from \"fast-deep-equal\";\nimport { get, isObject, set } from \"lodash\";\nimport { isMoment } from \"moment\";\nimport { EvalErrorTypes } from \"utils/DynamicBindingUtils\";\n\nexport const fn_keys: string = \"__fn_keys__\";\n\nexport const uniqueOrderUpdatePaths = (updatePaths: string[]) =>\n  Array.from(new Set(updatePaths)).sort((a, b) => b.length - a.length);\n\nexport const getNewDataTreeUpdates = (paths: string[], dataTree: object) =>\n  paths.map((path) => {\n    const segmentedPath = path.split(\".\");\n    return {\n      kind: \"N\",\n      path: segmentedPath,\n      rhs: get(dataTree, segmentedPath),\n    };\n  });\n\nexport interface DiffNewTreeState {\n  kind: \"newTree\";\n  rhs: any;\n}\nexport type DiffWithNewTreeState = Diff<DataTree, DataTree> | DiffNewTreeState;\n// Finds the first index which is a duplicate value\n// Returns -1 if there are no duplicates\n// Returns the index of the first duplicate entry it finds\n\n// Note: This \"can\" fail if the object entries don't have their properties in the\n// same order.\nexport const findDuplicateIndex = (arr: Array<unknown>) => {\n  const _uniqSet = new Set();\n  let currSetSize = 0;\n  for (let i = 0; i < arr.length; i++) {\n    // JSON.stringify because value can be objects\n    _uniqSet.add(JSON.stringify(arr[i]));\n    if (_uniqSet.size > currSetSize) currSetSize = _uniqSet.size;\n    else return i;\n  }\n  return -1;\n};\n\n/** Function that count occurrences of a substring in a string;\n * @param {String} string               The string\n * @param {String} subString            The sub string to search for\n * @param {Boolean} [allowOverlapping]  Optional. (Default:false)\n * @param {Number | null} [maxLimit]  Optional. (Default:null)\n */\nexport const countOccurrences = (\n  string: string,\n  subString: string,\n  allowOverlapping = false,\n  maxLimit: number | null = null,\n): number => {\n  string += \"\";\n  subString += \"\";\n  if (subString.length <= 0) return string.length + 1;\n\n  let n = 0, // count of occurrences\n    pos = 0; // current position of the pointer\n  const step = allowOverlapping ? 1 : subString.length;\n\n  while (true) {\n    pos = string.indexOf(subString, pos);\n    if (pos >= 0) {\n      ++n;\n      /**\n       * If you are only interested in knowing\n       * whether occurances count exceeds maxLimit,\n       * then break the loop.\n       */\n      if (maxLimit && n > maxLimit) break;\n      pos += step;\n    } else break;\n  }\n  return n;\n};\n\nconst LARGE_COLLECTION_SIZE = 100;\n\nexport const stringifyFnsInObject = (\n  userObject: Record<string, unknown>,\n): Record<string, unknown> => {\n  const paths: string[] = parseFunctionsInObject(userObject);\n  const fnStrings: string[] = [];\n\n  for (const path of paths) {\n    const fnValue: any = get(userObject, path);\n    fnStrings.push(fnValue.toString());\n  }\n\n  const output = JSON.parse(JSON.stringify(userObject));\n  for (const [index, parsedFnString] of fnStrings.entries()) {\n    set(output, paths[index], parsedFnString);\n  }\n\n  output[fn_keys] = paths;\n  return output;\n};\n\nconst constructPath = (existingPath: string, suffix: string): string => {\n  if (existingPath.length > 0) {\n    return `${existingPath}.${suffix}`;\n  } else {\n    return suffix;\n  }\n};\n\nconst parseFunctionsInObject = (\n  userObject: Record<string, unknown>,\n  paths: string[] = [],\n  path: string = \"\",\n): string[] => {\n  if (Array.isArray(userObject)) {\n    for (let i = 0; i < userObject.length; i++) {\n      const arrayValue = userObject[i];\n      if (typeof arrayValue == \"function\") {\n        paths.push(constructPath(path, `[${i}]`));\n      } else if (typeof arrayValue == \"object\") {\n        parseFunctionsInObject(\n          arrayValue,\n          paths,\n          constructPath(path, `[${i}]`),\n        );\n      }\n    }\n  } else {\n    const keys = Object.keys(userObject);\n    for (const key of keys) {\n      const value = userObject[key];\n      if (typeof value == \"function\") {\n        paths.push(constructPath(path, key));\n      } else if (typeof value == \"object\") {\n        parseFunctionsInObject(\n          value as Record<string, unknown>,\n          paths,\n          constructPath(path, key),\n        );\n      }\n    }\n  }\n\n  return paths;\n};\n\nconst isLargeCollection = (val: any) => {\n  if (!Array.isArray(val)) return false;\n  const rowSize = !isObject(val[0]) ? 1 : Object.keys(val[0]).length;\n\n  const size = val.length * rowSize;\n\n  return size > LARGE_COLLECTION_SIZE;\n};\n\nconst getReducedDataTree = (\n  dataTree: DataTree,\n  constrainedDiffPaths: string[],\n): DataTree => {\n  const withErrors = Object.keys(dataTree).reduce((acc: any, key: string) => {\n    const widgetValue = dataTree[key] as WidgetEntity;\n    acc[key] = {\n      __evaluation__: {\n        errors: widgetValue.__evaluation__?.errors,\n      },\n    };\n    return acc;\n  }, {});\n\n  return constrainedDiffPaths.reduce((acc: DataTree, key: string) => {\n    set(acc, key, get(dataTree, key));\n    return acc;\n  }, withErrors);\n};\nconst generateDiffUpdates = (\n  oldDataTree: DataTree,\n  dataTree: DataTree,\n  constrainedDiffPaths: string[],\n): Diff<DataTree, DataTree>[] => {\n  const attachDirectly: Diff<DataTree, DataTree>[] = [];\n  const attachLater: Diff<DataTree, DataTree>[] = [];\n\n  // we are reducing the data tree to only the paths that are being diffed\n  const oldData = getReducedDataTree(oldDataTree, constrainedDiffPaths);\n  const newData = getReducedDataTree(dataTree, constrainedDiffPaths);\n  const updates =\n    diff(oldData, newData, (path, key) => {\n      if (!path.length || key === \"__evaluation__\") return false;\n\n      const segmentedPath = [...path, key];\n\n      const rhs = get(dataTree, segmentedPath) as DataTree;\n\n      const lhs = get(oldDataTree, segmentedPath) as DataTree;\n\n      //when a moment value changes we do not want the inner moment object updates, we just want the ISO result of it\n      // which we get during the serialisation process we perform at latter steps\n      if (isMoment(rhs)) {\n        attachDirectly.push({\n          kind: \"E\",\n          lhs,\n          rhs: rhs as any,\n          path: segmentedPath,\n        });\n        // ignore trying to diff moment objects\n        return true;\n      }\n      if (rhs === undefined) {\n        //if an undefined value is being set it should be a delete\n        if (lhs !== undefined) {\n          attachDirectly.push({ kind: \"D\", lhs, path: segmentedPath });\n        }\n        return true;\n      }\n\n      const isLhsLarge = isLargeCollection(lhs);\n      const isRhsLarge = isLargeCollection(rhs);\n      if (!isLhsLarge && !isRhsLarge) {\n        //perform diff on this node\n        return false;\n      }\n\n      //if either of values are large just directly attach it don't have to generate very granular updates\n\n      if ((!isLhsLarge && isRhsLarge) || (isLhsLarge && !isRhsLarge)) {\n        attachDirectly.push({ kind: \"N\", path: segmentedPath, rhs });\n        return true;\n      }\n\n      //if the values are different attach the update directly\n      !equal(lhs, rhs) &&\n        attachDirectly.push({ kind: \"N\", path: segmentedPath, rhs });\n\n      //ignore diff on this node\n      return true;\n    }) || [];\n\n  const largeDataSetUpdates = [...attachDirectly, ...attachLater];\n  return [...updates, ...largeDataSetUpdates];\n};\n\nconst correctUndefinedUpdatesToDeletesOrNew = (\n  updates: Diff<DataTree, DataTree>[],\n) =>\n  updates.reduce(\n    (acc, update) => {\n      const { kind, lhs, path, rhs } = update as any;\n      if (kind === \"E\") {\n        if (lhs === undefined && rhs !== undefined) {\n          acc.push({ kind: \"N\", path, rhs });\n        }\n        if (lhs !== undefined && rhs === undefined) {\n          acc.push({ path, lhs, kind: \"D\" });\n        }\n        if (lhs !== undefined && rhs !== undefined) {\n          acc.push(update);\n        }\n        return acc;\n      }\n      acc.push(update);\n      return acc;\n    },\n    [] as Diff<DataTree, DataTree>[],\n  );\n\n// whenever an element in a collection is set to undefined, we need to send the entire collection as an update\nconst generateRootWidgetUpdates = (\n  updates: Diff<DataTree, DataTree>[],\n  newDataTree: DataTree,\n  oldDataTree: DataTree,\n): Diff<DataTree, DataTree>[] =>\n  updates\n    .filter(\n      (v) =>\n        v.kind === \"D\" &&\n        v.path &&\n        typeof v.path[v.path.length - 1] === \"number\",\n    )\n    .map(\n      ({ path }: any) => {\n        const pathCopy = [...path];\n        pathCopy.pop();\n        return {\n          kind: \"E\",\n          path: pathCopy,\n          lhs: get(oldDataTree, pathCopy) as DataTree,\n          rhs: get(newDataTree, pathCopy) as DataTree,\n        }; //push the parent path\n      },\n      [] as Diff<DataTree, DataTree>[],\n    );\n\n// when a root collection is updated, we need to scrub out updates that are inside the root collection\nconst getScrubbedOutUpdatesWhenRootCollectionIsUpdated = (\n  updates: Diff<DataTree, DataTree>[],\n  rootCollectionUpdates: Diff<DataTree, DataTree>[],\n) => {\n  const rootCollectionPaths = rootCollectionUpdates\n    .filter((update) => update?.path?.length)\n    .map((update) => (update.path as string[]).join(\".\"));\n  return (\n    updates\n      .map((update: any) => ({ update, condensedPath: update.path.join(\".\") }))\n      .filter(\n        ({ condensedPath }) =>\n          !rootCollectionPaths.some((p) => condensedPath.startsWith(p)),\n      )\n      // remove the condensedPath from the update\n      .map(({ update }) => update)\n  );\n};\n\nexport const generateOptimisedUpdates = (\n  oldDataTree: DataTree,\n  dataTree: DataTree,\n  // these are the paths that the diff is limited to, this is a performance optimisation and through this we don't have to diff the entire data tree\n  constrainedDiffPaths: string[],\n): Diff<DataTree, DataTree>[] => {\n  const updates = generateDiffUpdates(\n    oldDataTree,\n    dataTree,\n    constrainedDiffPaths,\n  );\n  const correctedUpdates = correctUndefinedUpdatesToDeletesOrNew(updates);\n\n  const rootCollectionUpdates = generateRootWidgetUpdates(\n    correctedUpdates,\n    dataTree,\n    oldDataTree,\n  );\n  const scrubedOutUpdates = getScrubbedOutUpdatesWhenRootCollectionIsUpdated(\n    correctedUpdates,\n    rootCollectionUpdates,\n  );\n  return [...scrubedOutUpdates, ...rootCollectionUpdates];\n};\n\nexport const generateSerialisedUpdates = (\n  prevState: DataTree,\n  currentState: DataTree,\n  constrainedDiffPaths: string[],\n  mergeAdditionalUpdates?: any,\n): {\n  serialisedUpdates: string;\n  error?: { type: string; message: string };\n} => {\n  const updates = generateOptimisedUpdates(\n    prevState,\n    currentState,\n    constrainedDiffPaths,\n  );\n\n  //remove lhs from diff to reduce the size of diff upload,\n  //it is not necessary to send lhs and we can make the payload to transfer to the main thread smaller for quicker transfer\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  let removedLhs = updates.map(({ lhs, ...rest }: any) => rest);\n  removedLhs = [...removedLhs, ...(mergeAdditionalUpdates || [])];\n\n  try {\n    // serialise bigInt values and convert the updates to a string over here to minismise the cost of transfer\n    // to the main thread. In the main thread parse this object there.\n    return { serialisedUpdates: serialiseToBigInt(removedLhs) };\n  } catch (error) {\n    return {\n      serialisedUpdates: \"[]\",\n      error: {\n        type: EvalErrorTypes.SERIALIZATION_ERROR,\n        message: (error as Error).message,\n      },\n    };\n  }\n};\n\nexport const generateOptimisedUpdatesAndSetPrevState = (\n  dataTree: DataTree,\n  dataTreeEvaluator: any,\n  constrainedDiffPaths: string[],\n  mergeAdditionalUpdates?: any,\n) => {\n  const { error, serialisedUpdates } = generateSerialisedUpdates(\n    dataTreeEvaluator?.getPrevState() || {},\n    dataTree,\n    constrainedDiffPaths,\n    mergeAdditionalUpdates,\n  );\n\n  if (error && dataTreeEvaluator?.errors) {\n    dataTreeEvaluator.errors.push(error);\n  }\n  dataTreeEvaluator?.setPrevState(dataTree);\n  return serialisedUpdates;\n};\n","/* eslint-disable @typescript-eslint/no-unused-vars */\n\nimport type { ValidationResponse, Validator } from \"constants/WidgetValidation\";\nimport { ValidationTypes } from \"constants/WidgetValidation\";\nimport _, {\n  compact,\n  get,\n  isArray,\n  isObject,\n  isPlainObject,\n  isRegExp,\n  isString,\n  toString,\n  uniq,\n} from \"lodash\";\n\nimport moment from \"moment\";\nimport type { ValidationConfig } from \"constants/PropertyControlConstants\";\n\nimport getIsSafeURL from \"utils/validation/getIsSafeURL\";\nimport * as log from \"loglevel\";\nimport {\n  countOccurrences,\n  findDuplicateIndex,\n  stringifyFnsInObject,\n} from \"./helpers\";\n\nexport const UNDEFINED_VALIDATION = \"UNDEFINED_VALIDATION\";\nexport const VALIDATION_ERROR_COUNT_THRESHOLD = 10;\nconst MAX_ALLOWED_LINE_BREAKS = 1000; // Rendering performance deteriorates beyond this number.\nconst LINE_BREAKS_ERROR_MESSAGE = `Warning: New lines in the text exceed ${MAX_ALLOWED_LINE_BREAKS}. The text displayed will not contain any new lines.`;\n\nconst flat = (array: Record<string, any>[], uniqueParam: string) => {\n  let result: { value: string }[] = [];\n  array.forEach((a) => {\n    result.push({ value: a[uniqueParam] });\n    if (Array.isArray(a.children)) {\n      result = result.concat(flat(a.children, uniqueParam));\n    }\n  });\n  return result;\n};\n\nfunction getPropertyEntry(\n  obj: Record<string, unknown>,\n  name: string,\n  ignoreCase = false,\n) {\n  if (!ignoreCase) {\n    return name;\n  } else {\n    const keys = Object.getOwnPropertyNames(obj);\n    return keys.find((key) => key.toLowerCase() === name.toLowerCase()) || name;\n  }\n}\n\nfunction validatePlainObject(\n  config: ValidationConfig,\n  value: Record<string, unknown>,\n  props: Record<string, unknown>,\n  propertyPath: string,\n) {\n  if (config.params?.allowedKeys) {\n    let _valid = true;\n    const _messages: Error[] = [];\n    config.params.allowedKeys.forEach((entry) => {\n      const ignoreCase = !!entry.params?.ignoreCase;\n      const entryName = getPropertyEntry(value, entry.name, ignoreCase);\n\n      if (value.hasOwnProperty(entryName)) {\n        const { isValid, messages, parsed } = validate(\n          entry,\n          value[entryName],\n          props,\n          propertyPath,\n        );\n        if (!isValid) {\n          value[entryName] = parsed;\n          _valid = isValid;\n          messages &&\n            messages.map((message) => {\n              _messages.push({\n                name: message.name,\n                message: `Value of key: ${entryName} is invalid: ${message.message}`,\n              });\n            });\n        }\n      } else if (entry.params?.required || entry.params?.requiredKey) {\n        _valid = false;\n        _messages.push({\n          name: \"ValidationError\",\n          message: `Missing required key: ${entryName}`,\n        });\n      }\n    });\n    if (_valid) {\n      return {\n        isValid: true,\n        parsed: value,\n      };\n    }\n    return {\n      isValid: false,\n      parsed: config.params?.default || value,\n      messages: _messages,\n    };\n  }\n  return {\n    isValid: true,\n    parsed: value,\n  };\n}\n\nfunction validateArray(\n  config: ValidationConfig,\n  value: unknown[],\n  props: Record<string, unknown>,\n  propertyPath: string,\n) {\n  let _isValid = true; // Let's first assume that this is valid\n  const _messages: Error[] = []; // Initialise messages array\n\n  // Values allowed in the array, converted into a set of unique values\n  // or an empty set\n  const allowedValues = new Set(config.params?.allowedValues || []);\n\n  // Keys whose values are supposed to be unique across all values in all objects in the array\n  let uniqueKeys: Array<string> = [];\n  const allowedKeyConfigs = config.params?.children?.params?.allowedKeys;\n\n  if (\n    config.params?.children?.type === ValidationTypes.OBJECT &&\n    Array.isArray(allowedKeyConfigs) &&\n    allowedKeyConfigs.length\n  ) {\n    uniqueKeys = compact(\n      allowedKeyConfigs.map((allowedKeyConfig) => {\n        // TODO(abhinav): This is concerning, we now have two ways,\n        // in which we can define unique keys in an array of objects\n        // We need to disable one option.\n\n        // If this key is supposed to be unique across all objects in the value array\n        // We include it in the uniqueKeys list\n        if (allowedKeyConfig.params?.unique) return allowedKeyConfig.name;\n      }),\n    );\n  }\n\n  // Concatenate unique keys from config.params?.unique\n  uniqueKeys = Array.isArray(config.params?.unique)\n    ? uniqueKeys.concat(config.params?.unique as Array<string>)\n    : uniqueKeys;\n\n  // Validation configuration for children\n  const childrenValidationConfig = config.params?.children;\n\n  // Should we validate against disallowed values in the value array?\n  const shouldVerifyAllowedValues = !!allowedValues.size; // allowedValues is a set\n\n  // Do we have validation config for array children?\n  const shouldValidateChildren = !!childrenValidationConfig;\n\n  // Should array values be unique? This should applies only to primitive values in array children\n  // If we have to validate children with their own validation config, this should be false (Needs verification)\n  // If this option is true, shouldArrayValuesHaveUniqueValuesForKeys will become false\n  const shouldArrayHaveUniqueEntries = config.params?.unique === true;\n\n  // Should we validate for unique values for properties in the array entries?\n  const shouldArrayValuesHaveUniqueValuesForKeys =\n    !!uniqueKeys.length && !shouldArrayHaveUniqueEntries;\n\n  // Verify if all values are unique\n  if (shouldArrayHaveUniqueEntries) {\n    // Find the index of a duplicate value in array\n    const duplicateIndex = findDuplicateIndex(value);\n    if (duplicateIndex !== -1) {\n      // Bail out early\n      // Because, we don't want to re-iterate, if this validation fails\n      return {\n        isValid: false,\n        parsed: config.params?.default || [],\n        messages: [\n          {\n            name: \"ValidationError\",\n            message: `Array must be unique. Duplicate values found at index: ${duplicateIndex}`,\n          },\n        ],\n      };\n    }\n  }\n\n  if (shouldArrayValuesHaveUniqueValuesForKeys) {\n    // Loop\n    // Get only unique entries from the value array\n    const uniqueEntries = _.uniqWith(\n      value as Array<Record<string, unknown>>,\n      (a: Record<string, unknown>, b: Record<string, unknown>) => {\n        // If any of the keys are the same, we fail the uniqueness test\n        return uniqueKeys.some((key) => a[key] === b[key]);\n      },\n    );\n\n    if (uniqueEntries.length !== value.length) {\n      // Bail out early\n      // Because, we don't want to re-iterate, if this validation fails\n      return {\n        isValid: false,\n        parsed: config.params?.default || [],\n        messages: [\n          {\n            name: \"ValidationError\",\n            message: `Duplicate values found for the following properties, in the array entries, that must be unique -- ${uniqueKeys.join(\n              \",\",\n            )}.`,\n          },\n        ],\n      };\n    }\n  }\n\n  // Loop\n  value.every((entry, index) => {\n    // Validate for allowed values\n    if (shouldVerifyAllowedValues && !allowedValues.has(entry)) {\n      _messages.push({\n        name: \"ValidationError\",\n        message: `Value is not allowed in this array: ${entry}`,\n      });\n      _isValid = false;\n    }\n\n    // validate using validation config\n    if (shouldValidateChildren && childrenValidationConfig) {\n      // Validate this entry\n      const childValidationResult = validate(\n        childrenValidationConfig,\n        entry,\n        props,\n        `${propertyPath}[${index}]`,\n      );\n\n      // If invalid, append to messages\n      if (!childValidationResult.isValid) {\n        _isValid = false;\n        childValidationResult.messages?.forEach((message) =>\n          _messages.push({\n            name: message.name,\n            message: `Invalid entry at index: ${index}. ${message.message}`,\n          }),\n        );\n      }\n    }\n\n    // Bail out, if the error count threshold has been overcome\n    // This way, debugger will not have to render too many errors\n    if (_messages.length >= VALIDATION_ERROR_COUNT_THRESHOLD && !_isValid) {\n      return false;\n    }\n    return true;\n  });\n\n  return {\n    isValid: _isValid,\n    parsed: _isValid ? value : config.params?.default || [],\n    messages: _messages,\n  };\n}\n\nfunction validateExcessLineBreaks(value: any): boolean {\n  /**\n   * Check if the value exceeds a threshold number of line breaks;\n   * beyond which the rendering performance starts deteriorating.\n   */\n  const str: string = isObject(value) ? JSON.stringify(value, null, 2) : value;\n  const lineBreakCount: number = countOccurrences(\n    str,\n    \"\\n\",\n    false,\n    MAX_ALLOWED_LINE_BREAKS,\n  );\n  return lineBreakCount > MAX_ALLOWED_LINE_BREAKS;\n}\n\nfunction validateExcessLength(text: string, maxLength: number): boolean {\n  /**\n   * Check if text is too long and without any line breaks.\n   */\n  const lineBreakCount = countOccurrences(text, \"\\n\", false, 0);\n  return lineBreakCount === 0 && text.length > maxLength;\n}\n\n/**\n * Iterate through an object,\n * Check for length of string values\n * and trim them in case they are too long.\n */\nfunction validateObjectValues(obj: any): any {\n  if (!obj) return;\n  Object.keys(obj).forEach((key) => {\n    if (typeof obj[key] === \"string\" && obj[key].length > 100000) {\n      obj[key] = obj[key].substring(0, 100000);\n    } else if (isObject(obj[key])) {\n      obj[key] = validateObjectValues(obj[key]);\n    } else if (isArray(obj[key])) {\n      obj[key] = obj[key].map((item: any) => validateObjectValues(item));\n    }\n  });\n  return obj;\n}\n\n//TODO: parameter props may not be in use\nexport const validate = (\n  config: ValidationConfig,\n  value: unknown,\n  props: Record<string, unknown>,\n  propertyPath = \"\",\n): ValidationResponse => {\n  const validateFn = VALIDATORS[config.type];\n  const staticValue = {\n    isValid: true,\n    parsed: value,\n  };\n  if (!validateFn) return staticValue;\n\n  return validateFn(config, value, props, propertyPath) || staticValue;\n};\n\nexport const WIDGET_TYPE_VALIDATION_ERROR =\n  \"This value does not evaluate to type\"; // TODO: Lot's of changes in validations.ts file\n\nexport function getExpectedType(config?: ValidationConfig): string | undefined {\n  if (!config) return UNDEFINED_VALIDATION; // basic fallback\n  switch (config.type) {\n    case ValidationTypes.FUNCTION:\n      return config.params?.expected?.type || \"unknown\";\n    case ValidationTypes.TEXT:\n      let result = \"string\";\n      if (config.params?.allowedValues) {\n        const allowed = config.params.allowedValues.join(\" | \");\n        result = result + ` ( ${allowed} )`;\n      }\n      if (config.params?.regex) {\n        result = config.params?.regex.source;\n      }\n      if (config.params?.expected?.type) result = config.params?.expected.type;\n      return result;\n    case ValidationTypes.REGEX:\n      return \"regExp\";\n    case ValidationTypes.DATE_ISO_STRING:\n      return \"ISO 8601 date string\";\n    case ValidationTypes.BOOLEAN:\n      return \"boolean\";\n    case ValidationTypes.NUMBER:\n      let validationType = \"number\";\n      if (config.params?.min) {\n        validationType = `${validationType} Min: ${config.params?.min}`;\n      }\n      if (config.params?.max) {\n        validationType = `${validationType} Max: ${config.params?.max}`;\n      }\n      if (config.params?.required) {\n        validationType = `${validationType} Required`;\n      }\n\n      return validationType;\n    case ValidationTypes.OBJECT:\n    case ValidationTypes.OBJECT_WITH_FUNCTION:\n      let objectType = \"Object\";\n      if (config.params?.allowedKeys) {\n        objectType = \"{\";\n        config.params?.allowedKeys.forEach((allowedKeyConfig) => {\n          const _expected = getExpectedType(allowedKeyConfig);\n          objectType = `${objectType} \"${allowedKeyConfig.name}\": \"${_expected}\",`;\n        });\n        objectType = `${objectType.substring(0, objectType.length - 1)} }`;\n        return objectType;\n      }\n      return objectType;\n    case ValidationTypes.ARRAY:\n    case ValidationTypes.NESTED_OBJECT_ARRAY:\n      if (config.params?.allowedValues) {\n        const allowed = config.params?.allowedValues.join(\"' | '\");\n        return `Array<'${allowed}'>`;\n      }\n      if (config.params?.children) {\n        const children = getExpectedType(config.params.children);\n        return `Array<${children}>`;\n      }\n      return \"Array\";\n    case ValidationTypes.OBJECT_ARRAY:\n      return `Array<Object>`;\n    case ValidationTypes.IMAGE_URL:\n      return `base64 encoded image | data uri | image url`;\n    case ValidationTypes.SAFE_URL:\n      return \"URL\";\n  }\n}\n\nexport const VALIDATORS: Record<ValidationTypes, Validator> = {\n  [ValidationTypes.TEXT]: (\n    config: ValidationConfig,\n    value: unknown,\n    props: Record<string, unknown>,\n  ): ValidationResponse => {\n    if (value === undefined || value === null || value === \"\") {\n      if (config.params && config.params.required) {\n        return {\n          isValid: false,\n          parsed: config.params?.default || \"\",\n          messages: [\n            {\n              name: \"TypeError\",\n              message: `${WIDGET_TYPE_VALIDATION_ERROR} ${getExpectedType(\n                config,\n              )}`,\n            },\n          ],\n        };\n      }\n\n      return {\n        isValid: true,\n        parsed: config.params?.default || \"\",\n      };\n    }\n    let parsed = value;\n\n    if (isObject(value)) {\n      if (\n        config.params &&\n        config.params.limitLineBreaks &&\n        validateExcessLineBreaks(value)\n      ) {\n        return {\n          isValid: false,\n          parsed: JSON.stringify(validateObjectValues(value)), // Parse without line breaks\n          messages: [\n            {\n              name: \"ValidationError\",\n              message: LINE_BREAKS_ERROR_MESSAGE,\n            },\n          ],\n        };\n      }\n      return {\n        isValid: false,\n        parsed: JSON.stringify(validateObjectValues(value), null, 2),\n        messages: [\n          {\n            name: \"TypeError\",\n            message: `${WIDGET_TYPE_VALIDATION_ERROR} ${getExpectedType(\n              config,\n            )}`,\n          },\n        ],\n      };\n    }\n\n    const isValid = isString(parsed);\n    const stringValidationError = {\n      isValid: false,\n      parsed: config.params?.default || \"\",\n      messages: [\n        {\n          name: \"TypeError\",\n          message: `${WIDGET_TYPE_VALIDATION_ERROR} ${getExpectedType(config)}`,\n        },\n      ],\n    };\n    if (!isValid) {\n      try {\n        if (!config.params?.strict) parsed = toString(parsed);\n        else return stringValidationError;\n      } catch (e) {\n        return stringValidationError;\n      }\n    }\n    if (\n      config.params &&\n      config.params.limitLineBreaks &&\n      validateExcessLineBreaks(value)\n    ) {\n      return {\n        isValid: false,\n        parsed: JSON.stringify(value), // Parse without line breaks\n        messages: [\n          {\n            name: \"ValidationError\",\n            message: LINE_BREAKS_ERROR_MESSAGE,\n          },\n        ],\n      };\n    }\n    if (config.params?.allowedValues) {\n      if (!config.params?.allowedValues.includes((parsed as string).trim())) {\n        return {\n          parsed: config.params?.default || \"\",\n          messages: [\n            {\n              name: \"ValidationError\",\n              message: `Disallowed value: ${parsed}`,\n            },\n          ],\n          isValid: false,\n        };\n      }\n    }\n\n    if (validateExcessLength(parsed as string, 200000)) {\n      return {\n        parsed: (parsed as string)?.substring(0, 200000),\n        isValid: false,\n        messages: [\n          {\n            name: \"ValidationError\",\n            message:\n              \"Excessive text length without a line break. Rendering a substring to avoid app crash.\",\n          },\n        ],\n      };\n    }\n\n    if (\n      config.params?.regex &&\n      isRegExp(config.params?.regex) &&\n      !config.params?.regex.test(parsed as string)\n    ) {\n      return {\n        parsed: config.params?.default || \"\",\n        messages: [\n          {\n            name: \"TypeError\",\n            message: `${WIDGET_TYPE_VALIDATION_ERROR} ${getExpectedType(\n              config,\n            )}`,\n          },\n        ],\n        isValid: false,\n      };\n    }\n\n    return {\n      isValid: true,\n      parsed,\n    };\n  },\n  // TODO(abhinav): The original validation does not make sense fix this.\n  [ValidationTypes.REGEX]: (\n    config: ValidationConfig,\n    value: unknown,\n    props: Record<string, unknown>,\n    propertyPath: string,\n  ): ValidationResponse => {\n    const { isValid, messages, parsed } = VALIDATORS[ValidationTypes.TEXT](\n      config,\n      value,\n      props,\n      propertyPath,\n    );\n\n    if (!isValid) {\n      return {\n        isValid: false,\n        parsed: new RegExp(parsed),\n        messages: [\n          {\n            name: \"TypeError\",\n            message: `${WIDGET_TYPE_VALIDATION_ERROR} ${getExpectedType(\n              config,\n            )}`,\n          },\n        ],\n      };\n    }\n\n    return { isValid, parsed, messages };\n  },\n  [ValidationTypes.NUMBER]: (\n    config: ValidationConfig,\n    value: unknown,\n    props: Record<string, unknown>,\n  ): ValidationResponse => {\n    if (value === undefined || value === null || value === \"\") {\n      if (config.params?.required) {\n        return {\n          isValid: false,\n          parsed: config.params?.default || 0,\n          messages: [\n            {\n              name: \"ValidationError\",\n              message: \"This value is required\",\n            },\n          ],\n        };\n      }\n\n      if (value === \"\") {\n        return {\n          isValid: true,\n          parsed: config.params?.default || 0,\n        };\n      }\n\n      return {\n        isValid: true,\n        parsed: value,\n      };\n    }\n    if (!Number.isFinite(value) && !isString(value)) {\n      return {\n        isValid: false,\n        parsed: config.params?.default || 0,\n        messages: [\n          {\n            name: \"TypeError\",\n            message: `${WIDGET_TYPE_VALIDATION_ERROR} ${getExpectedType(\n              config,\n            )}`,\n          },\n        ],\n      };\n    }\n\n    // check for min and max limits\n    let parsed: number = value as number;\n    if (isString(value)) {\n      if (/^-?\\d+\\.?\\d*$/.test(value)) {\n        parsed = Number(value);\n      } else {\n        return {\n          isValid: false,\n          parsed: value || config.params?.default || 0,\n          messages: [\n            {\n              name: \"TypeError\",\n              message: `${WIDGET_TYPE_VALIDATION_ERROR} ${getExpectedType(\n                config,\n              )}`,\n            },\n          ],\n        };\n      }\n    }\n\n    if (\n      config.params?.min !== undefined &&\n      Number.isFinite(config.params.min)\n    ) {\n      if (parsed < Number(config.params.min)) {\n        return {\n          isValid: false,\n          parsed:\n            // passThroughOnZero is introduced to resolve a bug and to not break existing apps\n            // Refer: https://github.com/appsmithorg/appsmith/issues/17472#issuecomment-1281818238\n            config.params.passThroughOnZero === false\n              ? parsed || config.params.min || 0\n              : parsed ?? config.params.min ?? 0,\n          messages: [\n            {\n              name: \"RangeError\",\n              message: `Minimum allowed value: ${config.params.min}`,\n            },\n          ],\n        };\n      }\n    }\n\n    if (\n      config.params?.max !== undefined &&\n      Number.isFinite(config.params.max)\n    ) {\n      if (parsed > Number(config.params.max)) {\n        return {\n          isValid: false,\n          parsed: config.params.max || parsed || 0,\n          messages: [\n            {\n              name: \"RangeError\",\n              message: `Maximum allowed value: ${config.params.max}`,\n            },\n          ],\n        };\n      }\n    }\n    if (config.params?.natural && (parsed < 0 || !Number.isInteger(parsed))) {\n      return {\n        isValid: false,\n        parsed: config.params.default || parsed || 0,\n        messages: [\n          {\n            name: \"ValidationError\",\n            message: `Value should be a positive integer`,\n          },\n        ],\n      };\n    }\n\n    return {\n      isValid: true,\n      parsed,\n    };\n  },\n  [ValidationTypes.BOOLEAN]: (\n    config: ValidationConfig,\n    value: unknown,\n    props: Record<string, unknown>,\n  ): ValidationResponse => {\n    if (value === undefined || value === null || value === \"\") {\n      if (config.params && config.params.required) {\n        return {\n          isValid: false,\n          parsed: !!config.params?.default,\n          messages: [\n            {\n              name: \"TypeError\",\n              message: `${WIDGET_TYPE_VALIDATION_ERROR} ${getExpectedType(\n                config,\n              )}`,\n            },\n          ],\n        };\n      }\n\n      if (value === \"\") {\n        return {\n          isValid: true,\n          parsed: config.params?.default || false,\n        };\n      }\n\n      return { isValid: true, parsed: config.params?.default || value };\n    }\n    const isABoolean = value === true || value === false;\n    const isStringTrueFalse = value === \"true\" || value === \"false\";\n    // if strictCheck is true then stringTrueFalse are considered invalid value.\n    const strictCheck = config.params && config.params.strict;\n    const isValid = strictCheck ? isABoolean : isABoolean || isStringTrueFalse;\n\n    let parsed = value;\n    if (isStringTrueFalse && !strictCheck) parsed = value !== \"false\";\n\n    if (!isValid) {\n      return {\n        isValid: false,\n        parsed: config.params?.default || false,\n        messages: [\n          {\n            name: \"TypeError\",\n            message: `${WIDGET_TYPE_VALIDATION_ERROR} ${getExpectedType(\n              config,\n            )}`,\n          },\n        ],\n      };\n    }\n\n    return { isValid, parsed };\n  },\n  [ValidationTypes.OBJECT]: (\n    config: ValidationConfig,\n    value: unknown,\n    props: Record<string, unknown>,\n    propertyPath: string,\n  ): ValidationResponse => {\n    if (\n      value === undefined ||\n      value === null ||\n      (isString(value) && value.trim().length === 0)\n    ) {\n      if (config.params && config.params.required) {\n        return {\n          isValid: false,\n          parsed: config.params?.default || {},\n          messages: [\n            {\n              name: \"TypeError\",\n              message: `${WIDGET_TYPE_VALIDATION_ERROR}: ${getExpectedType(\n                config,\n              )}`,\n            },\n          ],\n        };\n      }\n      return {\n        isValid: true,\n        parsed: config.params?.default || value,\n      };\n    }\n\n    if (isPlainObject(value)) {\n      return validatePlainObject(\n        config,\n        value as Record<string, unknown>,\n        props,\n        propertyPath,\n      );\n    }\n\n    try {\n      const result = { parsed: JSON.parse(value as string), isValid: true };\n      if (isPlainObject(result.parsed)) {\n        return validatePlainObject(config, result.parsed, props, propertyPath);\n      }\n      return {\n        isValid: false,\n        parsed: config.params?.default || {},\n        messages: [\n          {\n            name: \"TypeError\",\n            message: `${WIDGET_TYPE_VALIDATION_ERROR}: ${getExpectedType(\n              config,\n            )}`,\n          },\n        ],\n      };\n    } catch (e) {\n      return {\n        isValid: false,\n        parsed: config.params?.default || {},\n        messages: [\n          {\n            name: \"TypeError\",\n            message: `${WIDGET_TYPE_VALIDATION_ERROR}: ${getExpectedType(\n              config,\n            )}`,\n          },\n        ],\n      };\n    }\n  },\n  [ValidationTypes.ARRAY]: (\n    config: ValidationConfig,\n    value: unknown,\n    props: Record<string, unknown>,\n    propertyPath: string,\n  ): ValidationResponse => {\n    const invalidResponse = {\n      isValid: false,\n      parsed: config.params?.default || [],\n      messages: [\n        {\n          name: \"TypeError\",\n          message: `${WIDGET_TYPE_VALIDATION_ERROR} ${getExpectedType(config)}`,\n        },\n      ],\n    };\n    if (value === undefined || value === null || value === \"\") {\n      if (\n        config.params &&\n        config.params.required &&\n        !isArray(config.params.default)\n      ) {\n        invalidResponse.messages = [\n          {\n            name: \"ValidationError\",\n            message:\n              \"This property is required for the widget to function correctly\",\n          },\n        ];\n        return invalidResponse;\n      }\n      if (value === \"\") {\n        return {\n          isValid: true,\n          parsed: config.params?.default || [],\n        };\n      }\n      if (config.params && isArray(config.params.default)) {\n        return {\n          isValid: true,\n          parsed: config.params?.default,\n        };\n      }\n\n      return {\n        isValid: true,\n        parsed: value,\n      };\n    }\n\n    if (isString(value)) {\n      try {\n        const _value = JSON.parse(value);\n        if (Array.isArray(_value)) {\n          const result = validateArray(config, _value, props, propertyPath);\n          return result;\n        }\n      } catch (e) {\n        return invalidResponse;\n      }\n    }\n\n    if (Array.isArray(value)) {\n      return validateArray(config, value, props, propertyPath);\n    }\n\n    return invalidResponse;\n  },\n  [ValidationTypes.OBJECT_ARRAY]: (\n    config: ValidationConfig,\n    value: unknown,\n    props: Record<string, unknown>,\n  ): ValidationResponse => {\n    const invalidResponse = {\n      isValid: false,\n      parsed: config.params?.default || [{}],\n      messages: [\n        {\n          name: \"TypeError\",\n          message: `${WIDGET_TYPE_VALIDATION_ERROR} ${getExpectedType(config)}`,\n        },\n      ],\n    };\n    if (value === undefined || value === null || value === \"\") {\n      if (config.params?.required) return invalidResponse;\n\n      if (value === \"\") {\n        return {\n          isValid: true,\n          parsed: config.params?.default || [{}],\n        };\n      }\n\n      return { isValid: true, parsed: value };\n    }\n    if (!isString(value) && !Array.isArray(value)) {\n      return invalidResponse;\n    }\n\n    let parsed = value;\n\n    if (isString(value)) {\n      try {\n        parsed = JSON.parse(value);\n      } catch (e) {\n        return invalidResponse;\n      }\n    }\n\n    if (Array.isArray(parsed)) {\n      if (parsed.length === 0) {\n        if (config.params?.required) {\n          return invalidResponse;\n        } else {\n          return {\n            isValid: true,\n            parsed: config.params?.default || [{}],\n          };\n        }\n      }\n\n      for (const [index, parsedEntry] of parsed.entries()) {\n        if (!isPlainObject(parsedEntry)) {\n          return {\n            ...invalidResponse,\n            messages: [\n              {\n                name: \"ValidationError\",\n                message: `Invalid object at index ${index}`,\n              },\n            ],\n          };\n        }\n      }\n      return { isValid: true, parsed };\n    }\n    return invalidResponse;\n  },\n\n  [ValidationTypes.NESTED_OBJECT_ARRAY]: (\n    config: ValidationConfig,\n    value: unknown,\n    props: Record<string, unknown>,\n    propertyPath: string,\n  ): ValidationResponse => {\n    let response: ValidationResponse = {\n      isValid: false,\n      parsed: config.params?.default || [],\n      messages: [\n        {\n          name: \"TypeError\",\n          message: `${WIDGET_TYPE_VALIDATION_ERROR} ${getExpectedType(config)}`,\n        },\n      ],\n    };\n    response = VALIDATORS.ARRAY(config, value, props, propertyPath);\n\n    if (!response.isValid) {\n      return response;\n    }\n    // Check if all values and children values are unique\n    if (config.params?.unique && response.parsed.length) {\n      if (isArray(config.params?.unique)) {\n        for (const param of config.params?.unique) {\n          const flattenedArray = flat(response.parsed, param);\n          const shouldBeUnique = flattenedArray.map((entry) =>\n            get(entry, param, \"\"),\n          );\n          if (uniq(shouldBeUnique).length !== flattenedArray.length) {\n            response = {\n              ...response,\n              isValid: false,\n              messages: [\n                {\n                  name: \"ValidationError\",\n                  message: `path:${param} must be unique. Duplicate values found`,\n                },\n              ],\n            };\n          }\n        }\n      }\n    }\n    return response;\n  },\n  [ValidationTypes.DATE_ISO_STRING]: (\n    config: ValidationConfig,\n    value: unknown,\n    props: Record<string, unknown>,\n  ): ValidationResponse => {\n    let isValid = false;\n    let parsed = value;\n    let message = { name: \"\", message: \"\" };\n\n    if (_.isNil(value) || value === \"\") {\n      parsed = config.params?.default;\n\n      if (config.params?.required) {\n        isValid = false;\n        message = {\n          name: \"TypeError\",\n          message: `Value does not match: ${getExpectedType(config)}`,\n        };\n      } else {\n        isValid = true;\n      }\n    } else if (typeof value === \"object\" && moment(value).isValid()) {\n      //Date and moment object\n      isValid = true;\n      parsed = moment(value).toISOString(true);\n    } else if (isString(value)) {\n      //Date string\n      if (\n        value === moment(value).toISOString() ||\n        value === moment(value).toISOString(true)\n      ) {\n        return {\n          isValid: true,\n          parsed: value,\n        };\n      } else if (moment(value).isValid()) {\n        isValid = true;\n        parsed = moment(value).toISOString(true);\n      } else {\n        isValid = false;\n        message = {\n          name: \"TypeError\",\n          message: `Value does not match: ${getExpectedType(config)}`,\n        };\n        parsed = config.params?.default;\n      }\n    } else {\n      isValid = false;\n      message = {\n        name: \"TypeError\",\n        message: `Value does not match: ${getExpectedType(config)}`,\n      };\n    }\n\n    const result: ValidationResponse = {\n      isValid,\n      parsed,\n    };\n\n    if (message) {\n      result.messages = [message];\n    }\n\n    return result;\n  },\n  [ValidationTypes.FUNCTION]: (\n    config: ValidationConfig,\n    value: unknown,\n    props: Record<string, unknown>,\n    propertyPath: string,\n  ): ValidationResponse => {\n    const invalidResponse = {\n      isValid: false,\n      parsed: undefined,\n      messages: [\n        {\n          name: \"ValidationError\",\n          message: \"Failed to validate\",\n        },\n      ],\n    };\n    if (config.params?.fnString && isString(config.params?.fnString)) {\n      try {\n        const fnBody = `const fn = ${config.params?.fnString};\n        return fn(value, props, _, moment, propertyPath, config);`;\n\n        const result = new Function(\n          \"value\",\n          \"props\",\n          \"_\",\n          \"moment\",\n          \"propertyPath\",\n          \"config\",\n          fnBody,\n        )(value, props, self._, self.moment, propertyPath, config);\n\n        return result;\n      } catch (e) {\n        log.error(\"Validation function error: \", { e });\n      }\n    }\n    return invalidResponse;\n  },\n  [ValidationTypes.IMAGE_URL]: (\n    config: ValidationConfig,\n    value: unknown,\n    props: Record<string, unknown>,\n  ): ValidationResponse => {\n    const invalidResponse = {\n      isValid: false,\n      parsed: config.params?.default || \"\",\n      messages: [\n        {\n          name: \"TypeError\",\n          message: `${WIDGET_TYPE_VALIDATION_ERROR}: ${getExpectedType(\n            config,\n          )}`,\n        },\n      ],\n    };\n    const base64Regex =\n      /^(?:[A-Za-z\\d+\\/]{4})*?(?:[A-Za-z\\d+\\/]{2}(?:==)?|[A-Za-z\\d+\\/]{3}=?)?$/;\n    const base64ImageRegex = /^data:image\\/.*;base64/;\n    const imageUrlRegex =\n      /(http(s?)?:\\/\\/(localhost|([/|.|\\w|\\s|-])*\\.(?:jpeg|jpg|gif|png)??(?:&?[^=&]*=[^=&]*)*))/;\n    if (\n      value === undefined ||\n      value === null ||\n      (isString(value) && value.trim().length === 0)\n    ) {\n      if (config.params && config.params.required) return invalidResponse;\n      return { isValid: true, parsed: value };\n    }\n    if (isString(value)) {\n      if (imageUrlRegex.test(value.trim())) {\n        return { isValid: true, parsed: value.trim() };\n      }\n      if (base64ImageRegex.test(value)) {\n        return {\n          isValid: true,\n          parsed: value,\n        };\n      }\n      if (base64Regex.test(value) && btoa(atob(value)) === value) {\n        return { isValid: true, parsed: `data:image/png;base64,${value}` };\n      }\n    }\n    return invalidResponse;\n  },\n  [ValidationTypes.SAFE_URL]: (\n    config: ValidationConfig,\n    value: unknown,\n  ): ValidationResponse => {\n    const invalidResponse = {\n      isValid: false,\n      parsed: config?.params?.default || \"\",\n      messages: [\n        {\n          name: \"TypeError\",\n          message: `${WIDGET_TYPE_VALIDATION_ERROR}: ${getExpectedType(\n            config,\n          )}`,\n        },\n      ],\n    };\n\n    if (typeof value === \"string\" && getIsSafeURL(value)) {\n      return {\n        isValid: true,\n        parsed: value,\n      };\n    } else {\n      return invalidResponse;\n    }\n  },\n\n  /**\n   *\n   * ARRAY_OF_TYPE_OR_TYPE can be used in scenarios where we wanted to validate\n   * using ValidationTypes.ARRAY or ValidationTypes.* at the same time.\n   *\n   * This is needed in case of properties inside\n   * 1. Table widget where we use COMPUTE_VALUE\n   * 2. Menu button widget where we use MENU_BUTTON_DYNAMIC_ITEMS\n   *\n   * For more info: https://github.com/appsmithorg/appsmith/pull/9396\n   */\n  [ValidationTypes.ARRAY_OF_TYPE_OR_TYPE]: (\n    config: ValidationConfig,\n    value: unknown,\n    props: Record<string, unknown>,\n    propertyPath: string,\n  ): ValidationResponse => {\n    if (!config.params?.type)\n      return {\n        isValid: false,\n        parsed: undefined,\n        messages: [\n          {\n            name: \"ValidationError\",\n            message: \"Invalid validation\",\n          },\n        ],\n      };\n\n    // Validate when JS mode is disabled\n    const result = VALIDATORS[config.params.type as ValidationTypes](\n      config.params as ValidationConfig,\n      value,\n      props,\n      propertyPath,\n    );\n    if (result.isValid) return result;\n\n    // Validate when JS mode is enabled\n    const resultValue = [];\n    if (_.isArray(value)) {\n      for (const item of value) {\n        const result = VALIDATORS[config.params.type](\n          config.params as ValidationConfig,\n          item,\n          props,\n          propertyPath,\n        );\n        if (!result.isValid) return result;\n        resultValue.push(result.parsed);\n      }\n    } else {\n      return {\n        isValid: false,\n        parsed: config.params?.params?.default,\n        messages: result.messages,\n      };\n    }\n\n    return {\n      isValid: true,\n      parsed: resultValue,\n    };\n  },\n  [ValidationTypes.OBJECT_WITH_FUNCTION]: (\n    config: ValidationConfig,\n    value: any,\n    props: Record<string, unknown>,\n    propertyPath: string,\n  ): ValidationResponse => {\n    const invalidResponse = {\n      isValid: true,\n      parsed: {},\n      messages: [\n        {\n          name: \"TypeError\",\n          message: `${WIDGET_TYPE_VALIDATION_ERROR} ${getExpectedType(config)}`,\n        },\n      ],\n    };\n\n    const { isValid, messages, parsed } = VALIDATORS[ValidationTypes.OBJECT](\n      config,\n      value,\n      props,\n      propertyPath,\n    );\n\n    if (!isValid) {\n      return { isValid, messages, parsed }; // return the expected type\n    } else {\n      return { isValid, messages, parsed: stringifyFnsInObject(parsed) };\n    }\n  },\n\n  [ValidationTypes.UNION]: (\n    config: ValidationConfig,\n    value: unknown,\n    props: Record<string, unknown>,\n    propertyPath: string,\n  ): ValidationResponse => {\n    if (config.params?.types && config.params?.types.length > 0) {\n      for (const childConfig of config.params.types) {\n        const result = VALIDATORS[childConfig.type](\n          childConfig,\n          value,\n          props,\n          propertyPath,\n        );\n\n        if (result.isValid) {\n          return result;\n        }\n      }\n\n      return {\n        isValid: false,\n        parsed: config.params.defaultValue,\n        messages: [\n          {\n            name: \"ValidationError\",\n            message: config.params.defaultErrorMessage || \"\",\n          },\n        ],\n      };\n    } else {\n      return {\n        isValid: false,\n        parsed: undefined,\n        messages: [\n          {\n            name: \"ValidationError\",\n            message: \"Invalid validation configuration\",\n          },\n        ],\n      };\n    }\n  },\n};\n","import {\n  getEntityNameAndPropertyPath,\n  isJSAction,\n} from \"@appsmith/workers/Evaluation/evaluationUtils\";\nimport {\n  EXECUTION_PARAM_REFERENCE_REGEX,\n  THIS_DOT_PARAMS_KEY,\n} from \"constants/AppsmithActionConstants/ActionConstants\";\nimport type { ConfigTree, DataTree } from \"entities/DataTree/dataTreeTypes\";\nimport type DependencyMap from \"entities/DependencyMap\";\nimport type { TJSPropertiesState } from \"workers/Evaluation/JSObject/jsPropertiesState\";\nimport type { DataTreeEntity } from \"entities/DataTree/dataTreeTypes\";\nimport type {\n  DataTreeEntityConfig,\n  DataTreeEntityObject,\n  JSActionEntity,\n} from \"@appsmith/entities/DataTree/types\";\nimport { isObject } from \"lodash\";\nimport type { AffectedJSObjects } from \"sagas/EvaluationsSagaUtils\";\n\nexport function getFixedTimeDifference(endTime: number, startTime: number) {\n  return (endTime - startTime).toFixed(2) + \" ms\";\n}\nexport function isDataField(fullPath: string, configTree: ConfigTree) {\n  const { entityName, propertyPath } = getEntityNameAndPropertyPath(fullPath);\n  const entityConfig = configTree[entityName];\n  if (entityConfig && \"triggerPaths\" in entityConfig) {\n    return !(propertyPath in entityConfig.triggerPaths);\n  }\n  return false;\n}\n\nexport function replaceThisDotParams(code: string) {\n  return code.replace(EXECUTION_PARAM_REFERENCE_REGEX, THIS_DOT_PARAMS_KEY);\n}\n\nexport function getAllAsyncJSFunctions(\n  unevalTree: DataTree,\n  jsPropertiesState: TJSPropertiesState,\n  dependencyMap: DependencyMap,\n  allAsyncNodes: string[],\n) {\n  const allAsyncJSFunctions: string[] = [];\n  for (const [entityName, entity] of Object.entries(unevalTree)) {\n    if (!isJSAction(entity)) continue;\n    const jsEntityState = jsPropertiesState[entityName];\n    if (!jsEntityState) continue;\n    for (const [propertyName, propertyState] of Object.entries(jsEntityState)) {\n      if (!(\"isMarkedAsync\" in propertyState)) continue;\n      if (propertyState.isMarkedAsync) {\n        allAsyncJSFunctions.push(`${entityName}.${propertyName}`);\n        continue;\n      } else {\n        const reacheableAsyncNodes = dependencyMap.getAllReachableNodes(\n          `${entityName}.${propertyName}`,\n          allAsyncNodes,\n        );\n        reacheableAsyncNodes.length &&\n          allAsyncJSFunctions.push(`${entityName}.${propertyName}`);\n      }\n    }\n  }\n  return allAsyncJSFunctions;\n}\n\nexport function isValidEntity(\n  entity: DataTreeEntity,\n): entity is DataTreeEntityObject {\n  if (!isObject(entity)) {\n    return false;\n  }\n  return true;\n}\n\nexport function getValidEntityType(\n  entity: DataTreeEntity,\n  entityConfig: DataTreeEntityConfig,\n) {\n  let entityType;\n  if (isValidEntity(entity)) {\n    entityType =\n      (!!entityConfig && entityConfig.ENTITY_TYPE) || entity.ENTITY_TYPE;\n  }\n  return !!entityType ? entityType : \"noop\";\n}\n\n// in this function we are filtering out only the JSObjects that are affected by the changes\n// through this we limit the number of JSObjects that are diffed\nexport function getOnlyAffectedJSObjects(\n  jsDataTree: Record<string, JSActionEntity>,\n  affectedJSObjects: AffectedJSObjects,\n) {\n  const { ids, isAllAffected } = affectedJSObjects;\n  if (isAllAffected) {\n    return jsDataTree;\n  }\n  if (!ids || ids.length === 0) {\n    return {};\n  }\n  const idsSet = new Set(ids);\n  return Object.keys(jsDataTree).reduce(\n    (acc, key) => {\n      const { actionId } = jsDataTree[key];\n      //only matching action id will be included in the reduced jsDataTree\n      if (idsSet.has(actionId)) {\n        acc[key] = jsDataTree[key];\n      }\n      return acc;\n    },\n    {} as Record<string, JSActionEntity>,\n  );\n}\n","import type { ValidationConfig } from \"constants/PropertyControlConstants\";\nimport { Severity } from \"entities/AppsmithConsole\";\nimport type {\n  WidgetEntity,\n  WidgetEntityConfig,\n} from \"@appsmith/entities/DataTree/types\";\nimport type { ConfigTree } from \"entities/DataTree/dataTreeTypes\";\nimport type { EvaluationError } from \"utils/DynamicBindingUtils\";\nimport {\n  isPathDynamicTrigger,\n  PropertyEvaluationErrorType,\n} from \"utils/DynamicBindingUtils\";\nimport {\n  addErrorToEntityProperty,\n  getEntityNameAndPropertyPath,\n  resetValidationErrorsForEntityProperty,\n} from \"@appsmith/workers/Evaluation/evaluationUtils\";\nimport { validate } from \"workers/Evaluation/validations\";\nimport type { EvalProps } from \".\";\nimport type { ValidationResponse } from \"constants/WidgetValidation\";\n\nexport function validateAndParseWidgetProperty({\n  configTree,\n  evalPropertyValue,\n  evalProps,\n  fullPropertyPath,\n  unEvalPropertyValue,\n  widget,\n}: {\n  fullPropertyPath: string;\n  widget: WidgetEntity;\n  configTree: ConfigTree;\n  evalPropertyValue: unknown;\n  unEvalPropertyValue: string;\n  evalProps: EvalProps;\n}): unknown {\n  const { propertyPath } = getEntityNameAndPropertyPath(fullPropertyPath);\n\n  if (isPathDynamicTrigger(widget, propertyPath)) {\n    // TODO find a way to validate triggers\n    return unEvalPropertyValue;\n  }\n  const widgetConfig = configTree[widget.widgetName] as WidgetEntityConfig;\n  const validation = widgetConfig.validationPaths[propertyPath];\n\n  const { isValid, messages, parsed } = validateWidgetProperty(\n    validation,\n    evalPropertyValue,\n    widget,\n    propertyPath,\n  );\n\n  // remove already present validation errors\n  resetValidationErrorsForEntityProperty({\n    evalProps,\n    fullPropertyPath,\n  });\n\n  if (!isValid) {\n    const evalErrors: EvaluationError[] =\n      messages?.map((message) => {\n        return {\n          raw: unEvalPropertyValue,\n          errorMessage: message || {},\n          errorType: PropertyEvaluationErrorType.VALIDATION,\n          severity: Severity.ERROR,\n        };\n      }) ?? [];\n    // Add validation errors\n    addErrorToEntityProperty({\n      errors: evalErrors,\n      evalProps,\n      fullPropertyPath,\n      configTree,\n    });\n  }\n\n  return parsed;\n}\n\nexport function validateWidgetProperty(\n  config: ValidationConfig,\n  value: unknown,\n  props: Record<string, unknown>,\n  propertyPath: string,\n) {\n  if (!config) {\n    return {\n      isValid: true,\n      parsed: value,\n    };\n  }\n  return validate(config, value, props, propertyPath);\n}\n\nexport function validateActionProperty(\n  config: ValidationConfig,\n  value: unknown,\n): ValidationResponse {\n  if (!config) {\n    return {\n      isValid: true,\n      parsed: value,\n    };\n  }\n  return validate(config, value, {}, \"\");\n}\n"],"names":["EXECUTION_PARAM_KEY","_defineProperty","PluginType","apiActionSettingsConfig","queryActionSettingsConfig","saasActionSettingsConfig","apiActionEditorConfig","apiActionDependencyConfig","apiActionDatasourceFormButtonConfig","DATA_BIND_REGEX","ENTITY_TYPE","_objectSpread","CE_ENTITY_TYPE","MODULE_INPUT","MODULE_INSTANCE","EVAL_WORKER_SYNC_ACTION","EVAL_WORKER_ASYNC_ACTION","MAIN_THREAD_ACTION","Severity","UPDATES","TOASTS","FOCUSES","WIDGETS","setPropertyUpdate","replay","path","value","existingPathValue","_get","length","_set","addToArray","obj","key","Array","isArray","push","getPathsFromDiff","diffs","_step","paths","_iterator","_createForOfIteratorHelper","s","n","done","diff","join","err","e","f","MessageType","sendMessage","message","this","postMessage","PatchType","JSObjectCollection","_classCallCheck","_createClass","resolvedFunctions","entityName","unEvalState","_ref","fullPath","unEvalValue","prevUnEvalState","_ref2","variableValue","fullPropertyPath","_getEntityNameAndProp","getEntityNameAndPropertyPath","propertyPath","newVarState","variableState","clearCachedVariablesForEvaluationContext","JSObjectName","klona","_getEntityNameAndProp2","jsObject","undefined","cachedJSVariablesByEntityName","varState","getVariableState","variables","Object","entries","newJSObject","_loop","_variables$_i","_slicedToArray","_variables","_i","varName","variable","defineProperty","enumerable","configurable","get","TriggerEmitter","BatchKey","concat","method","GET","set","SET","ExecutionMetaData","enableJSVarUpdateTracking","jsPropertiesState","JsPropertiesState","jsObjectName","properties","jsObjectProperty","position","rawContent","type","isJSFunctionProperty","isMarkedAsync","isJSObjectVariable","configTree","entityConfig","entity","isJSAction","includes","isPromise","Boolean","then","DataStore","store","_unset","dataTreeDiff","filter","kind","forEach","deletedPath","deletedPathString","convertPathToString","deleteActionData","DOM_APIS","reduce","acc","UNDEFINED_ACTION_IN_SYNC_EVAL_ERROR","errorModifier","ErrorModifier","asyncFunctionsNameMap","asyncJSFunctionsNames","isViewMode","dataTree","appMode","APP_MODE","dependencyMap","allAsyncEntityFunctions","getAllAsyncFunctions","allAsyncJSFunctions","getAllAsyncJSFunctions","keys","error","metaData","modifiers","source","userScript","result","errorMessage","getErrorMessage","errorCategory","rootcause","_errorModifier2","tree","asynFns","errors","asyncFunc","map","_error$kind","category","PropertyEvaluationErrorCategory","isActionInvokedInDataField","updatedErrors","isDataField","reachableAsyncJSFunctions","getAllReachableNodes","_isEmpty","setAsyncInvocationErrorsRootcause","FoundPromiseInSyncEvalError","_Error","_this","_callSuper","name","_inherits","_wrapNativeSuper","Error","ActionCalledInSyncFieldError","_Error2","actionName","_this2","replaceAll","_possibleConstructorReturn","arguments","getErrorMessageWithType","UNDEFINED_TYPE_ERROR_REGEX","ActionInDataFieldErrorModifier","_Object$keys","asyncFunctionFullPath","functionNameWithWhiteSpace","match","TypeErrorModifier","startsWith","matchedString","undefinedProperty","allMemberExpressionObjects","getMemberExpressionObjectFromProperty","_step2","possibleCauses","Set","_iterator2","objectString","_toPath","topLevelEntity","at","isAction","self","add","possibleCausesArr","from","evalTreeWithChanges","updatedValuePaths","metaUpdates","setupUpdateTreeResponse","dataTreeEvaluator","setterAndLocalStorageUpdatePaths","uniqueOrderUpdatePaths","val","evaluateAndPushResponse","additionalPathsAddedAsUpdates","data","response","evaluateAndGenerateResponse","messageType","body","defaultResponse","updates","dependencies","evalMetaUpdates","evaluationOrder","jsUpdates","logs","unEvalUpdates","isCreateFirstTree","staleMetaIds","removedPaths","isNewWidgetAdded","undefinedEvalValuesMap","jsVarsCreatedEvent","generateOptimisedUpdatesAndSetPrevState","_toConsumableArray","workerResponse","unevalTree","evalOrder","updateResponse","evalAndValidateSubTree","oldConfigTree","makeEntityConfigsAsObjProperties","evalTree","evalProps","JSON","parse","stringify","getOldUnevalTree","additionalUpdates","getNewDataTreeUpdates","affectedNodePaths","allUnevalUpdates","update","payload","getAffectedNodesInTheDataTree","UserLog","isEnabled","emitter","getSource","triggerMeta","_triggerMeta$source","_triggerMeta$source2","_triggerMeta$source3","entityType","triggerPropertyName","id","_this$emitter","parsed","parseLogs","emit","_console","console","debug","info","log","table","warn","_len","args","_key","call","saveLog","_len2","_key2","apply","_len3","_key3","_len4","_key4","_len5","_key5","_len6","_key6","Promise","prototype","toString","replaceFunctionWithNamesFromObjects","uuid4","timestamp","moment","format","output","severity","stack","sanitizeData","setInterval","clearInterval","Map","isAsyncGuard","fn","fnName","$isDataField","getFnWithGuards","fnGuards","guard","positionProps","ReplayEntity","allKeys","actionEntity","actionConfig","actionDependencyMap","dynamicBindingPathList","getEntityDynamicBindingPathList","_i3","_Object$entries2","_Object$entries2$_i","pathDeps","propertyPathDependencies","dependentPath","hasOwnProperty","_step3","_iterator3","dynamicPathDependencies","getDependencyFromEntityPath","existingDeps","newDependencies","_union","getActionDependencies","jsEntity","jsActionConfig","jsActionReactivePaths","reactivePaths","jsActionDependencyMap","_Object$entries","_Object$entries$_i","_i2","reactivePath","reactivePathDependencies","newDeps","getJSDependencies","widgetEntity","widgetConfig","widgetName","widgetInternalDependencies","addWidgetPropertyDependencies","_dependencies$fullPro","targetPaths","p","dynamicTriggerPathList","getWidgetDependencies","_actionInternalDepend","actionPathDependencies","_getEntityNameAndProp3","actionInternalDependencyMap","actionPathInternalDependencies","dep","bindingPaths","_find","getActionPropertyPathDependencies","_jsInternalDependency","_jsInternalDependency2","jsInternalDependencyMap","jsPathInternalDependencies","getJSPropertyPathDependencies","widgetPathInternalDependencies","isATriggerPath","getWidgetPropertyPathDependencies","unevalPropValue","getDynamicBindings","jsSnippets","jsSnippet","DependencyMapUtils","dependencyTree","rawDependencies","_step$value","node","deps","size","success","sortedDependencies","toposort","reverse","edge","cyclicNodes","RegExp","cyclicNode","_step2$value","makeParentsDependOnChild","child","matches","curKey","IMMEDIATE_PARENT_REGEX","immediateParent","existingImmediateParentDeps","getDirectDependencies","has","addDependency","canvasWidgetsMeta","metaWidgetsCache","canvasWidgets","handleActionsDataUpdate","actionsToUpdate","actionToUpdate","dataPath","dataPathRef","updatedProperties","updatePaths","sort","a","b","segmentedPath","split","rhs","findDuplicateIndex","arr","_uniqSet","currSetSize","i","countOccurrences","string","subString","allowOverlapping","maxLimit","pos","step","indexOf","stringifyFnsInObject","userObject","parseFunctionsInObject","fnStrings","_paths","fnValue","index","parsedFnString","constructPath","existingPath","suffix","arrayValue","_keys","isLargeCollection","rowSize","_isObject","getReducedDataTree","constrainedDiffPaths","withErrors","_widgetValue$__evalua","widgetValue","__evaluation__","generateOptimisedUpdates","oldDataTree","attachDirectly","oldData","newData","lhs","isMoment","isLhsLarge","isRhsLarge","equal","largeDataSetUpdates","generateDiffUpdates","correctedUpdates","correctUndefinedUpdatesToDeletesOrNew","rootCollectionUpdates","newDataTree","v","pathCopy","pop","generateRootWidgetUpdates","scrubedOutUpdates","rootCollectionPaths","_update$path","condensedPath","_ref3","some","_ref4","getScrubbedOutUpdatesWhenRootCollectionIsUpdated","mergeAdditionalUpdates","_generateSerialisedUp","prevState","currentState","removedLhs","_ref5","_objectWithoutProperties","_excluded","serialisedUpdates","serialiseToBigInt","EvalErrorTypes","generateSerialisedUpdates","getPrevState","setPrevState","_VALIDATORS","MAX_ALLOWED_LINE_BREAKS","LINE_BREAKS_ERROR_MESSAGE","flat","array","uniqueParam","children","validatePlainObject","config","props","_config$params","params","allowedKeys","_config$params2","_valid","_messages","entry","_entry$params","_entry$params2","_entry$params3","ignoreCase","entryName","getOwnPropertyNames","find","toLowerCase","getPropertyEntry","_validate","validate","isValid","messages","required","requiredKey","default","validateArray","_config$params3","_config$params4","_config$params4$child","_config$params4$child2","_config$params5","_config$params5$child","_config$params6","_config$params7","_config$params8","_config$params9","_config$params12","_isValid","allowedValues","uniqueKeys","allowedKeyConfigs","ValidationTypes","_compact","allowedKeyConfig","_allowedKeyConfig$par","unique","_config$params11","childrenValidationConfig","shouldVerifyAllowedValues","shouldValidateChildren","shouldArrayHaveUniqueEntries","shouldArrayValuesHaveUniqueValuesForKeys","_config$params10","duplicateIndex","_uniqWith","every","_childValidationResul","childValidationResult","validateExcessLineBreaks","str","validateObjectValues","substring","_isArray","item","validateFn","VALIDATORS","staticValue","WIDGET_TYPE_VALIDATION_ERROR","getExpectedType","_config$params13","_config$params13$expe","_config$params14","_config$params15","_config$params17","_config$params17$expe","_config$params18","_config$params19","_config$params21","_config$params23","_config$params24","_config$params26","_config$params28","expected","_config$params16","allowed","regex","_config$params20","_config$params22","validationType","min","max","_config$params25","objectType","_expected","_config$params27","_config$params31","_config$params33","_config$params36","_config$params37","_config$params38","_config$params30","_config$params29","limitLineBreaks","_config$params34","_config$params35","_parsed","text","maxLength","_config$params39","_isString","stringValidationError","_config$params32","strict","_toString","trim","_isRegExp","test","_VALIDATORS$Validatio","_config$params45","_config$params46","_config$params47","_config$params40","_config$params41","_config$params42","_config$params43","Number","isFinite","_parsed2","_config$params44","passThroughOnZero","natural","isInteger","_config$params50","_config$params48","_config$params49","_config$params51","isABoolean","isStringTrueFalse","strictCheck","_config$params53","_config$params52","_isPlainObject","_config$params54","_config$params55","_config$params56","_config$params57","_config$params58","invalidResponse","_value","_config$params59","_config$params60","_config$params61","_config$params62","_config$params63","parsedEntry","_config$params64","_config$params65","_config$params66","ARRAY","_config$params67","param","flattenedArray","shouldBeUnique","_uniq","_config$params68","_config$params69","_isNil","toISOString","_config$params70","_config$params71","_config$params72","fnString","_config$params73","fnBody","Function","_","_config$params74","btoa","atob","_config$params75","getIsSafeURL","_config$params76","_config$params77","_config$params77$para","resultValue","_VALIDATORS$Validatio2","_config$params78","_config$params79","types","_step4","_iterator4","childConfig","defaultValue","defaultErrorMessage","triggerPaths","allAsyncNodes","jsEntityState","propertyName","propertyState","validateAndParseWidgetProperty","evalPropertyValue","unEvalPropertyValue","widget","isPathDynamicTrigger","_validateWidgetProper","validateWidgetProperty","validationPaths","resetValidationErrorsForEntityProperty","_messages$map","evalErrors","raw","errorType","PropertyEvaluationErrorType","addErrorToEntityProperty"],"sourceRoot":""}