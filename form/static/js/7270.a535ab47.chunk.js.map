{"version":3,"file":"static/js/7270.a535ab47.chunk.js","mappings":"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","sources":["globalStyles/WidgetGlobalStyles.ts","pages/AppViewer/AppPage.styled.tsx","pages/Editor/RequestConfirmationModal.tsx","selectors/mainCanvasSelectors.tsx","utils/hooks/useDynamicAppLayout.tsx","utils/hooks/useWidgetFocus/tabbable.ts","utils/hooks/useWidgetFocus/handleTab.ts","utils/hooks/useWidgetFocus/useWidgetFocus.tsx"],"sourcesContent":["import { createGlobalStyle } from \"styled-components\";\n\nexport const WidgetGlobaStyles = createGlobalStyle<{\n  primaryColor?: string;\n  fontFamily?: string;\n}>`\n    :root{\n      --wds-accent-color: ${({ primaryColor }) => primaryColor};\n      --wds-font-family: ${({ fontFamily }) =>\n        fontFamily === \"System Default\" ? \"inherit\" : fontFamily};\n    }\n  `;\n","import styled from \"styled-components\";\n\n/**\n * OldName: PageViewContainer\n */\nexport const PageViewWrapper = styled.div<{\n  hasPinnedSidebar: boolean;\n  sidebarWidth: number;\n  isPreview?: boolean;\n  isPublished: boolean;\n}>`\n  ${({ isPublished }) => (isPublished ? \"\" : \"width: inherit;\")};\n  ${({ hasPinnedSidebar, isPreview, sidebarWidth }) =>\n    (hasPinnedSidebar && !isPreview && `margin-left: ${sidebarWidth}px;`) ||\n    (hasPinnedSidebar &&\n      isPreview &&\n      `padding-left: ${sidebarWidth}px; margin: 0 auto;`) ||\n    \"margin: 0 auto;\"}\n`;\n\nexport const PageView = styled.div<{ width: string }>`\n  height: 100%;\n  position: relative;\n  width: ${(props) => props.width};\n  margin: 0 auto;\n`;\n","import React from \"react\";\nimport { connect } from \"react-redux\";\nimport type { AppState } from \"@appsmith/reducers\";\nimport { Keys } from \"@blueprintjs/core\";\nimport {\n  showActionConfirmationModal,\n  cancelActionConfirmationModal,\n  acceptActionConfirmationModal,\n} from \"actions/pluginActionActions\";\nimport {\n  Button,\n  Modal,\n  ModalBody,\n  ModalContent,\n  ModalFooter,\n  ModalHeader,\n} from \"design-system\";\nimport {\n  createMessage,\n  QUERY_CONFIRMATION_MODAL_MESSAGE,\n} from \"@appsmith/constants/messages\";\nimport type { ModalInfo } from \"reducers/uiReducers/modalActionReducer\";\n\ninterface Props {\n  modals: ModalInfo[];\n  dispatch: any;\n}\n\nclass RequestConfirmationModal extends React.Component<Props> {\n  addEventListener = () => {\n    document.addEventListener(\"keydown\", this.onKeyUp);\n  };\n\n  removeEventListener = () => {\n    document.removeEventListener(\"keydown\", this.onKeyUp);\n  };\n\n  onKeyUp = (event: KeyboardEvent) => {\n    // Sometimes calling the shortcut keys \"Cmd + Enter\" also triggers the onConfirm function below\n    // so We check if no multiple keys are being pressed currently before executing this block of code.\n    if (!(event.metaKey || event.ctrlKey) && event.keyCode === Keys.ENTER) {\n      // please note: due to the way the state is being updated, the last action will always correspond to the right Action Modal.\n      // this is not a bug.\n      this.onConfirm(this.props.modals[this.props.modals.length - 1]);\n    }\n  };\n\n  onConfirm = (modalInfo: ModalInfo) => {\n    const { dispatch } = this.props;\n    dispatch(acceptActionConfirmationModal(modalInfo.name));\n    this.handleClose(modalInfo);\n  };\n\n  handleClose = (modalInfo: ModalInfo) => {\n    const { dispatch } = this.props;\n    dispatch(showActionConfirmationModal({ ...modalInfo, modalOpen: false }));\n    dispatch(cancelActionConfirmationModal(modalInfo.name));\n  };\n\n  componentDidUpdate() {\n    const { modals } = this.props;\n    if (!!modals) {\n      this.addEventListener();\n    } else {\n      this.removeEventListener();\n    }\n  }\n\n  render() {\n    const { dispatch, modals } = this.props;\n\n    // making sure that only modals that are set to be open are eventually opened.\n    // basically filters out modals that have already been opened and prevents it from flashing after other modals have been confirmed.\n    const modalsToBeOpened = modals.filter((modal) => modal.modalOpen);\n\n    return (\n      <>\n        {modalsToBeOpened.map((modalInfo: ModalInfo) => (\n          <Modal\n            key={modalInfo.name}\n            onOpenChange={() => this.handleClose(modalInfo)}\n            open={modalInfo?.modalOpen}\n          >\n            <ModalContent\n              data-testid=\"t--query-run-confirmation-modal\"\n              style={{ width: \"600px\" }}\n            >\n              <ModalHeader>Confirmation dialog</ModalHeader>\n              <ModalBody>\n                {createMessage(QUERY_CONFIRMATION_MODAL_MESSAGE)}{\" \"}\n                <b>{modalInfo.name}</b> ?\n              </ModalBody>\n              <ModalFooter>\n                <Button\n                  kind=\"secondary\"\n                  onClick={() => {\n                    dispatch(cancelActionConfirmationModal(modalInfo.name));\n                    this.handleClose(modalInfo);\n                  }}\n                  size=\"md\"\n                >\n                  No\n                </Button>\n                <Button\n                  kind=\"primary\"\n                  onClick={() => this.onConfirm(modalInfo)}\n                  size=\"md\"\n                >\n                  Yes\n                </Button>\n              </ModalFooter>\n            </ModalContent>\n          </Modal>\n        ))}\n      </>\n    );\n  }\n}\n\nconst mapStateToProps = (state: AppState) => ({\n  modals: state.ui.modalAction.modals,\n});\n\nexport default connect(mapStateToProps)(RequestConfirmationModal);\n","import type { AppState } from \"@appsmith/reducers\";\n\nexport const getIsCanvasInitialized = (state: AppState) => {\n  return state.ui.mainCanvas.initialized;\n};\n","import { debounce, get } from \"lodash\";\nimport { useCallback, useEffect, useMemo, useState } from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\n\nimport { updateLayoutForMobileBreakpointAction } from \"actions/autoLayoutActions\";\nimport { updateCanvasLayoutAction } from \"actions/editorActions\";\nimport { APP_SIDEBAR_WIDTH } from \"constants/AppConstants\";\nimport {\n  DefaultLayoutType,\n  layoutConfigurations,\n  MAIN_CONTAINER_WIDGET_ID,\n} from \"constants/WidgetConstants\";\nimport { APP_MODE } from \"entities/App\";\nimport { LayoutSystemTypes } from \"layoutSystems/types\";\nimport {\n  combinedPreviewModeSelector,\n  getCurrentApplicationLayout,\n  getCurrentPageId,\n  getMainCanvasProps,\n} from \"selectors/editorSelectors\";\nimport { getAppMode } from \"@appsmith/selectors/entitiesSelector\";\nimport { getExplorerWidth } from \"selectors/explorerSelector\";\nimport { getIsCanvasInitialized } from \"selectors/mainCanvasSelectors\";\nimport { getIsAppSettingsPaneWithNavigationTabOpen } from \"selectors/appSettingsPaneSelectors\";\nimport {\n  getAppSidebarPinned,\n  getCurrentApplication,\n  getSidebarWidth,\n} from \"@appsmith/selectors/applicationSelectors\";\nimport { useIsMobileDevice } from \"./useDeviceDetect\";\nimport { getPropertyPaneWidth } from \"selectors/propertyPaneSelectors\";\nimport { scrollbarWidth } from \"utils/helpers\";\nimport { useWindowSizeHooks } from \"./dragResizeHooks\";\nimport type { AppState } from \"@appsmith/reducers\";\nimport { ReduxActionTypes } from \"@appsmith/constants/ReduxActionConstants\";\nimport { useLocation } from \"react-router\";\nimport { CANVAS_VIEWPORT } from \"constants/componentClassNameConstants\";\nimport { getLayoutSystemType } from \"selectors/layoutSystemSelectors\";\n\nconst GUTTER_WIDTH = 72;\nexport const AUTOLAYOUT_RESIZER_WIDTH_BUFFER = 40;\n\nexport const useDynamicAppLayout = () => {\n  const dispatch = useDispatch();\n  const explorerWidth = useSelector(getExplorerWidth);\n  const propertyPaneWidth = useSelector(getPropertyPaneWidth);\n  const appMode: APP_MODE | undefined = useSelector(getAppMode);\n  const { width: screenWidth } = useWindowSizeHooks();\n  const mainCanvasProps = useSelector(getMainCanvasProps);\n  const isPreviewMode = useSelector(combinedPreviewModeSelector);\n  const currentPageId = useSelector(getCurrentPageId);\n  const isCanvasInitialized = useSelector(getIsCanvasInitialized);\n  const appLayout = useSelector(getCurrentApplicationLayout);\n  const layoutSystemType = useSelector(getLayoutSystemType);\n  const isAppSidebarPinned = useSelector(getAppSidebarPinned);\n  const sidebarWidth = useSelector(getSidebarWidth);\n  const isAppSettingsPaneWithNavigationTabOpen = useSelector(\n    getIsAppSettingsPaneWithNavigationTabOpen,\n  );\n  const currentApplicationDetails = useSelector(getCurrentApplication);\n  const isMobile = useIsMobileDevice();\n  const isAutoCanvasResizing = useSelector(\n    (state: AppState) => state.ui.widgetDragResize.isAutoCanvasResizing,\n  );\n  const [isCanvasResizing, setIsCanvasResizing] = useState<boolean>(false);\n  const { search } = useLocation();\n  const queryParams = new URLSearchParams(search);\n  const isEmbed = queryParams.get(\"embed\");\n  const isNavbarVisibleInEmbeddedApp = queryParams.get(\"navbar\");\n\n  const isPreviewing = isPreviewMode;\n\n  // /**\n  //  * calculates min height\n  //  */\n  // const calculatedMinHeight = useMemo(() => {\n  //   return calculateDynamicHeight();\n  // }, [mainCanvasProps]);\n\n  /**\n   * app layout range i.e minWidth and maxWidth for the current layout\n   * if there is no config for the current layout, use default layout i.e desktop\n   */\n  const layoutWidthRange = useMemo(() => {\n    let minWidth = -1;\n    let maxWidth = -1;\n\n    if (appLayout) {\n      const { type } = appLayout;\n      const currentLayoutConfig = get(\n        layoutConfigurations,\n        type,\n        layoutConfigurations[DefaultLayoutType],\n      );\n\n      if (currentLayoutConfig.minWidth) minWidth = currentLayoutConfig.minWidth;\n      if (currentLayoutConfig.maxWidth) maxWidth = currentLayoutConfig.maxWidth;\n    }\n\n    return { minWidth, maxWidth };\n  }, [appLayout]);\n\n  /**\n   * calculate the width for the canvas\n   *\n   * cases:\n   *  - if max width is negative, use calculated width\n   *  - if calculated width is in range of min/max widths of layout, use calculated width\n   *  - if calculated width is less then min width, use min Width\n   *  - if calculated width is larger than max width, use max width\n   *  - by default use min width\n   *\n   * @returns\n   */\n  const calculateCanvasWidth = () => {\n    let { maxWidth } = layoutWidthRange;\n    const { minWidth } = layoutWidthRange;\n    let calculatedWidth = screenWidth - scrollbarWidth();\n\n    const gutterWidth =\n      layoutSystemType === LayoutSystemTypes.AUTO ? 0 : GUTTER_WIDTH;\n\n    // if preview mode is not on and the app setting pane is not opened, we need to subtract the width of the property pane\n    if (!isPreviewing && appMode === APP_MODE.EDIT) {\n      calculatedWidth -= propertyPaneWidth;\n    }\n\n    // if explorer is closed or its preview mode, we don't need to subtract the EE width\n    if (!isPreviewing && appMode === APP_MODE.EDIT) {\n      calculatedWidth -= explorerWidth;\n    }\n\n    if (appMode === APP_MODE.EDIT) {\n      calculatedWidth -= APP_SIDEBAR_WIDTH;\n    }\n\n    /**\n     * If there is\n     * 1. a sidebar for navigation,\n     * 2. it is pinned,\n     * 3. device is not mobile\n     * 4. and it is not an embedded app\n     * we need to subtract the sidebar width as well in the following modes -\n     * 1. Preview\n     * 2. App settings open with navigation tab\n     * 3. Published\n     */\n    const isEmbeddedAppWithNavVisible = isEmbed && isNavbarVisibleInEmbeddedApp;\n    if (\n      (appMode === APP_MODE.PUBLISHED ||\n        isPreviewing ||\n        isAppSettingsPaneWithNavigationTabOpen) &&\n      !isMobile &&\n      (!isEmbed || isEmbeddedAppWithNavVisible) &&\n      sidebarWidth\n    ) {\n      calculatedWidth -= sidebarWidth;\n    }\n    if (isMobile) {\n      maxWidth += sidebarWidth;\n    }\n    const ele: any = document.getElementById(CANVAS_VIEWPORT);\n    if (\n      appMode === APP_MODE.EDIT &&\n      appLayout?.type === \"FLUID\" &&\n      ele &&\n      calculatedWidth > ele.clientWidth\n    ) {\n      calculatedWidth = ele.clientWidth;\n    }\n\n    switch (true) {\n      case maxWidth < 0:\n      case appLayout?.type === \"FLUID\":\n      case calculatedWidth < maxWidth && calculatedWidth > minWidth:\n        const totalWidthToSubtract = gutterWidth;\n        // NOTE: gutter + border width will be only substracted when theme mode and preview mode are off\n        return (\n          calculatedWidth -\n          (appMode === APP_MODE.EDIT &&\n          !isPreviewing &&\n          !isAppSettingsPaneWithNavigationTabOpen\n            ? totalWidthToSubtract\n            : 0)\n        );\n      case calculatedWidth < minWidth:\n        return minWidth;\n      case calculatedWidth > maxWidth:\n        return maxWidth;\n      default:\n        return minWidth;\n    }\n  };\n\n  /**\n   * resizes the layout based on the layout type\n   *\n   * @param screenWidth\n   * @param appLayout\n   */\n  const resizeToLayout = () => {\n    const calculatedWidth = calculateCanvasWidth();\n    const { width: rightColumn } = mainCanvasProps || {};\n    if (rightColumn !== calculatedWidth || !isCanvasInitialized) {\n      dispatch(updateCanvasLayoutAction(calculatedWidth));\n    }\n    return calculatedWidth;\n  };\n\n  const debouncedResize = useCallback(debounce(resizeToLayout, 250), [\n    mainCanvasProps,\n    screenWidth,\n  ]);\n\n  const immediateDebouncedResize = useCallback(debounce(resizeToLayout), [\n    mainCanvasProps,\n    screenWidth,\n    currentPageId,\n    appMode,\n    appLayout,\n    isPreviewing,\n  ]);\n\n  const resizeObserver = new ResizeObserver(immediateDebouncedResize);\n  useEffect(() => {\n    const ele: any = document.getElementById(CANVAS_VIEWPORT);\n    if (ele) {\n      if (appLayout?.type === \"FLUID\") {\n        resizeObserver.observe(ele);\n      } else {\n        resizeObserver.unobserve(ele);\n      }\n    }\n    return () => {\n      ele && resizeObserver.unobserve(ele);\n    };\n  }, [appLayout, currentPageId, isPreviewing]);\n\n  /**\n   * when screen height is changed, update canvas layout\n   */\n  // useEffect(() => {\n  //   if (calculatedMinHeight !== mainCanvasProps?.height) {\n  //     // dispatch(updateCanvasLayoutAction(mainCanvasProps?.width));\n  //   }\n  // }, [screenHeight, mainCanvasProps?.height]);\n\n  useEffect(() => {\n    if (isCanvasInitialized) debouncedResize();\n  }, [screenWidth]);\n\n  /**\n   * resize the layout if any of the following thing changes:\n   *  - app layout\n   *  - page\n   *  - container right column\n   *  - preview mode\n   *  - explorer width\n   *  - explorer is pinned\n   *  - theme mode is turned on\n   *  - sidebar pin/unpin\n   *  - app settings pane open with navigation tab\n   *  - any of the following navigation settings changes\n   *    - orientation\n   *    - nav style\n   *  - device changes to/from mobile\n   */\n  useEffect(() => {\n    resizeToLayout();\n  }, [\n    appLayout,\n    mainCanvasProps?.width,\n    isPreviewing,\n    isAppSettingsPaneWithNavigationTabOpen,\n    explorerWidth,\n    sidebarWidth,\n    propertyPaneWidth,\n    propertyPaneWidth,\n    isAppSidebarPinned,\n    currentApplicationDetails?.applicationDetail?.navigationSetting\n      ?.orientation,\n    currentApplicationDetails?.applicationDetail?.navigationSetting?.navStyle,\n    isMobile,\n    currentPageId, //TODO: preet - remove this after first merge.\n  ]);\n\n  useEffect(() => {\n    dispatch(\n      updateLayoutForMobileBreakpointAction(\n        MAIN_CONTAINER_WIDGET_ID,\n        layoutSystemType === LayoutSystemTypes.AUTO\n          ? mainCanvasProps?.isMobile\n          : false,\n        calculateCanvasWidth(),\n      ),\n    );\n  }, [mainCanvasProps?.isMobile]);\n\n  useEffect(() => {\n    if (isAutoCanvasResizing) setIsCanvasResizing(true);\n    else if (isCanvasResizing) {\n      setIsCanvasResizing(false);\n      const canvasWidth: number = resizeToLayout();\n      dispatch(\n        updateLayoutForMobileBreakpointAction(\n          MAIN_CONTAINER_WIDGET_ID,\n          layoutSystemType === LayoutSystemTypes.AUTO\n            ? mainCanvasProps?.isMobile\n            : false,\n          canvasWidth,\n        ),\n      );\n      dispatch({\n        type: ReduxActionTypes.PROCESS_AUTO_LAYOUT_DIMENSION_UPDATES,\n      });\n    }\n  }, [isAutoCanvasResizing]);\n\n  return isCanvasInitialized;\n};\n","export const CANVAS_WIDGET = '[type=\"CANVAS_WIDGET\"]';\n// NOTE: This is a hack to exclude the current canvas from the query selector\n// because when we use.closest, it returns the current element too\nexport const CANVAS_WIDGET_EXCLUDING_SCOPE =\n  '[type=\"CANVAS_WIDGET\"]:not(:scope)';\nexport const CONTAINER_SELECTOR =\n  \":is(.t--widget-containerwidget, .t--widget-formwidget)\";\nconst NON_FOCUSABLE_WIDGET_CLASS =\n  \".t--widget-textwidget, .t--widget-ratewidget, [disabled], [data-hidden]\";\nexport const JSONFORM_WIDGET = \".t--widget-jsonformwidget\";\nexport const MODAL_WIDGET = \".t--modal-widget\";\nexport const CHECKBOXGROUP_WIDGET = \".t--widget-checkboxgroupwidget\";\nexport const SWITCHGROUP_WIDGET = \".t--widget-switchgroupwidget\";\nexport const BUTTONGROUP_WIDGET = \".t--widget-buttongroupwidget\";\nexport const FOCUS_SELECTOR =\n  \":is(a, input, select, textarea, button, object, audio, video, [tabindex='-1']):not([data-tabbable='false'])\";\nexport const WIDGET_SELECTOR = `.positioned-widget:is(:not(${NON_FOCUSABLE_WIDGET_CLASS}))`;\n\n/**\n * returns the tabbable descendants of the current node\n *\n * @param currentNode\n * @param shiftKey\n * @returns\n */\nexport function getTabbableDescendants(\n  currentNode: HTMLElement,\n  shiftKey = false,\n): HTMLElement[] {\n  const activeWidget = currentNode.closest(WIDGET_SELECTOR) as HTMLElement;\n\n  if (!activeWidget) {\n    const modal = currentNode.closest(MODAL_WIDGET) as HTMLElement;\n\n    // if we are in modal, we have to trap the focus within the modal\n    if (modal) {\n      const tabbableDescendants = Array.from(\n        modal.querySelectorAll(WIDGET_SELECTOR),\n      ) as HTMLElement[];\n\n      const domRect = modal.getBoundingClientRect();\n\n      const sortedTabbableDescendants = sortWidgetsByPosition(\n        {\n          top: shiftKey ? domRect.bottom : domRect.top,\n          left: shiftKey ? domRect.right : domRect.left,\n        },\n        tabbableDescendants,\n        shiftKey,\n      );\n\n      return sortedTabbableDescendants;\n    }\n\n    // this case means the focus on the main container canvas\n    if (currentNode.matches(CANVAS_WIDGET)) {\n      const tabbableDescendants = Array.from(\n        currentNode.querySelectorAll(WIDGET_SELECTOR),\n      ) as HTMLElement[];\n\n      const domRect = currentNode.getBoundingClientRect();\n\n      const sortedTabbableDescendants = sortWidgetsByPosition(\n        {\n          top: shiftKey ? domRect.bottom : domRect.top,\n          left: shiftKey ? domRect.right : domRect.left,\n        },\n        tabbableDescendants,\n        shiftKey,\n      );\n\n      return sortedTabbableDescendants;\n    }\n  }\n\n  const siblings = getWidgetSiblingsOfNode(activeWidget);\n  const domRect = activeWidget.getBoundingClientRect();\n\n  const sortedSiblings = sortWidgetsByPosition(\n    {\n      top: domRect.top,\n      left: domRect.left,\n    },\n    siblings,\n    shiftKey,\n  );\n\n  if (sortedSiblings.length) return sortedSiblings;\n\n  // there are no siblings, which means we are at the end of the tabbable list\n  // we have to go to next sibling widget of current canvas\n  const currentCanvas = currentNode.closest(\n    CANVAS_WIDGET_EXCLUDING_SCOPE,\n  ) as HTMLElement;\n\n  if (currentCanvas) {\n    return getTabbableDescendants(currentCanvas, shiftKey);\n  }\n\n  return [];\n}\n\n/**\n * returns the next tabbable descendant from the list of descendants\n * sorted by position and distance\n * if the next tabbable descendant is JSONFORM, it returns the first tabbable\n *\n * @param descendants\n * @param shiftKey\n * @returns\n */\nexport function getNextTabbableDescendant(\n  descendants: HTMLElement[],\n  shiftKey = false,\n) {\n  const nextTabbableDescendant = descendants[0];\n\n  if (!nextTabbableDescendant) return;\n\n  // if nextTabbableDescendant is a container,\n  if (nextTabbableDescendant.matches(CONTAINER_SELECTOR)) {\n    const tabbableDescendants = getChildrenWidgetsOfNode(\n      nextTabbableDescendant,\n    );\n\n    const { bottom, left, right, top } =\n      nextTabbableDescendant.getBoundingClientRect();\n\n    const sortedTabbableDescendants = sortWidgetsByPosition(\n      {\n        top: shiftKey ? bottom : top,\n        left: shiftKey ? right : left,\n      },\n      tabbableDescendants,\n      shiftKey,\n    );\n\n    return sortedTabbableDescendants[0];\n  }\n\n  // if nextTabbableDescendant is a jsonform widget\n  if (\n    nextTabbableDescendant.matches(JSONFORM_WIDGET) ||\n    nextTabbableDescendant.matches(CHECKBOXGROUP_WIDGET) ||\n    nextTabbableDescendant.matches(SWITCHGROUP_WIDGET) ||\n    nextTabbableDescendant.matches(BUTTONGROUP_WIDGET)\n  ) {\n    const tabbable = Array.from(\n      nextTabbableDescendant.querySelectorAll<HTMLElement>(FOCUS_SELECTOR),\n    );\n\n    return shiftKey ? tabbable[tabbable.length - 1] : tabbable[0];\n  }\n\n  return nextTabbableDescendant;\n}\n\n/**\n * returns a focussable element within a widget\n *\n * @param node\n * @returns\n */\nexport function getFocussableElementOfWidget(node: HTMLElement) {\n  if (node.matches(FOCUS_SELECTOR)) {\n    return node;\n  }\n\n  return node.querySelector(FOCUS_SELECTOR) as HTMLElement;\n}\n/**\n *  get widgets of a given node\n *\n * @param node\n * @returns\n */\nexport function getChildrenWidgetsOfNode(node: HTMLElement) {\n  const widgets = Array.from(\n    node.querySelectorAll(WIDGET_SELECTOR),\n  ) as HTMLElement[];\n\n  return widgets;\n}\n\n/**\n * get the siblings of the current node's widget\n *\n * @param node\n * @returns\n */\nfunction getWidgetSiblingsOfNode(node: HTMLElement) {\n  const canvas = node.closest(CANVAS_WIDGET_EXCLUDING_SCOPE) as HTMLElement;\n\n  if (!canvas) return [];\n\n  const widget = node.closest(WIDGET_SELECTOR) as HTMLElement;\n  const siblings = Array.from(\n    canvas.querySelectorAll(`:scope > ${WIDGET_SELECTOR}`),\n  ) as HTMLElement[];\n\n  return siblings.filter((sibling) => sibling !== widget);\n}\n\n/**\n * sorts the descendants by their position in the DOM\n *\n * @param currentElement\n * @param tabbableDescendants\n * @param shiftKey\n * @returns\n */\nexport function sortWidgetsByPosition(\n  boundingClientRect: {\n    top: number;\n    left: number;\n  },\n  tabbableDescendants: HTMLElement[],\n  shiftKey = false,\n) {\n  const { left, top } = boundingClientRect;\n  const isTabbingForward = !shiftKey;\n  const isTabbingBackward = shiftKey;\n\n  let tabbableElementsByPosition = Array.from(tabbableDescendants).map(\n    (element) => {\n      const { left: elementLeft, top: elementTop } =\n        element.getBoundingClientRect();\n      const topDiff = elementTop - top;\n      const leftDiff = elementLeft - left;\n\n      return {\n        element,\n        topDiff,\n        leftDiff,\n        top,\n        left,\n        elementTop,\n        elementLeft,\n      };\n    },\n  );\n\n  tabbableElementsByPosition = tabbableElementsByPosition.filter((element) => {\n    // if tabbing forward, only consider elements below and to the right\n    if (isTabbingForward) {\n      if (element.topDiff === 0) {\n        return element.leftDiff > 0;\n      }\n\n      return element.topDiff > 0;\n    }\n\n    // if tabbing backward, only consider elements above and to the left\n    if (isTabbingBackward) {\n      if (element.topDiff === 0) {\n        return element.leftDiff < 0;\n      }\n\n      return element.topDiff < 0;\n    }\n  });\n\n  tabbableElementsByPosition = tabbableElementsByPosition.sort((a, b) => {\n    if (isTabbingForward) {\n      return a.topDiff - b.topDiff || a.leftDiff - b.leftDiff;\n    }\n\n    if (isTabbingBackward) {\n      return b.topDiff - a.topDiff || b.leftDiff - a.leftDiff;\n    }\n\n    return 0;\n  });\n\n  return tabbableElementsByPosition.map((element) => element.element);\n}\n\n/**\n * get next item to focus if the current widget has relative positioned children\n *\n * Note:\n * if the user is tabbing out, we need to get the next tabbable descendant of the current widget\n * else tabbing will work as expected as widgets inside the widget are regular components\n * and will be handled by the default tabbing logic\n *\n *\n * @param currentWidget\n * @param shiftKey\n * @returns\n */\nexport function getNextTabbableDescendantForRegularWidgets(\n  currentWidget: HTMLElement,\n  shiftKey: boolean,\n) {\n  let nextTabbableDescendant;\n\n  const tabbable = Array.from(\n    currentWidget.querySelectorAll<HTMLElement>(FOCUS_SELECTOR),\n  );\n\n  const currentIndex = tabbable.indexOf(document.activeElement as HTMLElement);\n  const isTabbingOutOfJSONForm = shiftKey\n    ? currentIndex === 0\n    : currentIndex === tabbable.length - 1;\n\n  if (isTabbingOutOfJSONForm) {\n    const descendents = getTabbableDescendants(currentWidget, shiftKey);\n    nextTabbableDescendant = getNextTabbableDescendant(descendents, shiftKey);\n  }\n\n  return nextTabbableDescendant;\n}\n","import {\n  getTabbableDescendants,\n  getNextTabbableDescendant,\n  getFocussableElementOfWidget,\n  JSONFORM_WIDGET,\n  WIDGET_SELECTOR,\n  getNextTabbableDescendantForRegularWidgets,\n  CHECKBOXGROUP_WIDGET,\n  SWITCHGROUP_WIDGET,\n  BUTTONGROUP_WIDGET,\n} from \"./tabbable\";\n\nexport function handleTab(event: KeyboardEvent) {\n  let nextTabbableDescendant;\n  const shiftKey = event.shiftKey;\n  const currentNode = event.target as HTMLElement;\n  const currentWidget = currentNode.closest(WIDGET_SELECTOR) as HTMLElement;\n\n  switch (true) {\n    // when the current node is one of these widget, we want to do tabbing in regular way\n    // the elements will be in proper order in dom for thes widgets\n    case currentWidget && currentWidget.matches(JSONFORM_WIDGET):\n    case currentWidget && currentWidget.matches(CHECKBOXGROUP_WIDGET):\n    case currentWidget && currentWidget.matches(SWITCHGROUP_WIDGET):\n    case currentWidget && currentWidget.matches(BUTTONGROUP_WIDGET):\n      nextTabbableDescendant = getNextTabbableDescendantForRegularWidgets(\n        currentWidget,\n        shiftKey,\n      );\n      break;\n    default:\n      const tabbable = getTabbableDescendants(currentNode, shiftKey);\n\n      let isNextWidgetElementFocusable = false;\n      do {\n        nextTabbableDescendant = getNextTabbableDescendant(tabbable, shiftKey);\n        if (nextTabbableDescendant) {\n          isNextWidgetElementFocusable = !!getFocussableElementOfWidget(\n            nextTabbableDescendant,\n          );\n        }\n        tabbable.shift();\n      } while (!isNextWidgetElementFocusable && tabbable.length > 0);\n  }\n\n  // if nextTabbableDescendant is found, focus\n  if (nextTabbableDescendant) {\n    event.preventDefault();\n\n    const focusableElement = getFocussableElementOfWidget(\n      nextTabbableDescendant,\n    );\n\n    if (focusableElement) {\n      focusableElement.focus();\n    }\n  }\n}\n","import { useSelector } from \"react-redux\";\nimport { useCallback, useEffect, useRef } from \"react\";\n\nimport { handleTab } from \"./handleTab\";\nimport { CANVAS_WIDGET } from \"./tabbable\";\nimport { getIsAutoLayout } from \"selectors/canvasSelectors\";\n\nfunction useWidgetFocus(): (instance: HTMLElement | null) => void {\n  const ref = useRef<HTMLElement | null>();\n  const isAutoLayout = useSelector(getIsAutoLayout);\n\n  // This is a callback that will be called when the ref is set\n  const setRef = useCallback((node: HTMLElement | null) => {\n    if (node === null) return;\n\n    if (ref.current === node) return;\n\n    ref.current = node;\n\n    return ref;\n  }, []);\n\n  useEffect(() => {\n    if (isAutoLayout) return;\n    if (!ref.current) return;\n\n    const handleKeyDown = (event: KeyboardEvent) => {\n      if (event.key === \"Tab\") handleTab(event);\n    };\n\n    const handleClick = (event: any) => {\n      const target = event.target as HTMLElement;\n      if (target.matches(CANVAS_WIDGET)) {\n        target.focus();\n      }\n    };\n\n    ref.current.addEventListener(\"keydown\", handleKeyDown);\n    ref.current.addEventListener(\"click\", handleClick);\n\n    return () => {\n      ref?.current && ref.current.removeEventListener(\"keydown\", handleKeyDown);\n      ref?.current && ref.current.removeEventListener(\"click\", handleClick);\n    };\n  }, []);\n\n  return setRef;\n}\n\nexport default useWidgetFocus;\n"],"names":["WidgetGlobaStyles","createGlobalStyle","_templateObject","_taggedTemplateLiteral","_ref","primaryColor","_ref2","fontFamily","PageViewWrapper","styled","isPublished","hasPinnedSidebar","isPreview","sidebarWidth","concat","PageView","_templateObject2","props","width","RequestConfirmationModal","_React$Component","_this","_classCallCheck","_len","arguments","length","args","Array","_key","addEventListener","document","onKeyUp","removeEventListener","event","metaKey","ctrlKey","keyCode","Keys","onConfirm","modals","modalInfo","dispatch","acceptActionConfirmationModal","name","handleClose","showActionConfirmationModal","_objectSpread","modalOpen","cancelActionConfirmationModal","_inherits","_createClass","key","value","this","_this2","_this$props","modalsToBeOpened","filter","modal","_jsx","_Fragment","children","map","Modal","onOpenChange","open","_jsxs","ModalContent","style","ModalHeader","ModalBody","createMessage","QUERY_CONFIRMATION_MODAL_MESSAGE","ModalFooter","Button","kind","onClick","size","React","connect","state","ui","modalAction","getIsCanvasInitialized","mainCanvas","initialized","AUTOLAYOUT_RESIZER_WIDTH_BUFFER","useDynamicAppLayout","_currentApplicationDe","_currentApplicationDe2","_currentApplicationDe3","_currentApplicationDe4","useDispatch","explorerWidth","useSelector","getExplorerWidth","propertyPaneWidth","getPropertyPaneWidth","appMode","getAppMode","screenWidth","useWindowSizeHooks","mainCanvasProps","getMainCanvasProps","isPreviewMode","combinedPreviewModeSelector","currentPageId","getCurrentPageId","isCanvasInitialized","appLayout","getCurrentApplicationLayout","layoutSystemType","getLayoutSystemType","isAppSidebarPinned","getAppSidebarPinned","getSidebarWidth","isAppSettingsPaneWithNavigationTabOpen","getIsAppSettingsPaneWithNavigationTabOpen","currentApplicationDetails","getCurrentApplication","isMobile","useIsMobileDevice","isAutoCanvasResizing","widgetDragResize","_useState","useState","_useState2","_slicedToArray","isCanvasResizing","setIsCanvasResizing","search","useLocation","queryParams","URLSearchParams","isEmbed","get","isNavbarVisibleInEmbeddedApp","isPreviewing","layoutWidthRange","useMemo","minWidth","maxWidth","type","currentLayoutConfig","_get","layoutConfigurations","DefaultLayoutType","calculateCanvasWidth","calculatedWidth","scrollbarWidth","gutterWidth","LayoutSystemTypes","APP_MODE","APP_SIDEBAR_WIDTH","isEmbeddedAppWithNavVisible","ele","getElementById","CANVAS_VIEWPORT","clientWidth","totalWidthToSubtract","resizeToLayout","updateCanvasLayoutAction","debouncedResize","useCallback","_debounce","immediateDebouncedResize","resizeObserver","ResizeObserver","useEffect","observe","unobserve","applicationDetail","navigationSetting","orientation","navStyle","updateLayoutForMobileBreakpointAction","MAIN_CONTAINER_WIDGET_ID","canvasWidth","ReduxActionTypes","CANVAS_WIDGET","CANVAS_WIDGET_EXCLUDING_SCOPE","CONTAINER_SELECTOR","JSONFORM_WIDGET","MODAL_WIDGET","CHECKBOXGROUP_WIDGET","SWITCHGROUP_WIDGET","BUTTONGROUP_WIDGET","FOCUS_SELECTOR","WIDGET_SELECTOR","getTabbableDescendants","currentNode","shiftKey","undefined","activeWidget","closest","tabbableDescendants","from","querySelectorAll","domRect","getBoundingClientRect","sortWidgetsByPosition","top","bottom","left","right","matches","siblings","node","canvas","widget","sibling","getWidgetSiblingsOfNode","sortedSiblings","currentCanvas","getNextTabbableDescendant","descendants","nextTabbableDescendant","_nextTabbableDescenda","tabbable","getFocussableElementOfWidget","querySelector","boundingClientRect","isTabbingForward","isTabbingBackward","tabbableElementsByPosition","element","_element$getBoundingC","elementLeft","elementTop","topDiff","leftDiff","sort","a","b","handleTab","target","currentWidget","currentIndex","indexOf","activeElement","getNextTabbableDescendantForRegularWidgets","isNextWidgetElementFocusable","shift","preventDefault","focusableElement","focus","ref","useRef","isAutoLayout","getIsAutoLayout","setRef","current","handleKeyDown","handleClick"],"sourceRoot":""}