{"version":3,"file":"static/js/session_trace-aggregate.d6f75e2e.chunk.js","mappings":"0GAMA,IAAIA,E,gCACJ,IAAMC,EAA2B,IAAIC,SAAQ,SAAAC,GAC3CH,EAAgBG,CAClB,IACaC,EAAgBC,OAAOC,OAAO,CACzCN,cAAAA,EACAC,yBAAAA,G,0MCEK,IAAMM,EAAgB,SAAAC,GAY3B,SAAAD,EAAYE,EAAUC,EAAMC,GAAQ,IAAAC,EAAAC,E,MAkB9B,OAlB8BC,EAAAA,EAAAA,GAAA,KAAAP,G,EAClC,K,EAAAA,E,EAAA,CAAMI,G,cAANE,G,oFACKJ,SAAWA,EAChBI,EAAKH,KAAOA,GAAQ,CAAC,EACrBG,EAAKE,SAAU,EACfF,EAAKG,cAAgB,KACrBH,EAAKI,SAAU,EAEfJ,EAAKK,QAAU,IAAIC,EAAAA,EAAQN,EAAKO,gBAGhCC,EAAAA,EAAAA,GAAeR,EAAKS,OAAOC,MAAIC,EAAAA,EAAAA,GAAAX,KAKb,QAAlBD,EAAAC,EAAKO,qBAAa,IAAAR,GAAlBA,EAAoBa,GAAGC,GAAGC,EAAAA,GAAAA,OAAsB,kBAAMd,EAAKe,WAAW,CACpEC,cAAc,GACd,IAAEhB,CACN,CAiHC,OAhJ0BiB,EAAAA,EAAAA,GAAAvB,EAAAC,IAiC3BuB,EAAAA,EAAAA,GAAAxB,EAAA,EAAAyB,IAAA,SAAAC,MAIA,WACMC,KAAKjB,UAELiB,KAAKxB,KAAKyB,UAAUD,KAAKxB,KAAKyB,WAClCD,KAAKN,WAAW,CACdN,QAAQ,IAEZ,GAAC,CAAAU,IAAA,aAAAC,MACD,SAAWG,EAAUC,GACnBH,KAAKE,SAAWA,EAChBF,KAAKnB,SAAU,EACfmB,KAAKI,gBAAgC,MAAhBD,EAAuBA,EAAeH,KAAKE,SAClE,GAAC,CAAAJ,IAAA,YAAAC,MACD,WACE,IAAIM,EAAcC,UAAUC,OAAS,QAAsBC,IAAjBF,UAAU,IAAmBA,UAAU,GACjFN,KAAKjB,QAAUsB,EACfL,KAAKnB,SAAU,EACXmB,KAAKlB,eACP2B,aAAaT,KAAKlB,cAEtB,GAAC,CAAAgB,IAAA,kBAAAC,MACD,SAAgBW,EAAOlC,GAAM,IAAAmC,EAAA,KACvBX,KAAKlB,gBACI,MAAT4B,IACFA,EAAQV,KAAKE,UAEfF,KAAKlB,cAAgB8B,YAAW,WAC9BD,EAAK7B,cAAgB,KACrB6B,EAAKjB,WAAWlB,EAClB,GAAW,IAARkC,GACL,GAAC,CAAAZ,IAAA,aAAAC,MACD,SAAWvB,GAAM,IAAAqC,EAAA,KACf,IAAIb,KAAKjB,QAAT,CAMA,IAKI+B,EACAC,EANEC,EAAiB,SAAAC,GACb,OAAJzC,QAAI,IAAJA,GAAAA,EAAMmB,eAAcsB,EAAOC,OAAQ,GACvCL,EAAKM,kBAAkB3C,EAAMyC,EAC/B,EACIG,EAAW,GAGf,GAAIpB,KAAKxB,KAAK6C,WAAY,CAKxB,KAHAP,EAAeQ,EAAAA,GAA2B,CACxCC,eAAoB,OAAJ/C,QAAI,IAAJA,OAAI,EAAJA,EAAMY,UAEL,OAAO,EAC1B,IAAM8B,IAAa,OAAJ1C,QAAI,IAAJA,GAAAA,EAAMY,SAAU0B,IAAiBQ,EAAAA,GAKhD,KAJAP,EAAUf,KAAKxB,KAAK6C,WAAW,CAC7BH,MAAAA,EACA1C,KAAAA,KAMA,YAHIwB,KAAKnB,SACPmB,KAAKI,mBAITW,EAAsD,mBAA5C5C,OAAOqD,UAAUC,SAASC,KAAKX,GAAgCA,EAAU,CAACA,GACpFK,EAASO,KAAIC,MAAbR,GAAQS,EAAAA,EAAAA,GAASd,GACnB,CAGA,IAAIe,EAAO,SAAAC,GAAI,OAAIlB,EAAK7B,QAAQgD,MAAMD,EAAK,EACvCX,EAASb,OAEQuB,EAAf9B,KAAKxB,KAAKyD,IAAY,SAAAF,GAAI,OAAIlB,EAAK7B,QAAQkD,MAAMH,EAAK,EAC6C,SAAAA,GAAI,OAAIlB,EAAK7B,QAAQ8C,KAAKC,EAAK,EAGtIX,EAASO,UAAKnB,GAEhBY,EAASe,SAAQ,SAAApB,GACfe,EAAK,CACHvD,SAAUsC,EAAKtC,SACfwC,QAAAA,EACAvC,KAAAA,EACAsC,aAAAA,EACAsB,WAAYpB,EACZqB,UAAWxB,EAAKrC,KAAK6D,UACrBJ,IAAKpB,EAAKrC,KAAKyD,KAEnB,IACIjC,KAAKnB,SACPmB,KAAKI,iBAxDiB,CA0D1B,GAAC,CAAAN,IAAA,oBAAAC,MACD,SAAkBvB,EAAMyC,GAItB,GAHIjB,KAAKxB,KAAK8D,YACZtC,KAAKxB,KAAK8D,WAAWrB,GAEnBA,EAAOsB,MAAQtB,EAAOC,MAAO,CAC/B,IAAMR,EAAQO,EAAOP,OAASV,KAAKxB,KAAKgE,WAEpCxC,KAAKnB,SAAW6B,GAClBD,aAAaT,KAAKlB,eAClBkB,KAAKlB,cAAgB,KACrBkB,KAAKI,gBAAgBM,EAAOlC,KAClBwB,KAAKnB,SAAW6B,GAE1BV,KAAKI,gBAAgBM,EAAOlC,EAEhC,CACF,KAACH,CAAA,CAhJ0B,CAASoE,EAAAA,E,wGCPtC,GAAIC,EAAAA,GAAe,CACjBC,EAAAA,GAAAA,aAA2B,GAE3B,IAAMC,EAAYD,EAAAA,GAAAA,MAClBA,EAAAA,GAAAA,MAAoB,WAClB,IACyCE,EADzCC,GAAAC,EAAAA,EAAAA,GACiBJ,EAAAA,GAAAA,cAAwB,IAAzC,IAAAG,EAAAE,MAAAH,EAAAC,EAAAG,KAAAC,MAA2C,EACzCC,EADWN,EAAA9C,QAEb,CAAC,OAAAqD,GAAAN,EAAAO,EAAAD,EAAA,SAAAN,EAAAQ,GAAA,CACDV,GACF,CACF,CAOO,SAASzD,EAAeoE,GACzBC,EAAAA,KACFC,EAAAA,EAAAA,GAA4BF,GAAI,IAChCG,EAAAA,EAAAA,IAAuB,WAAYH,IAE1Bb,EAAAA,IACTC,EAAAA,GAAAA,aAAAA,KAA8BY,EAGlC,C,+YC/BaI,EAAY,oBAAAA,IAAA,IAAAhF,EAAA,MAAAC,EAAAA,EAAAA,GAAA,KAAA+E,IAmBvBC,EAAAA,EAAAA,GAAA,KAAAC,IAVAD,EAAAA,EAAAA,GAAA,KAAAE,IARAC,EAAAA,EAAAA,GAAA,KAAAC,EAAA,CAAAC,UAAA,EAAAlE,WACYS,KACZuD,EAAAA,EAAAA,GAAA,KAAAG,EAAA,CAAAD,UAAA,EAAAlE,MACS,MACTgE,EAAAA,EAAAA,GAAA,KAAAI,EAAA,CAAAF,UAAA,EAAAlE,MACea,YAAW,kBAAAwD,EAAAA,EAAAA,GAAMzF,EAAIkF,EAAAQ,GAAA3C,KAAJ/C,EAAI,GAAW,QAAKoF,EAAAA,EAAAA,GAAA,KAAAO,EAAA,CAAAL,UAAA,EAAAlE,OACnC,GAAK,CAmDrB,OAnDqBF,EAAAA,EAAAA,GAAA8D,EAAA,EAAA7D,IAAA,SAAAC,MA2BtB,SAAOwE,IACkB,KAAnBC,EAAAA,EAAAA,GAAAxE,KAAIgE,UAEsBxD,KAAnBgE,EAAAA,EAAAA,GAAAxE,KAAIgE,IAA0BQ,EAAAA,EAAAA,GAAAxE,KAAIkE,GAAQvC,KAAK4C,GAAcA,IAC1E,GAEA,CAAAzE,IAAA,SAAAC,MAQA,SAAO0E,IACLD,EAAAA,EAAAA,GAAIxE,KAAIsE,MACRI,EAAAA,EAAAA,GAAA1E,KAAIgE,EAAaS,IACA,IAAbA,IAAoBL,EAAAA,EAAAA,GAAApE,KAAI6D,EAAAQ,GAAA3C,KAAJ1B,OACP,IAAbyE,IAAmBL,EAAAA,EAAAA,GAAApE,KAAI8D,EAAAa,GAAAjD,KAAJ1B,MACzB,GAAC,CAAAF,IAAA,oBAAAC,MACD,SAAkB0E,IAChBD,EAAAA,EAAAA,GAAIxE,KAAIsE,KACRtE,KAAK4E,OAAOH,IACZC,EAAAA,EAAAA,GAAA1E,KAAIsE,GAAkB,GACxB,KAACX,CAAA,CA1DsB,GA2DxB,SAAAgB,KA5CGH,EAAAA,EAAAA,GAAAxE,KAAIkE,GAAQ/B,SAAQ,SAAA0C,GAAC,OAAIA,GAAG,KAC5BT,EAAAA,EAAAA,GAAApE,KAAI6D,EAAAQ,GAAA3C,KAAJ1B,KACF,CAAC,SAAAqE,KAQCK,EAAAA,EAAAA,GAAA1E,KAAIkE,EAAU,IACdzD,cAAY+D,EAAAA,EAAAA,GAACxE,KAAImE,GACnB,C,qCClBK,SAAeW,EAAoBC,GAAA,OAAAC,EAAApD,MAAC,KAADtB,UAAA,CAUzC,SAAA0E,IAAA,OAAAA,GAAAC,EAAAA,EAAAA,IAAAC,EAAAA,EAAAA,KAAAC,MAVM,SAAAC,EAAoCC,GAAO,IAAAC,EAAA,OAAAJ,EAAAA,EAAAA,KAAAK,MAAA,SAAAC,GAAA,cAAAA,EAAAC,KAAAD,EAAAE,MAAA,OAG9C,GAH8CF,EAAAC,KAAA,EAExCH,GAAWK,EAAAA,EAAAA,QAEbC,EAAAA,EAAAA,IAAsBP,EAAS,2BAAoG,kBAAhEC,EAASO,kBAAkBR,GAASS,SAASC,eAA2B,CAAAP,EAAAE,KAAA,gBAAAF,EAAAE,KAAA,EACjHJ,EAASO,kBAAkBR,GAASS,SAASC,eAAeC,oBAAmB,OAAxF,IAAAR,EAAAjD,KACA,CAAFiD,EAAAE,KAAA,gBAAAF,EAAAE,KAAA,EAAexH,EAAAA,EAAAA,yBAAsC,cAAAsH,EAAAS,OAAA,SAAAT,EAAAjD,MAAA,QAAAiD,EAAAE,KAAA,iBAAAF,EAAAC,KAAA,GAAAD,EAAAU,GAAAV,EAAA,wBAAAA,EAAAS,OAAA,SAGnEE,EAAAA,GAAAA,KAAQ,yBAAAX,EAAAY,OAAA,GAAAhB,EAAA,oBAChBxD,MAAA,KAAAtB,UAAA,C,0BCRD,IAAM+F,EAAgB,CAEpBC,OAAQ,CACNC,SAAS,EACTC,WAAW,GAGbC,OAAQ,CACNC,MAAM,EACNC,UAAU,GAGZC,iBAAkB,CAChBC,WAAW,IAGTC,EAAc,CAClBC,OAAQ,CAAC,IAAM,KACfC,UAAW,CAAC,IAAK,KACjBC,QAAS,CAAC,IAAM,KAChBC,SAAU,CAAC,IAAM,MAEbC,EAAqB,IAEkBC,EAAA,IAAAC,QAAAC,EAAA,IAAAC,QAAAC,EAAA,IAAAD,QAAAE,EAAA,IAAAJ,QAEhCK,EAAS,SAAAC,GAGpB,SAAAD,EAAYE,EAAiBC,EAAYC,GAAS,IAAAnH,EAC5ChC,E,MAMJ,IAPgDC,EAAAA,EAAAA,GAAA,KAAA8I,G,EAEhD,K,EAAAA,E,EAAA,CAAME,EAAiBC,EAAYE,EAAAA,I,aAAnCpH,G,oFAAiDiD,EAAAA,EAAAA,IAAAtE,EAAAA,EAAAA,GAAAqB,GAAA6G,IAAA5D,EAAAA,EAAAA,IAAAtE,EAAAA,EAAAA,GAAAqB,GAAA2G,IAAAvD,EAAAA,EAAAA,IAAAzE,EAAAA,EAAAA,GAAAqB,GAAAyG,EAAA,CAAAnD,UAAA,EAAAlE,WAAA,KAAAgE,EAAAA,EAAAA,IAAAzE,EAAAA,EAAAA,GAAAqB,GAAA8G,EAAA,CAAAxD,UAAA,EAAAlE,MA4WtC,IA3WXpB,GAAKW,EAAAA,EAAAA,GAAAqB,GACLA,EAAKqH,cAAeC,EAAAA,EAAAA,IAAWL,IAG1BjH,EAAKqH,aAAaE,aAAc,OAAAC,EAAAA,EAAAA,GAAAxH,GACrCA,EAAKyH,iBAA0B,OAAPN,QAAO,IAAPA,OAAO,EAAPA,EAASM,iBACjCzH,EAAK0H,KAAO,GACZ1H,EAAK2H,MAAQ,CAAC,EACd3H,EAAK4H,UAAY,EACjB5H,EAAK6H,UAAY,KACjB7H,EAAK8H,oBAAqB7C,EAAAA,EAAAA,IAAsBgC,EAAiB,qCAAuC,GACxGjH,EAAK+H,oBAAqB9C,EAAAA,EAAAA,IAAsBgC,EAAiB,qCAAuC,IAIxGjH,EAAKgI,cAAe,EACpB,IAAMC,EAAkB,IAAIjF,EACtBkF,EAAgBlI,EAAKqH,aAAac,QACxCnI,EAAKiI,gBAAkBA,EAGvB,IAkBIG,EAlBEC,EAAiB,SAAAC,GACrB,OAAQA,GACN,KAAK9C,EAAAA,GAAAA,MACHxF,EAAKuI,aAAaN,GAAiB,GACnC,MACF,KAAKzC,EAAAA,GAAAA,KACL,KAAK,EACHxF,EAAKuI,aAAaN,GAClB,MACF,KAAKzC,EAAAA,GAAAA,IAEL,QAEEyC,EAAgBhE,QAAO,GAG7B,EACIuE,GAAc,EAElBxI,EAAKpB,GAAGC,GAAGC,EAAAA,GAAAA,QAAuB,SAAC2J,EAAWC,GAExCA,EAAaC,oBAAsBnD,EAAAA,GAAAA,MAAWoD,GACpD,IAOA,IAAMA,EAAe,WAAM,IAAAC,EACzB,IAAqB,QAAjBA,EAAA7I,EAAKqH,oBAAY,IAAAwB,GAAS,QAATA,EAAjBA,EAAmBV,eAAO,IAAAU,GAAO,QAAPA,EAA1BA,EAA4BC,aAAK,IAAAD,OAAA,EAAjCA,EAAmCF,qBAAsBnD,EAAAA,GAAAA,MACzD4C,IAAwB5C,EAAAA,GAAAA,KAAW,CACrC,IAAMuD,EAAWX,EACjBA,EAAsB5C,EAAAA,GAAAA,KACtB0C,EAAcc,MAAM,CAClBC,iBAAkBb,IAEpBpI,EAAKgI,cAAe,EAChBe,IAAavD,EAAAA,GAAAA,QAAU3B,EAAAA,EAAAA,IAAAlF,EAAAA,EAAAA,GAAAqB,GAAAyG,IACzBzG,EAAKkJ,SApEmB,MAqExBrF,EAAAA,EAAAA,IAAAlF,EAAAA,EAAAA,GAAAqB,GAAAyG,GAAgB1H,WAAW,CACzBoK,cAAc,KAGhBd,EAAe7C,EAAAA,GAAAA,KAEnB,CACF,EACA,GAAK0C,EAOE,EACLkB,EAAAA,EAAAA,GAAgB,YAAY,WAC1BZ,GAAc,EACdI,GACF,GAAG5I,EAAKqJ,YAAarJ,EAAKpB,IAC1B,IAAM0K,EAAgB,WAAM,IAAAC,EAAAC,EACtBtB,EAAcY,MAAMG,mBAAqBzD,EAAAA,GAAAA,KAAU0C,EAAcc,MAAM,CACzEC,iBAAkBzD,EAAAA,GAAAA,MAEpByC,EAAgBwB,mBAAkB,GAC9BrB,IAAwB5C,EAAAA,GAAAA,OAAW,QAAA+D,GAAA1F,EAAAA,EAAAA,IAAAlF,EAAAA,EAAAA,GAAAqB,GAAAyG,UAAA,IAAA8C,GAAAA,EAAiBxK,cACxD,QAAAyK,GAAA3F,EAAAA,EAAAA,IAAAlF,EAAAA,EAAAA,GAAAqB,GAAAyG,UAAA,IAAA+C,GAAAA,EAAiBE,WAAU,IAC3B3F,EAAAA,EAAAA,IAAApF,EAAAA,EAAAA,GAAAqB,GAAAyG,EAAkB,KACpB,EAGAzG,EAAK2J,aAAa,CAAC,MAAO,OAAOC,KAAI,eAAAC,GAAAvF,EAAAA,EAAAA,IAAAC,EAAAA,EAAAA,KAAAC,MAAC,SAAAC,EAAMqF,GAAK,IAAAC,EAAAC,EAAAC,EAAAC,EAAA,OAAA3F,EAAAA,EAAAA,KAAAK,MAAA,SAAAC,GAAA,cAAAA,EAAAC,KAAAD,EAAAE,MAAA,OACzB,GADyBgF,GAAAI,EAAAA,EAAAA,GACrBL,EAAK,GAA1BE,EAAOD,EAAA,GAAUA,EAAA,GACP,CAAFlF,EAAAE,KAAA,QAEX/E,EAAKgI,cAAe,EACpBK,EAAe2B,GAASnF,EAAAE,KAAA,gBAerB,GAbH/E,EAAKpB,GAAGC,GAAG,kBAAkB,kBAAMyK,GAAe,IAIlDtJ,EAAKpB,GAAGC,GAAGC,EAAAA,GAAAA,QAAuB,WAChC,IAAMsL,EAAmBlC,EAAcY,MAAMG,iBACzCmB,IAAqB5E,EAAAA,GAAAA,IAAU8D,IAAyBc,IAAqB5E,EAAAA,GAAAA,OAAS3B,EAAAA,EAAAA,IAAAlF,EAAAA,EAAAA,GAAAqB,GAAAyG,MAAwB5C,EAAAA,EAAAA,IAAAlF,EAAAA,EAAAA,GAAAqB,GAAAyG,GAAgBvI,UAAS2F,EAAAA,EAAAA,IAAAlF,EAAAA,EAAAA,GAAAqB,GAAAyG,GAAgB1H,WAAW,CACpKoK,cAAc,IAEhBf,EAAsBgC,CACxB,IACApK,EAAKpB,GAAGC,GAAGC,EAAAA,GAAAA,OAAsB,WAC/BsJ,EAAsBF,EAAcY,MAAMG,gBAC5C,IACKf,EAAcmC,MAAO,CAAFxF,EAAAE,KAAA,SAElBmD,EAAcY,MAAMH,oBAAsBnD,EAAAA,GAAAA,MAAUxF,EAAKgI,cAAe,GAC5EK,EAAeD,EAAsBF,EAAcY,MAAMG,kBAAkBpE,EAAAE,KAAA,wBAAAF,EAAAE,KAAA,GAGlDZ,EAAqB8C,GAAgB,SAAxDgD,EAAUpF,EAAAjD,QACG4D,EAAAA,GAAAA,MAAUxF,EAAKgI,cAAe,GAK/CkC,EAFEF,GAMEC,IAAezE,EAAAA,GAAAA,OAAcgD,EAJlBhD,EAAAA,GAAAA,KAI4EyE,EAE7F/B,EAAcc,MAAM,CAClBC,iBAAkBb,EAAsB8B,IAE1C7B,EAAe6B,GAAc,yBAAArF,EAAAY,OAAA,GAAAhB,EAAA,KAGlC,gBAAAL,GAAA,OAAAyF,EAAA5I,MAAA,KAAAtB,UAAA,EA7CoC,GA8CvC,MAnEEK,EAAKgI,cAAe,EACpBhI,EAAK2J,aAAa,CAAC,QAAQC,MAAK,SAAAU,GAC9B,IAAKzL,GAALsL,EAAAA,EAAAA,GAAWG,EAAI,GAAR,GACP,OAAOjC,EAAexJ,EACxB,GAAGmB,EAAKqJ,YAAarJ,EAAKpB,IA6Gf,OA1CbwK,EAAAA,EAAAA,GAAgB,OAAO,WACrB,IAAK,IAAImB,EAAO5K,UAAUC,OAAQwB,EAAO,IAAIoJ,MAAMD,GAAOE,EAAO,EAAGA,EAAOF,EAAME,IAC/ErJ,EAAKqJ,GAAQ9K,UAAU8K,GAEzB,OAAOxC,EAAgByC,QAAO,eAAAxK,EAAA,OAAMA,EAAAlC,GAAM2M,WAAU1J,MAAAf,EAAIkB,EAAK,GAC/D,GAAGpB,EAAKqJ,YAAarJ,EAAKpB,KAC1BwK,EAAAA,EAAAA,GAAgB,eAAe,WAC7B,IAAK,IAAIwB,EAAQjL,UAAUC,OAAQwB,EAAO,IAAIoJ,MAAMI,GAAQC,EAAQ,EAAGA,EAAQD,EAAOC,IACpFzJ,EAAKyJ,GAASlL,UAAUkL,GAE1B,OAAO5C,EAAgByC,QAAO,eAAAI,EAAA,OAAMA,EAAA9M,GAAM+M,eAAc9J,MAAA6J,EAAI1J,EAAK,GACnE,GAAGpB,EAAKqJ,YAAarJ,EAAKpB,KAC1BwK,EAAAA,EAAAA,GAAgB,WAAW,WACzB,IAAK,IAAI4B,EAAQrL,UAAUC,OAAQwB,EAAO,IAAIoJ,MAAMQ,GAAQC,EAAQ,EAAGA,EAAQD,EAAOC,IACpF7J,EAAK6J,GAAStL,UAAUsL,GAE1B,OAAOhD,EAAgByC,QAAO,eAAAQ,EAAA,OAAMA,EAAAlN,GAAMmN,UAASlK,MAAAiK,EAAI9J,EAAK,GAC9D,GAAGpB,EAAKqJ,YAAarJ,EAAKpB,KAC1BwK,EAAAA,EAAAA,GAAgB,aAAa,WAC3B,IAAK,IAAIgC,EAAQzL,UAAUC,OAAQwB,EAAO,IAAIoJ,MAAMY,GAAQC,EAAQ,EAAGA,EAAQD,EAAOC,IACpFjK,EAAKiK,GAAS1L,UAAU0L,GAE1B,OAAOpD,EAAgByC,QAAO,eAAAY,EAAA,OAAMA,EAAAtN,GAAMuN,YAAWtK,MAAAqK,EAAIlK,EAAK,GAChE,GAAGpB,EAAKqJ,YAAarJ,EAAKpB,KAC1BwK,EAAAA,EAAAA,GAAgB,UAAU,WACxB,IAAK,IAAIoC,EAAQ7L,UAAUC,OAAQwB,EAAO,IAAIoJ,MAAMgB,GAAQC,EAAQ,EAAGA,EAAQD,EAAOC,IACpFrK,EAAKqK,GAAS9L,UAAU8L,GAE1B,OAAOxD,EAAgByC,QAAO,eAAAgB,EAAA,OAAMA,EAAA1N,GAAM2N,SAAQ1K,MAAAyK,EAAItK,EAAK,GAC7D,GAAGpB,EAAKqJ,YAAarJ,EAAKpB,KAC1BwK,EAAAA,EAAAA,GAAgB,YAAY,WAC1B,IAAK,IAAIwC,EAAQjM,UAAUC,OAAQwB,EAAO,IAAIoJ,MAAMoB,GAAQC,EAAQ,EAAGA,EAAQD,EAAOC,IACpFzK,EAAKyK,GAASlM,UAAUkM,GAE1B,OAAO5D,EAAgByC,QAAO,eAAAoB,EAAA,OAAMA,EAAA9N,GAAM+N,cAAa9K,MAAA6K,EAAI1K,EAAK,GAClE,GAAGpB,EAAKqJ,YAAarJ,EAAKpB,KAC1BwK,EAAAA,EAAAA,GAAgB,YAAY,WAC1B,IAAK,IAAI4C,EAAQrM,UAAUC,OAAQwB,EAAO,IAAIoJ,MAAMwB,GAAQC,EAAQ,EAAGA,EAAQD,EAAOC,IACpF7K,EAAK6K,GAAStM,UAAUsM,GAE1B,OAAOhE,EAAgByC,QAAO,eAAAwB,EAAA,OAAMA,EAAAlO,GAAMmO,WAAUlL,MAAAiL,EAAI9K,EAAK,GAC/D,GAAGpB,EAAKqJ,YAAarJ,EAAKpB,IAC1BoB,EAAKoM,QAAQpM,CACf,CAuVC,OAthBmBf,EAAAA,EAAAA,GAAA8H,EAAAC,IA+LnB9H,EAAAA,EAAAA,GAAA6H,EAAA,EAAA5H,IAAA,eAAAC,MACD,SAAaiN,GACX,IAAIC,EAAsB3M,UAAUC,OAAS,QAAsBC,IAAjBF,UAAU,IAAmBA,UAAU,GAC9C,qBAAhC4M,4BACTlN,KAAKmN,YAAY1G,OAAO2G,YAAYC,iBAAiB,cAAc,IAEnErN,KAAKmN,YAAY1G,OAAO2G,YAAYE,SAEtC5I,EAAAA,EAAAA,GAAA1E,KAAIoH,EAAc,IAAI/I,EAAAA,EAAiB,YAAa,CAClDiE,YAAY8B,EAAAA,EAAAA,GAAApE,KAAIsH,EAAAiG,GAAoBlO,KAAKW,MACzCwC,WAAYxC,KAAKyI,oBAChBzI,QACHwE,EAAAA,EAAAA,GAAAxE,KAAIoH,GAAYpI,QAAQQ,GAAG,aAAa4E,EAAAA,EAAAA,GAAApE,KAAIwH,EAAAgG,GAAiBnO,KAAKW,QACtC,IAAxBiN,IAA+BzI,EAAAA,EAAAA,GAAAxE,KAAIoH,GAAY1H,WAAW,CAC5DoK,cAAc,IAEhBkD,EAAcpI,QAAO,EACvB,GAAC,CAAA9E,IAAA,aAAAC,MA2CD,SAAW0N,EAAM1N,EAAO2N,GACtB1N,KAAKmN,aAAWQ,EAAAA,EAAAA,GAAC,CAAC,EACfF,EAAO1N,IAMV,SAAgB0N,EAAMC,GACpB,MAAgB,OAATD,KAAmBC,GAA8B,kBAAdA,EAAME,GAClD,CANIC,CAAOJ,EAAMC,IAAQ1N,KAAKsL,WAAW,CACvCwC,KAAM,MACNC,OAAQ,YACP,WAAYhO,EAAOA,EAAQ2N,EAAME,IAItC,GAEA,CAAA9N,IAAA,cAAAC,MACA,SAAYiO,GACV,GAAKA,EAGL,IAAK,IAAIlO,KAAOkO,EAAa,CAC3B,IAAIC,EAAMD,EAAYlO,GAGhBoO,EAAMpO,EAAIqO,cACZD,EAAIE,QAAQ,SAAW,GAAKF,EAAIE,QAAQ,WAAa,GAIpC,kBAARH,GAAoBA,GAAO,IACxCA,EAAMI,KAAKC,MAAML,GACjBjO,KAAKsM,SAAS,CACZrJ,EAAGnD,EACHkD,EAAGiL,EACH5K,EAAG4K,EACHM,EAAG,WACHC,EAAG,WAEP,CACF,GAEA,CAAA1O,IAAA,aAAAC,MACA,SAAW0O,EAAcV,EAAQW,EAAOC,GACtC,IAAI3O,KAAK4O,kBAAkBH,EAAcV,GAAzC,CACA,IAAMc,EAAM,CACV5L,EAAGjD,KAAK8O,QAAQL,EAAaX,MAC7B9K,EAAG0L,EACHrL,EAAGsL,EACHH,EAAG,SAEL,IAGEK,EAAIN,EAAIvO,KAAK+O,UAAUN,EAAaV,OAAQA,EAC9C,CAAE,MAAO1K,GACPwL,EAAIN,EAAIvO,KAAK+O,UAAU,KAAMhB,EAC/B,CACA/N,KAAKsM,SAASuC,EAd0C,CAe1D,GAAC,CAAA/O,IAAA,oBAAAC,MACD,SAAkBiP,EAAOjB,GACvB,IAAMkB,EAASjP,KAAK+O,UAAUC,EAAMjB,OAAQA,GAC5C,OAAIiB,EAAMlB,QAAQzH,EAAcC,YAC1BD,EAAc4I,KAAW5I,EAAc4I,GAAQpI,eACzCR,EAAc4I,MAAWD,EAAMlB,QAAQzH,EAAc4I,KACnE,GAAC,CAAAnP,IAAA,UAAAC,MACD,SAAQ+N,GACN,OAAQA,GACN,IAAK,UACL,IAAK,QACL,IAAK,WACH,MAAO,SACT,IAAK,YACL,IAAK,aACL,IAAK,aACL,IAAK,YACL,IAAK,WACH,MAAO,UACT,IAAK,SACH,MAAO,YACT,IAAK,aACL,IAAK,YACL,IAAK,WACL,IAAK,cACL,IAAK,aACL,IAAK,aACH,MAAO,WACT,QACE,OAAOA,EAEb,GAAC,CAAAhO,IAAA,YAAAC,MACD,SAAUyO,EAAGT,GACX,IAAIkB,EAAS,UACb,GAAIT,GAAKA,aAAaU,eAAgB,CACpC,IAAMC,EAASnP,KAAKT,GAAG6P,QAAQZ,GAAGW,OAClC,IAAKA,IAAWA,EAAOE,SAAWF,EAAOG,SAAWH,EAAOI,OAASJ,EAAOK,SAAU,MAAO,mBAC5FP,EAASE,EAAOE,OAAS,IAAMF,EAAOG,OAAS,KAAOH,EAAOI,KAAOJ,EAAOK,QAC7E,MAAO,GAAIhB,GAA0B,kBAAdA,EAAEiB,UACvBR,EAAST,EAAEiB,QAAQtB,cACfK,EAAEkB,KAAIT,GAAU,IAAMT,EAAEkB,IACxBlB,EAAEmB,WACJ,IAAK,IAAIC,EAAI,EAAGA,EAAIpB,EAAEqB,UAAUtP,OAAQqP,IAAKX,GAAU,IAAMT,EAAEqB,UAAUD,GAM7E,MAHe,YAAXX,IACoB,kBAAXlB,EAAqBkB,EAASlB,EAAgBA,IAAW+B,SAAUb,EAAS,WAAoBlB,IAAWtH,OAAQwI,EAAS,SAAkBlB,aAAkBgC,aAAYd,EAAS,eAE3LA,CACT,GAEA,CAAAnP,IAAA,YAAAC,MACA,SAAUiQ,EAAMC,EAAKC,GACnB,IAAMC,EAAO,CACXlN,EAAG,oBACHD,EAAGkN,EACH7M,EAAG6M,EACH3B,EAAGyB,EACHxB,EAAGyB,GAELjQ,KAAKsM,SAAS6D,EAChB,GAAC,CAAArQ,IAAA,iBAAAC,MAGD,SAAeqQ,GAAW,IAAAC,EAAA,KACnBD,GAAkC,IAArBA,EAAU7P,SAC5B6P,EAAUjO,SAAQ,SAAAmO,GAChB,MAAkC,EAA7BA,EAAgBC,cAAc/L,EAAAA,EAAAA,GAAK6L,EAAI5I,IAA5C,CAEA,IAAM+I,GAASC,EAAAA,EAAAA,GAASH,EAAgB7C,MAClCiD,EAAM,CACVzN,EAAGqN,EAAgBK,cACnB3N,EAAgC,EAA7BsN,EAAgBC,WACnBlN,EAAiC,EAA9BiN,EAAgBM,YACnBrC,EAAGiC,EAAOK,SAAW,MAAQL,EAAOM,SAAW,IAAMN,EAAOO,KAAOP,EAAOhB,SAE1EhB,EAAG8B,EAAgBU,WAErBX,EAAK/D,SAASoE,EAXiD,CAYjE,KACAhM,EAAAA,EAAAA,GAAA1E,KAAIyH,EAA2D,EAA7C2I,EAAUA,EAAU7P,OAAS,GAAGgQ,YACpD,GAEA,CAAAzQ,IAAA,gBAAAC,MACA,SAAc+N,EAAML,EAAM0B,EAAQ8B,GAChC,GAAa,QAATnD,EAAJ,CACA,IAAMqC,EAAO,CACXlN,EAAG,QACHD,EAAGiO,EAAQf,KACX7M,EAAG4N,EAAQf,KACX3B,EAAGY,EAAO+B,QACV1C,EAAGW,EAAOgC,WAEZnR,KAAKsM,SAAS6D,EARY,CAS5B,GAEA,CAAArQ,IAAA,cAAAC,MACA,SAAY+N,EAAML,EAAM0B,EAAQ8B,GAC9B,GAAa,QAATnD,EAAJ,CACA,IAAMqC,EAAO,CACXlN,EAAG,OACHD,EAAGiO,EAAQf,KACX7M,EAAG4N,EAAQf,KAAOe,EAAQG,SAC1B7C,EAAGY,EAAOE,OAAS,IAAMF,EAAOG,OAAS,KAAOH,EAAOI,KAAOJ,EAAOK,SACrEhB,EAAG,QAELxO,KAAKsM,SAAS6D,EARY,CAS5B,GAEA,CAAArQ,IAAA,WAAAC,MACA,SAASsR,GACP,GAAIrR,KAAKuI,WAAavI,KAAK0I,mBAAoB,CAE7C,GAAI1I,KAAK2I,cAAgB3I,KAAKgI,aAAac,QAAQW,MAAMG,mBAAqBzD,EAAAA,GAAAA,MAAY,OAE1F,GAAoB,IADAnG,KAAK6J,SAvaG,KAwaL,MACzB,CACI7J,KAAK2I,eAAgB2I,EAAAA,EAAAA,MAASnK,IAG9BnH,KAAKsI,MAAM+I,EAAIpO,GAAIjD,KAAKsI,MAAM+I,EAAIpO,GAAGtB,KAAK0P,GAAUrR,KAAKsI,MAAM+I,EAAIpO,GAAK,CAACoO,GAC7ErR,KAAKuI,YACP,GAEA,CAAAzI,IAAA,WAAAC,MAKA,SAASwR,GAAkB,IAAAC,EAAA,KACrBC,EAAc,EACZC,EAAoBrD,KAAKsD,KAAIL,EAAAA,EAAAA,KAAQC,EAAkB,GAgB7D,OAfApT,OAAOyT,KAAK5R,KAAKsI,OAAOnG,SAAQ,SAAA0P,GAC9B,IAAMC,EAAWN,EAAKlJ,MAAMuJ,GAIxBE,EAAYD,EAASE,WAAU,SAAA7B,GAAI,OAAIuB,GAAqBvB,EAAK9M,CAAC,IACpD,IAAd0O,IAAiCA,EAAY,GAE/CA,EAAYD,EAASvR,cACdiR,EAAKlJ,MAAMuJ,IACbC,EAASG,OAAO,EAAGF,GAE1BP,EAAKjJ,WAAawJ,EAClBN,GAAeM,EACjB,IACON,CACT,GAEA,CAAA3R,IAAA,WAAAC,MACA,SAASmB,GAAO,IAAAgR,EAAA,KACTlS,KAAKoI,kBAERpI,KAAK0L,eAAejF,OAAO2G,YAAYC,iBAAiB,aAE1D,IAkBI8E,EAlBAC,EAAoBC,IAClBC,EAAOnU,OAAOoU,QAAQvS,KAAKsI,OAAOkK,SAAQ,SAAAC,GAC9C,IAAAC,GAAA5H,EAAAA,EAAAA,GAA4B2H,EAAK,GAA5BhF,EAAIiF,EAAA,GAAEC,EAAaD,EAAA,GAElBE,EAAeD,EAAcE,QAAO,SAACC,EAAKpN,GAAI,OAAMoN,GAAOpN,EAAK1C,EAAI8P,EAAMpN,EAAK1C,EAAI8P,CAAG,QAAEtS,GAE9F,GADIoS,EAAeR,IAAmBA,EAAoBQ,KACpDnF,KAAQ3G,GAAc,OAAO6L,EAEnC,IAAMI,EAAoBb,EAAKc,kBAAkBvF,GAC3CwF,EAA2BN,EAAcO,MAAK,SAACC,EAAGC,GAAC,OAAKD,EAAEnQ,EAAIoQ,EAAEpQ,CAAC,IAAE6P,OAAOE,EAAmB,CAAC,GACpG,OAAO5U,OAAOkV,OAAOJ,GAA0BK,MACjD,GAAGtT,MACH,GAAoB,IAAhBsS,EAAK/R,OAAc,MAAO,CAAC,EAO/B,GANIW,IACFlB,KAAKwI,UAAYxI,KAAKsI,OAExBtI,KAAKsI,MAAQ,CAAC,EACdtI,KAAKuI,UAAY,EAEbvI,KAAKgI,aAAac,QAAS,CAC7B,IAAMyK,GAAkBvT,KAAKgI,aAAac,QAAQW,MAAM+J,oBACxDrB,EAAwB,CACtBsB,IAAKC,OAAOH,IAEVA,GAAgBvT,KAAKgI,aAAac,QAAQa,MAAM,CAClD6J,qBAAqB,GAEzB,CACA,MAAO,CACLG,IAAEC,EAAAA,EAAAA,GAAA,CACAC,GAAI7T,KAAKgI,aAAa8L,OAGtBC,GAAIL,QAAQ1T,KAAK2I,cAGjBqL,IAAKhU,KAAKgI,aAAa8L,OAAS1B,EAEhCnP,EAAGqP,EAAK/R,QAEL4R,GAEL8B,KAAM,CACJvD,IAAK4B,GAGX,GAAC,CAAAxS,IAAA,oBAAAC,MACD,SAAkB0N,GAChB,IAAMyG,EAASpN,EAAY2G,GAAM,GAC3B0G,EAASrN,EAAY2G,GAAM,GAC3B2G,EAAQ,CAAC,EACf,OAAO,SAACC,EAAUC,GAChB,IAAIC,EAAUF,EAASC,EAAQ/F,GAC1BgG,IAASA,EAAUF,EAASC,EAAQ/F,GAAK,IAC9C,IAAMiG,EAAOJ,EAAME,EAAQ/F,GAW3B,MAVa,cAATd,GAYN,SAAiB0C,GACf,IAAMsE,EAAQ,EACd,SAAUtE,GAA0B,kBAAXA,EAAK9M,GAAoC,kBAAX8M,EAAKnN,GAAkBmN,EAAK9M,EAAI8M,EAAKnN,EAAIyR,EAClG,CAf+BC,CAAQJ,GAI1BE,GAAQF,EAAQtR,EAAIwR,EAAKxR,EAAImR,GAAUK,EAAKnR,EAAIiR,EAAQtR,EAAIkR,EACrEM,EAAKnR,EAAIiR,EAAQjR,GAEjB+Q,EAAME,EAAQ/F,GAAK+F,EACnBC,EAAQ5S,KAAK2S,KAPbF,EAAME,EAAQ/F,GAAK,KACnB+F,EAAQrR,EAAI,SACZsR,EAAQ5S,KAAK2S,IAORD,CACT,CAKF,KAAC3M,CAAA,CAthBmB,CAASiN,EAAAA,GAuhB9B,SAAApH,EAtUoBtM,GAAQ,IAAA2T,EAAA,KACrB3T,EAAOsB,MAAQtB,EAAO4T,eAAiB7U,KAAKqI,OAE9CrI,KAAKgI,aAAaK,KAAOrI,KAAKqI,KAAOpH,EAAO4T,cAC5CrQ,EAAAA,EAAAA,GAAAxE,KAAIoH,GAAY0N,WAAW9U,KAAKyI,qBAE9BxH,EAAOsB,MAAQtB,EAAOC,OAASlB,KAAKwI,YAEtCrK,OAAOoU,QAAQvS,KAAKwI,WAAWrG,SAAQ,SAAA4S,GACrC,IAAAC,GAAAlK,EAAAA,EAAAA,GAA4BiK,EAAK,GAA5BtH,EAAIuH,EAAA,GAAErC,EAAaqC,EAAA,GACpBJ,EAAKrM,WAAaqM,EAAKlM,qBAC3BkM,EAAKrM,WAAaoK,EAAcpS,OAChCqU,EAAKtM,MAAMmF,GAAQmH,EAAKtM,MAAMmF,GAAQkF,EAAcsC,OAAOL,EAAKtM,MAAMmF,IAASkF,EACjF,IACA3S,KAAKwI,UAAY,KAErB,CAAC,SAAAgF,EACe0H,GACd,GAAIlV,KAAK2I,cACP,GAAI3I,KAAKqI,OAAQiJ,EAAAA,EAAAA,MAASnK,EAExB+N,EAAQ3T,gBAAiB,EACzBvB,KAAK4I,gBAAgBwB,mBAAkB,IACvC5F,EAAAA,EAAAA,GAAAxE,KAAIoH,GAAYiD,WAAU,QACrB,GAAIrK,KAAKqI,MAAQrI,KAAKuI,WA5OL,KA4O4C2M,EAAQ3T,eAE1E,WAEG,CAIL,IAAM4T,EAAcnV,KAAKgI,aAAac,QAAQW,MAAMG,iBAGpD,GAAIuL,IAAgBhP,EAAAA,GAAAA,KAA+C,IAAnChI,OAAOyT,KAAK5R,KAAKsI,OAAO/H,OAAc,OACtE,GAAI4U,IAAgBhP,EAAAA,GAAAA,MAAY,MAClC,CACA,OAAOnG,KAAKoV,SAASF,EAAQhU,MAC/B,EAACyM,EAAAA,EAAAA,GAxPUjG,EAAS,cACCK,EAAAA,G","sources":["../node_modules/@newrelic/browser-agent/dist/esm/common/constants/shared-channel.js","../node_modules/@newrelic/browser-agent/dist/esm/common/harvest/harvest-scheduler.js","../node_modules/@newrelic/browser-agent/dist/esm/common/unload/eol.js","../node_modules/@newrelic/browser-agent/dist/esm/features/utils/handler-cache.js","../node_modules/@newrelic/browser-agent/dist/esm/features/session_replay/shared/replay-mode.js","../node_modules/@newrelic/browser-agent/dist/esm/features/session_trace/aggregate/index.js"],"sourcesContent":["/**\n * @file Keeps an object alive that is passed to all feature aggregate modules.\n * The purpose is to have a way for communication and signals to relay across features at runtime.\n * This object can hold any arbitrary values and should be treated as on-the-fly dynamic.\n */\n\nlet onReplayReady;\nconst sessionReplayInitialized = new Promise(resolve => {\n  onReplayReady = resolve;\n});\nexport const sharedChannel = Object.freeze({\n  onReplayReady,\n  sessionReplayInitialized\n});","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as submitData from '../util/submit-data';\nimport { SharedContext } from '../context/shared-context';\nimport { Harvest } from './harvest';\nimport { subscribeToEOL } from '../unload/eol';\nimport { SESSION_EVENTS } from '../session/constants';\n\n/**\n * Periodically invokes harvest calls and handles retries\n */\nexport class HarvestScheduler extends SharedContext {\n  /**\n     * Create a HarvestScheduler\n     * @param {string} endpoint - The base BAM endpoint name -- ex. 'events'\n     * @param {object} opts - The options used to configure the HarvestScheduler\n     * @param {Function} opts.onFinished - The callback to be fired when a harvest has finished\n     * @param {Function} opts.getPayload - A callback which can be triggered to return a payload for harvesting\n     * @param {number} opts.retryDelay - The number of seconds to wait before retrying after a network failure\n     * @param {boolean} opts.raw - Use a prefabricated payload shape as the harvest payload without the need for formatting\n     * @param {string} opts.customUrl - A custom url that falls outside of the shape of the standard BAM harvester url pattern.  Will use directly instead of concatenating various pieces\n     * @param {*} parent - The parent object, whose state can be passed into SharedContext\n     */\n  constructor(endpoint, opts, parent) {\n    super(parent); // gets any allowed properties from the parent and stores them in `sharedContext`\n    this.endpoint = endpoint;\n    this.opts = opts || {};\n    this.started = false;\n    this.timeoutHandle = null;\n    this.aborted = false; // this controls the per-interval and final harvests for the scheduler (currently per feature specific!)\n\n    this.harvest = new Harvest(this.sharedContext);\n\n    // unload if EOL mechanism fires\n    subscribeToEOL(this.unload.bind(this));\n\n    /* Flush all buffered data if session resets and give up retries. This should be synchronous to ensure that the correct `session` value is sent.\n      Since session-reset generates a new session ID and the ID is grabbed at send-time, any delays or retries would cause the payload to be sent under\n      the wrong session ID. */\n    this.sharedContext?.ee.on(SESSION_EVENTS.RESET, () => this.runHarvest({\n      forceNoRetry: true\n    }));\n  }\n\n  /**\n   * This function is only meant for the last outgoing harvest cycle of a page. It trickles down to using sendBeacon, which should not be used\n   * to send payloads while the page is still active, due to limitations on how much data can be buffered in the API at any one time.\n   */\n  unload() {\n    if (this.aborted) return;\n    // If opts.onUnload is defined, these are special actions to execute before attempting to send the final payload.\n    if (this.opts.onUnload) this.opts.onUnload();\n    this.runHarvest({\n      unload: true\n    });\n  }\n  startTimer(interval, initialDelay) {\n    this.interval = interval;\n    this.started = true;\n    this.scheduleHarvest(initialDelay != null ? initialDelay : this.interval);\n  }\n  stopTimer() {\n    let permanently = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    this.aborted = permanently; // stopping permanently is same as aborting, but this function also cleans up the setTimeout loop\n    this.started = false;\n    if (this.timeoutHandle) {\n      clearTimeout(this.timeoutHandle);\n    }\n  }\n  scheduleHarvest(delay, opts) {\n    if (this.timeoutHandle) return;\n    if (delay == null) {\n      delay = this.interval;\n    }\n    this.timeoutHandle = setTimeout(() => {\n      this.timeoutHandle = null;\n      this.runHarvest(opts);\n    }, delay * 1000);\n  }\n  runHarvest(opts) {\n    if (this.aborted) return;\n\n    /**\n     * This is executed immediately after harvest sends the data via XHR, or if there's nothing to send. Note that this excludes on unloading / sendBeacon.\n     * @param {Object} result\n     */\n    const cbRanAfterSend = result => {\n      if (opts?.forceNoRetry) result.retry = false; // discard unsent data rather than re-queuing for next harvest attempt\n      this.onHarvestFinished(opts, result);\n    };\n    let harvests = [];\n    let submitMethod;\n    let payload;\n    if (this.opts.getPayload) {\n      // Ajax & PVT & SR features provide a callback function to get data for harvesting\n      submitMethod = submitData.getSubmitMethod({\n        isFinalHarvest: opts?.unload\n      });\n      if (!submitMethod) return false;\n      const retry = !opts?.unload && submitMethod === submitData.xhr;\n      payload = this.opts.getPayload({\n        retry,\n        opts\n      });\n      if (!payload) {\n        if (this.started) {\n          this.scheduleHarvest();\n        }\n        return;\n      }\n      payload = Object.prototype.toString.call(payload) === '[object Array]' ? payload : [payload];\n      harvests.push(...payload);\n    }\n\n    /** sendX is used for features that do not supply a preformatted payload via \"getPayload\" */\n    let send = args => this.harvest.sendX(args);\n    if (harvests.length) {\n      /** _send is the underlying method for sending in the harvest, if sending raw we can bypass the other helpers completely which format the payloads */\n      if (this.opts.raw) send = args => this.harvest._send(args);\n      /** send is used to formated the payloads from \"getPayload\" and obfuscate before sending */else send = args => this.harvest.send(args);\n    } else {\n      // force it to run at least once in sendX mode\n      harvests.push(undefined);\n    }\n    harvests.forEach(payload => {\n      send({\n        endpoint: this.endpoint,\n        payload,\n        opts,\n        submitMethod,\n        cbFinished: cbRanAfterSend,\n        customUrl: this.opts.customUrl,\n        raw: this.opts.raw\n      });\n    });\n    if (this.started) {\n      this.scheduleHarvest();\n    }\n  }\n  onHarvestFinished(opts, result) {\n    if (this.opts.onFinished) {\n      this.opts.onFinished(result);\n    }\n    if (result.sent && result.retry) {\n      const delay = result.delay || this.opts.retryDelay;\n      // reschedule next harvest if should be delayed longer\n      if (this.started && delay) {\n        clearTimeout(this.timeoutHandle);\n        this.timeoutHandle = null;\n        this.scheduleHarvest(delay, opts);\n      } else if (!this.started && delay) {\n        // if not running on a timer, schedule a single retry\n        this.scheduleHarvest(delay, opts);\n      }\n    }\n  }\n}","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { windowAddEventListener } from '../event-listener/event-listener-opts';\nimport { globalScope, isWorkerScope, isBrowserScope } from '../constants/runtime';\nimport { subscribeToVisibilityChange } from '../window/page-visibility';\nif (isWorkerScope) {\n  globalScope.cleanupTasks = []; // create new list on WorkerGlobalScope to track funcs to run before exiting thread\n\n  const origClose = globalScope.close;\n  globalScope.close = () => {\n    // on worker's EoL signal, execute all \"listeners\", e.g. final harvests\n    for (let task of globalScope.cleanupTasks) {\n      task();\n    }\n    origClose();\n  };\n}\n\n/**\n * Subscribes a provided callback to the time/event when the agent should treat it as end-of-life.\n * This is used, for example, to submit a final harvest and send all remaining data on best-effort.\n * @param {function} cb - func to run before or during the last reliable event or time of an env's life span\n */\nexport function subscribeToEOL(cb) {\n  if (isBrowserScope) {\n    subscribeToVisibilityChange(cb, true); // when user switches tab or hides window, esp. mobile scenario\n    windowAddEventListener('pagehide', cb); // when user navigates away, and because safari iOS v14.4- doesn't fully support vis change\n    // --this ought to be removed once support for version below 14.5 phases out\n  } else if (isWorkerScope) {\n    globalScope.cleanupTasks.push(cb); // close() should run these tasks before quitting thread\n  }\n  // By default (for other env), this fn has no effect.\n}","/**\n * A class to defer callback execution until a decision can be reached\n */\nexport class HandlerCache {\n  /** @private @type {boolean | undefined} */\n  #decision = undefined;\n  /** @private @type {Function[]} */\n  #cache = [];\n  /** @private @type {Timeout} */\n  #settleTimer = setTimeout(() => this.#close(), 5000);\n  #noMoreChanges = false;\n\n  /**\n   * tell the handlerCache that its ok to immediately execute the callbacks that are triggered by the ee from this moment on\n   * and execute all the storage callbacks saved up in the handlerCache\n   * @private\n   */\n  #drain() {\n    this.#cache.forEach(h => h());\n    this.#close();\n  }\n\n  /**\n   * tell the handlerCache not to execute any of the storage callbacks\n   * and wipe out all the storage callbacks saved up in the handlerCache\n   * @private\n   */\n  #close() {\n    this.#cache = [];\n    clearTimeout(this.#settleTimer);\n  }\n\n  /**\n   * Wrap callback functions with this method to defer their execution until a decision has been reached\n   * @param {Function} handler\n   * @returns {void}\n   */\n  settle(handler) {\n    if (this.#decision === false) {\n      // Do nothing\n    } else if (this.#decision === undefined) this.#cache.push(handler);else handler();\n  }\n\n  /**\n   * Make a decision about what to do with the cache of callbacks.\n   * --- if true: tell the handlerCache that its ok to immediately execute the callbacks that are triggered by the ee from this moment on\n   * and execute all the storage callbacks saved up in the handlerCache ---\n   * --- if false: tell the handlerCache not to execute any of the storage callbacks\n   * and wipe out all the storage callbacks saved up in the handlerCache\n   * @param {boolean} decision\n   */\n  decide(decision) {\n    if (this.#noMoreChanges) return;\n    this.#decision = decision;\n    if (decision === false) this.#close();\n    if (decision === true) this.#drain();\n  }\n  permanentlyDecide(decision) {\n    if (this.#noMoreChanges) return;\n    this.decide(decision);\n    this.#noMoreChanges = true;\n  }\n}","import { getConfigurationValue } from '../../../common/config/config';\nimport { gosNREUM } from '../../../common/window/nreum';\nimport { sharedChannel } from '../../../common/constants/shared-channel';\nimport { MODE } from '../../../common/session/constants';\n\n/**\n * Figure out if the Replay feature is running (what mode it's in).\n * IMPORTANT: Session tracking is assumed to be ON; if applicable, check init's privacy.cookies_enabled setting before using this fn!\n * CRITICAL: This fn must be called prior to ALL features aggregate draining. If not, it will never resolve.\n * @param {String} agentId\n * @returns Promise that resolves to one of the values in MODE enum\n */\nexport async function getSessionReplayMode(agentId) {\n  try {\n    const newrelic = gosNREUM();\n    // Should be enabled by configuration and using an agent build that includes it (via checking that the instrument class was initialized).\n    if (getConfigurationValue(agentId, 'session_replay.enabled') && typeof newrelic.initializedAgents[agentId].features.session_replay === 'object') {\n      const srInitialized = await newrelic.initializedAgents[agentId].features.session_replay.onAggregateImported;\n      if (srInitialized) return await sharedChannel.sessionReplayInitialized; // wait for replay to determine which mode it's after running its sampling logic\n    }\n  } catch (e) {/* exception ==> off */}\n  return MODE.OFF; // at any step of the way s.t. SR cannot be on by implication or is explicitly off\n}","/*\n * Copyright 2020 New Relic Corporation. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { registerHandler } from '../../../common/event-emitter/register-handler';\nimport { HarvestScheduler } from '../../../common/harvest/harvest-scheduler';\nimport { parseUrl } from '../../../common/url/parse-url';\nimport { getConfigurationValue, getRuntime } from '../../../common/config/config';\nimport { FEATURE_NAME } from '../constants';\nimport { HandlerCache } from '../../utils/handler-cache';\nimport { getSessionReplayMode } from '../../session_replay/shared/replay-mode';\nimport { AggregateBase } from '../../utils/aggregate-base';\nimport { MODE, SESSION_EVENTS } from '../../../common/session/constants';\nimport { now } from '../../../common/timing/now';\nconst ignoredEvents = {\n  // we find that certain events make the data too noisy to be useful\n  global: {\n    mouseup: true,\n    mousedown: true\n  },\n  // certain events are present both in the window and in PVT metrics.  PVT metrics are prefered so the window events should be ignored\n  window: {\n    load: true,\n    pagehide: true\n  },\n  // when ajax instrumentation is disabled, all XMLHttpRequest events will return with origin = xhrOriginMissing and should be ignored\n  xhrOriginMissing: {\n    ignoreAll: true\n  }\n};\nconst toAggregate = {\n  typing: [1000, 2000],\n  scrolling: [100, 1000],\n  mousing: [1000, 2000],\n  touching: [1000, 2000]\n};\nconst MAX_TRACE_DURATION = 10 * 60 * 1000; // 10 minutes\nconst REQ_THRESHOLD_TO_SEND = 30;\nconst ERROR_MODE_SECONDS_WINDOW = 30 * 1000; // sliding window of nodes to track when simply monitoring (but not harvesting) in error mode\n\nexport class Aggregate extends AggregateBase {\n  static featureName = FEATURE_NAME;\n  #scheduler;\n  constructor(agentIdentifier, aggregator, argsObj) {\n    var _this;\n    super(agentIdentifier, aggregator, FEATURE_NAME);\n    _this = this;\n    this.agentRuntime = getRuntime(agentIdentifier);\n\n    // Very unlikely, but in case the existing XMLHttpRequest.prototype object on the page couldn't be wrapped.\n    if (!this.agentRuntime.xhrWrappable) return;\n    this.resourceObserver = argsObj?.resourceObserver; // undefined if observer couldn't be created\n    this.ptid = '';\n    this.trace = {};\n    this.nodeCount = 0;\n    this.sentTrace = null;\n    this.harvestTimeSeconds = getConfigurationValue(agentIdentifier, 'session_trace.harvestTimeSeconds') || 10;\n    this.maxNodesPerHarvest = getConfigurationValue(agentIdentifier, 'session_trace.maxNodesPerHarvest') || 1000;\n    /**\n     * Standalone (mode) refers to the legacy version of ST before the idea of 'session' or the Replay feature existed.\n     * It has some different behavior vs when used in tandem with replay. */\n    this.isStandalone = false;\n    const operationalGate = new HandlerCache(); // acts as a controller-intermediary that can enable or disable this feature's collection dynamically\n    const sessionEntity = this.agentRuntime.session;\n    this.operationalGate = operationalGate;\n\n    /* --- The following section deals with user sessions concept & contains non-trivial control flow. --- */\n    const controlTraceOp = traceMode => {\n      switch (traceMode) {\n        case MODE.ERROR:\n          this.startTracing(operationalGate, true);\n          break;\n        case MODE.FULL:\n        case true:\n          this.startTracing(operationalGate);\n          break;\n        case MODE.OFF:\n        case false:\n        default:\n          // this feature becomes \"off\" (does nothing & nothing is sent)\n          operationalGate.decide(false);\n          break;\n      }\n    };\n    let seenAnError = false;\n    let mostRecentModeKnown;\n    this.ee.on(SESSION_EVENTS.UPDATE, (eventType, sessionState) => {\n      // this will only have an effect if ST is NOT already in full mode\n      if (sessionState.sessionReplayMode === MODE.FULL) switchToFull();\n    });\n\n    /**\n     * The goal of switchToFull is to take external input to trigger a change from off or error to full.\n     * It will have no effect if already running in full mode.\n     * \"external\" input in this case means errors thrown on the page or session replay itself being triggered to run in full mode by the API, which updates the session entity.\n     */\n    const switchToFull = () => {\n      if (this.agentRuntime?.session?.state?.sessionReplayMode !== MODE.FULL) return;\n      if (mostRecentModeKnown !== MODE.FULL) {\n        const prevMode = mostRecentModeKnown;\n        mostRecentModeKnown = MODE.FULL;\n        sessionEntity.write({\n          sessionTraceMode: mostRecentModeKnown\n        });\n        this.isStandalone = false;\n        if (prevMode === MODE.ERROR && this.#scheduler) {\n          this.trimSTNs(ERROR_MODE_SECONDS_WINDOW); // up until now, Trace would've been just buffering nodes up to max, which needs to be trimmed to last X seconds\n          this.#scheduler.runHarvest({\n            needResponse: true\n          });\n        } else {\n          controlTraceOp(MODE.FULL);\n        }\n      }\n    };\n    if (!sessionEntity) {\n      // Since session manager isn't around, do the old Trace behavior of waiting for RUM response to decide feature activation.\n      this.isStandalone = true;\n      this.waitForFlags(['stn']).then(_ref => {\n        let [on] = _ref;\n        return controlTraceOp(on);\n      }, this.featureName, this.ee);\n    } else {\n      registerHandler('errorAgg', () => {\n        seenAnError = true;\n        switchToFull();\n      }, this.featureName, this.ee);\n      const stopTracePerm = () => {\n        if (sessionEntity.state.sessionTraceMode !== MODE.OFF) sessionEntity.write({\n          sessionTraceMode: MODE.OFF\n        });\n        operationalGate.permanentlyDecide(false);\n        if (mostRecentModeKnown === MODE.FULL) this.#scheduler?.runHarvest(); // allow queued nodes (past opGate) to final harvest, unless they were buffered in other modes\n        this.#scheduler?.stopTimer(true); // the 'true' arg here will forcibly block any future call to runHarvest, so the last runHarvest above must be prior\n        this.#scheduler = null;\n      };\n\n      // CAUTION: everything inside this promise runs post-load; event subscribers must be pre-load aka synchronous with constructor\n      this.waitForFlags(['stn', 'sr']).then(async _ref2 => {\n        let [traceOn, replayOn] = _ref2;\n        if (!replayOn) {\n          // When sr = 0 from BCS, also do the old Trace behavior:\n          this.isStandalone = true;\n          controlTraceOp(traceOn);\n        } else {\n          this.ee.on('REPLAY_ABORTED', () => stopTracePerm());\n          /* Assuming on page visible that the trace mode is updated from shared session,\n           - if trace is turned off from the other page, it should be likewise here.\n           - if trace switches to Full mode, harvest should start (prev: Error) if not already running (prev: Full). */\n          this.ee.on(SESSION_EVENTS.RESUME, () => {\n            const updatedTraceMode = sessionEntity.state.sessionTraceMode;\n            if (updatedTraceMode === MODE.OFF) stopTracePerm();else if (updatedTraceMode === MODE.FULL && this.#scheduler && !this.#scheduler.started) this.#scheduler.runHarvest({\n              needResponse: true\n            });\n            mostRecentModeKnown = updatedTraceMode;\n          });\n          this.ee.on(SESSION_EVENTS.PAUSE, () => {\n            mostRecentModeKnown = sessionEntity.state.sessionTraceMode;\n          });\n          if (!sessionEntity.isNew) {\n            // inherit the same mode as existing session's Trace\n            if (sessionEntity.state.sessionReplayMode === MODE.OFF) this.isStandalone = true;\n            controlTraceOp(mostRecentModeKnown = sessionEntity.state.sessionTraceMode);\n          } else {\n            // for new sessions, see the truth table associated with NEWRELIC-8662 wrt the new Trace behavior under session management\n            const replayMode = await getSessionReplayMode(agentIdentifier);\n            if (replayMode === MODE.OFF) this.isStandalone = true; // without SR, Traces are still subject to old harvest limits\n\n            let startingMode;\n            if (traceOn) {\n              // CASE: both trace (entitlement+sampling) & replay (entitlement) flags are true from RUM\n              startingMode = MODE.FULL; // always full capture regardless of replay sampling decisions\n            } else {\n              // CASE: trace flag is off, BUT it must still run if replay is on (possibly)\n              // At this point, it's possible that 1 or more exception was thrown, in which case just start in full if Replay originally started in ERROR mode.\n              if (replayMode === MODE.ERROR && seenAnError) startingMode = MODE.FULL;else startingMode = replayMode;\n            }\n            sessionEntity.write({\n              sessionTraceMode: mostRecentModeKnown = startingMode\n            });\n            controlTraceOp(startingMode);\n          }\n        }\n      });\n    }\n    /* --- EoS --- */\n\n    // register the handlers immediately... but let the handlerCache decide if the data should actually get stored...\n    registerHandler('bst', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return operationalGate.settle(() => _this.storeEvent(...args));\n    }, this.featureName, this.ee);\n    registerHandler('bstResource', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return operationalGate.settle(() => _this.storeResources(...args));\n    }, this.featureName, this.ee);\n    registerHandler('bstHist', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      return operationalGate.settle(() => _this.storeHist(...args));\n    }, this.featureName, this.ee);\n    registerHandler('bstXhrAgg', function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      return operationalGate.settle(() => _this.storeXhrAgg(...args));\n    }, this.featureName, this.ee);\n    registerHandler('bstApi', function () {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n      return operationalGate.settle(() => _this.storeSTN(...args));\n    }, this.featureName, this.ee);\n    registerHandler('errorAgg', function () {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n      return operationalGate.settle(() => _this.storeErrorAgg(...args));\n    }, this.featureName, this.ee);\n    registerHandler('pvtAdded', function () {\n      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n      return operationalGate.settle(() => _this.processPVT(...args));\n    }, this.featureName, this.ee);\n    this.drain();\n  }\n  startTracing(startupBuffer) {\n    let dontStartHarvestYet = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (typeof PerformanceNavigationTiming !== 'undefined') {\n      this.storeTiming(window.performance.getEntriesByType('navigation')[0]);\n    } else {\n      this.storeTiming(window.performance.timing);\n    }\n    this.#scheduler = new HarvestScheduler('resources', {\n      onFinished: this.#onHarvestFinished.bind(this),\n      retryDelay: this.harvestTimeSeconds\n    }, this);\n    this.#scheduler.harvest.on('resources', this.#prepareHarvest.bind(this));\n    if (dontStartHarvestYet === false) this.#scheduler.runHarvest({\n      needResponse: true\n    }); // sends first stn harvest immediately\n    startupBuffer.decide(true); // signal to ALLOW & process data in EE's buffer into internal nodes queued for next harvest\n  }\n  #onHarvestFinished(result) {\n    if (result.sent && result.responseText && !this.ptid) {\n      // continue interval harvest only if ptid was returned by server on the first\n      this.agentRuntime.ptid = this.ptid = result.responseText;\n      this.#scheduler.startTimer(this.harvestTimeSeconds);\n    }\n    if (result.sent && result.retry && this.sentTrace) {\n      // merge previous trace back into buffer to retry for next harvest\n      Object.entries(this.sentTrace).forEach(_ref3 => {\n        let [name, listOfSTNodes] = _ref3;\n        if (this.nodeCount >= this.maxNodesPerHarvest) return;\n        this.nodeCount += listOfSTNodes.length;\n        this.trace[name] = this.trace[name] ? listOfSTNodes.concat(this.trace[name]) : listOfSTNodes;\n      });\n      this.sentTrace = null;\n    }\n  }\n  #prepareHarvest(options) {\n    if (this.isStandalone) {\n      if (this.ptid && now() >= MAX_TRACE_DURATION) {\n        // Perform a final harvest once we hit or exceed the max session trace time\n        options.isFinalHarvest = true;\n        this.operationalGate.permanentlyDecide(false);\n        this.#scheduler.stopTimer(true);\n      } else if (this.ptid && this.nodeCount <= REQ_THRESHOLD_TO_SEND && !options.isFinalHarvest) {\n        // Only harvest when more than some threshold of nodes are pending, after the very first harvest, with the exception of the last outgoing harvest.\n        return;\n      }\n    } else {\n      //   -- *cli May '26 - Update: Not rate limiting backgrounded pages either for now.\n      //   if (this.ptid && document.visibilityState === 'hidden' && this.nodeCount <= REQ_THRESHOLD_TO_SEND) return\n\n      const currentMode = this.agentRuntime.session.state.sessionTraceMode;\n      /* There could still be nodes previously collected even after Trace (w/ session mgmt) is turned off. Hence, continue to send the last batch.\n       * The intermediary controller SHOULD be already switched off so that no nodes are further queued. */\n      if (currentMode === MODE.OFF && Object.keys(this.trace).length === 0) return;\n      if (currentMode === MODE.ERROR) return; // Trace in this mode should never be harvesting, even on unload\n    }\n    return this.takeSTNs(options.retry);\n  }\n\n  // PageViewTiming (FEATURE) events and metrics, such as 'load', 'lcp', etc. pipes into ST here.\n  processPVT(name, value, attrs) {\n    this.storeTiming({\n      [name]: value\n    });\n    if (hasFID(name, attrs)) this.storeEvent({\n      type: 'fid',\n      target: 'document'\n    }, 'document', value, value + attrs.fid);\n    function hasFID(name, attrs) {\n      return name === 'fi' && !!attrs && typeof attrs.fid === 'number';\n    }\n  }\n\n  // This processes the aforementioned PVT and the first navigation entry of the page.\n  storeTiming(timingEntry) {\n    if (!timingEntry) return;\n\n    // loop iterates through prototype also (for FF)\n    for (let key in timingEntry) {\n      let val = timingEntry[key];\n\n      // ignore size and status type nodes that do not map to timestamp metrics\n      const lck = key.toLowerCase();\n      if (lck.indexOf('size') >= 0 || lck.indexOf('status') >= 0) continue;\n\n      // ignore inherited methods, meaningless 0 values, and bogus timestamps\n      // that are in the future (Microsoft Edge seems to sometimes produce these)\n      if (!(typeof val === 'number' && val >= 0)) continue;\n      val = Math.round(val);\n      this.storeSTN({\n        n: key,\n        s: val,\n        e: val,\n        o: 'document',\n        t: 'timing'\n      });\n    }\n  }\n\n  // Tracks the events and their listener's duration on objects wrapped by wrap-events.\n  storeEvent(currentEvent, target, start, end) {\n    if (this.shouldIgnoreEvent(currentEvent, target)) return;\n    const evt = {\n      n: this.evtName(currentEvent.type),\n      s: start,\n      e: end,\n      t: 'event'\n    };\n    try {\n      // webcomponents-lite.js can trigger an exception on currentEvent.target getter because\n      // it does not check currentEvent.currentTarget before calling getRootNode() on it\n      evt.o = this.evtOrigin(currentEvent.target, target);\n    } catch (e) {\n      evt.o = this.evtOrigin(null, target);\n    }\n    this.storeSTN(evt);\n  }\n  shouldIgnoreEvent(event, target) {\n    const origin = this.evtOrigin(event.target, target);\n    if (event.type in ignoredEvents.global) return true;\n    if (!!ignoredEvents[origin] && ignoredEvents[origin].ignoreAll) return true;\n    return !!(!!ignoredEvents[origin] && event.type in ignoredEvents[origin]);\n  }\n  evtName(type) {\n    switch (type) {\n      case 'keydown':\n      case 'keyup':\n      case 'keypress':\n        return 'typing';\n      case 'mousemove':\n      case 'mouseenter':\n      case 'mouseleave':\n      case 'mouseover':\n      case 'mouseout':\n        return 'mousing';\n      case 'scroll':\n        return 'scrolling';\n      case 'touchstart':\n      case 'touchmove':\n      case 'touchend':\n      case 'touchcancel':\n      case 'touchenter':\n      case 'touchleave':\n        return 'touching';\n      default:\n        return type;\n    }\n  }\n  evtOrigin(t, target) {\n    let origin = 'unknown';\n    if (t && t instanceof XMLHttpRequest) {\n      const params = this.ee.context(t).params;\n      if (!params || !params.status || !params.method || !params.host || !params.pathname) return 'xhrOriginMissing';\n      origin = params.status + ' ' + params.method + ': ' + params.host + params.pathname;\n    } else if (t && typeof t.tagName === 'string') {\n      origin = t.tagName.toLowerCase();\n      if (t.id) origin += '#' + t.id;\n      if (t.className) {\n        for (let i = 0; i < t.classList.length; i++) origin += '.' + t.classList[i];\n      }\n    }\n    if (origin === 'unknown') {\n      if (typeof target === 'string') origin = target;else if (target === document) origin = 'document';else if (target === window) origin = 'window';else if (target instanceof FileReader) origin = 'FileReader';\n    }\n    return origin;\n  }\n\n  // Tracks when the window history API specified by wrap-history is used.\n  storeHist(path, old, time) {\n    const node = {\n      n: 'history.pushState',\n      s: time,\n      e: time,\n      o: path,\n      t: old\n    };\n    this.storeSTN(node);\n  }\n  #laststart = 0;\n  // Processes all the PerformanceResourceTiming entries captured (by observer).\n  storeResources(resources) {\n    if (!resources || resources.length === 0) return;\n    resources.forEach(currentResource => {\n      if ((currentResource.fetchStart | 0) <= this.#laststart) return; // don't recollect already-seen resources\n\n      const parsed = parseUrl(currentResource.name);\n      const res = {\n        n: currentResource.initiatorType,\n        s: currentResource.fetchStart | 0,\n        e: currentResource.responseEnd | 0,\n        o: parsed.protocol + '://' + parsed.hostname + ':' + parsed.port + parsed.pathname,\n        // resource.name is actually a URL so it's the source\n        t: currentResource.entryType\n      };\n      this.storeSTN(res);\n    });\n    this.#laststart = resources[resources.length - 1].fetchStart | 0;\n  }\n\n  // JavascriptError (FEATURE) events pipes into ST here.\n  storeErrorAgg(type, name, params, metrics) {\n    if (type !== 'err') return; // internal errors are purposefully ignored\n    const node = {\n      n: 'error',\n      s: metrics.time,\n      e: metrics.time,\n      o: params.message,\n      t: params.stackHash\n    };\n    this.storeSTN(node);\n  }\n\n  // Ajax (FEATURE) events--XML & fetches--pipes into ST here.\n  storeXhrAgg(type, name, params, metrics) {\n    if (type !== 'xhr') return;\n    const node = {\n      n: 'Ajax',\n      s: metrics.time,\n      e: metrics.time + metrics.duration,\n      o: params.status + ' ' + params.method + ': ' + params.host + params.pathname,\n      t: 'ajax'\n    };\n    this.storeSTN(node);\n  }\n\n  // Central function called by all the other store__ & addToTrace API to append a trace node.\n  storeSTN(stn) {\n    if (this.nodeCount >= this.maxNodesPerHarvest) {\n      // limit the amount of pending data awaiting next harvest\n      if (this.isStandalone || this.agentRuntime.session.state.sessionTraceMode !== MODE.ERROR) return;\n      const openedSpace = this.trimSTNs(ERROR_MODE_SECONDS_WINDOW); // but maybe we could make some space by discarding irrelevant nodes if we're in sessioned Error mode\n      if (openedSpace === 0) return;\n    }\n    if (this.isStandalone && now() >= MAX_TRACE_DURATION) {\n      return;\n    }\n    if (this.trace[stn.n]) this.trace[stn.n].push(stn);else this.trace[stn.n] = [stn];\n    this.nodeCount++;\n  }\n\n  /**\n   * Trim the collection of nodes awaiting harvest such that those seen outside a certain span of time are discarded.\n   * @param {number} lookbackDuration Past length of time until now for which we care about nodes, in milliseconds\n   * @returns {number} However many nodes were discarded after trimming.\n   */\n  trimSTNs(lookbackDuration) {\n    let prunedNodes = 0;\n    const cutoffHighResTime = Math.max(now() - lookbackDuration, 0);\n    Object.keys(this.trace).forEach(nameCategory => {\n      const nodeList = this.trace[nameCategory];\n      /* Notice nodes are appending under their name's list as they end and are stored. This means each list is already (roughly) sorted in chronological order by end time.\n       * This isn't exact since nodes go through some processing & EE handlers chain, but it's close enough as we still capture nodes whose duration overlaps the lookback window.\n       * ASSUMPTION: all 'end' timings stored are relative to timeOrigin (DOMHighResTimeStamp) and not Unix epoch based. */\n      let cutoffIdx = nodeList.findIndex(node => cutoffHighResTime <= node.e);\n      if (cutoffIdx === 0) return;else if (cutoffIdx < 0) {\n        // whole list falls outside lookback window and is irrelevant\n        cutoffIdx = nodeList.length;\n        delete this.trace[nameCategory];\n      } else nodeList.splice(0, cutoffIdx); // chop off everything outside our window i.e. before the last <lookbackDuration> timeframe\n\n      this.nodeCount -= cutoffIdx;\n      prunedNodes += cutoffIdx;\n    });\n    return prunedNodes;\n  }\n\n  // Used by session trace's harvester to create the payload body.\n  takeSTNs(retry) {\n    if (!this.resourceObserver) {\n      // if PO isn't supported, this checks resourcetiming buffer every harvest.\n      this.storeResources(window.performance.getEntriesByType('resource'));\n    }\n    let earliestTimeStamp = Infinity;\n    const stns = Object.entries(this.trace).flatMap(_ref4 => {\n      let [name, listOfSTNodes] = _ref4;\n      // basically take the \"this.trace\" map-obj and concat all the list-type values\n      const oldestNodeTS = listOfSTNodes.reduce((acc, next) => !acc || next.s < acc ? next.s : acc, undefined);\n      if (oldestNodeTS < earliestTimeStamp) earliestTimeStamp = oldestNodeTS;\n      if (!(name in toAggregate)) return listOfSTNodes;\n      // Special processing for event nodes dealing with user inputs:\n      const reindexByOriginFn = this.smearEvtsByOrigin(name);\n      const partitionListByOriginMap = listOfSTNodes.sort((a, b) => a.s - b.s).reduce(reindexByOriginFn, {});\n      return Object.values(partitionListByOriginMap).flat(); // join the partitions back into 1-D, now ordered by origin then start time\n    }, this);\n    if (stns.length === 0) return {};\n    if (retry) {\n      this.sentTrace = this.trace;\n    }\n    this.trace = {};\n    this.nodeCount = 0;\n    let firstHarvestOfSession;\n    if (this.agentRuntime.session) {\n      const isFirstPayload = !this.agentRuntime.session.state.traceHarvestStarted;\n      firstHarvestOfSession = {\n        fsh: Number(isFirstPayload)\n      }; // converted to '0' | '1'\n      if (isFirstPayload) this.agentRuntime.session.write({\n        traceHarvestStarted: true\n      });\n    }\n    return {\n      qs: {\n        st: this.agentRuntime.offset,\n        /** hr === \"hasReplay\" in NR1, standalone is always checked and processed before harvesting\n         * so a race condition between ST and SR states should not be a concern if implemented here */\n        hr: Number(!this.isStandalone),\n        /** fts === \"firstTimestamp\" in NR1, indicates what the earliest NODE timestamp was\n         * so that blob parsing doesn't need to happen to support UI/API functions  */\n        fts: this.agentRuntime.offset + earliestTimeStamp,\n        /** n === \"nodeCount\" in NR1, a count of nodes in the ST payload, so that blob parsing doesn't need to happen to support UI/API functions */\n        n: stns.length,\n        // node count\n        ...firstHarvestOfSession\n      },\n      body: {\n        res: stns\n      }\n    };\n  }\n  smearEvtsByOrigin(name) {\n    const maxGap = toAggregate[name][0];\n    const maxLen = toAggregate[name][1];\n    const lastO = {};\n    return (byOrigin, evtNode) => {\n      let lastArr = byOrigin[evtNode.o];\n      if (!lastArr) lastArr = byOrigin[evtNode.o] = [];\n      const last = lastO[evtNode.o];\n      if (name === 'scrolling' && !trivial(evtNode)) {\n        lastO[evtNode.o] = null;\n        evtNode.n = 'scroll';\n        lastArr.push(evtNode);\n      } else if (last && evtNode.s - last.s < maxLen && last.e > evtNode.s - maxGap) {\n        last.e = evtNode.e;\n      } else {\n        lastO[evtNode.o] = evtNode;\n        lastArr.push(evtNode);\n      }\n      return byOrigin;\n    };\n    function trivial(node) {\n      const limit = 4;\n      return !!(node && typeof node.e === 'number' && typeof node.s === 'number' && node.e - node.s < limit);\n    }\n  }\n}"],"names":["onReplayReady","sessionReplayInitialized","Promise","resolve","sharedChannel","Object","freeze","HarvestScheduler","_SharedContext","endpoint","opts","parent","_this$sharedContext","_this","_classCallCheck","started","timeoutHandle","aborted","harvest","Harvest","sharedContext","subscribeToEOL","unload","bind","_assertThisInitialized","ee","on","SESSION_EVENTS","runHarvest","forceNoRetry","_inherits","_createClass","key","value","this","onUnload","interval","initialDelay","scheduleHarvest","permanently","arguments","length","undefined","clearTimeout","delay","_this2","setTimeout","_this3","submitMethod","payload","cbRanAfterSend","result","retry","onHarvestFinished","harvests","getPayload","submitData","isFinalHarvest","prototype","toString","call","push","apply","_toConsumableArray","send","args","sendX","raw","_send","forEach","cbFinished","customUrl","onFinished","sent","retryDelay","SharedContext","isWorkerScope","globalScope","origClose","_step","_iterator","_createForOfIteratorHelper","s","n","done","task","err","e","f","cb","isBrowserScope","subscribeToVisibilityChange","windowAddEventListener","HandlerCache","_classPrivateMethodInitSpec","_close","_drain","_classPrivateFieldInitSpec","_decision","writable","_cache","_settleTimer","_classPrivateMethodGet","_close2","_noMoreChanges","handler","_classPrivateFieldGet","decision","_classPrivateFieldSet","_drain2","decide","h","getSessionReplayMode","_x","_getSessionReplayMode","_asyncToGenerator","_regeneratorRuntime","mark","_callee","agentId","newrelic","wrap","_context","prev","next","gosNREUM","getConfigurationValue","initializedAgents","features","session_replay","onAggregateImported","abrupt","t0","MODE","stop","ignoredEvents","global","mouseup","mousedown","window","load","pagehide","xhrOriginMissing","ignoreAll","toAggregate","typing","scrolling","mousing","touching","MAX_TRACE_DURATION","_scheduler","WeakMap","_onHarvestFinished","WeakSet","_prepareHarvest","_laststart","Aggregate","_AggregateBase","agentIdentifier","aggregator","argsObj","FEATURE_NAME","agentRuntime","getRuntime","xhrWrappable","_possibleConstructorReturn","resourceObserver","ptid","trace","nodeCount","sentTrace","harvestTimeSeconds","maxNodesPerHarvest","isStandalone","operationalGate","sessionEntity","session","mostRecentModeKnown","controlTraceOp","traceMode","startTracing","seenAnError","eventType","sessionState","sessionReplayMode","switchToFull","_this2$agentRuntime","state","prevMode","write","sessionTraceMode","trimSTNs","needResponse","registerHandler","featureName","stopTracePerm","_classPrivateFieldGet2","_classPrivateFieldGet3","permanentlyDecide","stopTimer","waitForFlags","then","_ref6","_ref2","_ref7","traceOn","replayMode","startingMode","_slicedToArray","updatedTraceMode","isNew","_ref","_len","Array","_key","settle","storeEvent","_len2","_key2","_this4","storeResources","_len3","_key3","_this5","storeHist","_len4","_key4","_this6","storeXhrAgg","_len5","_key5","_this7","storeSTN","_len6","_key6","_this8","storeErrorAgg","_len7","_key7","_this9","processPVT","drain","startupBuffer","dontStartHarvestYet","PerformanceNavigationTiming","storeTiming","performance","getEntriesByType","timing","_onHarvestFinished2","_prepareHarvest2","name","attrs","_defineProperty","fid","hasFID","type","target","timingEntry","val","lck","toLowerCase","indexOf","Math","round","o","t","currentEvent","start","end","shouldIgnoreEvent","evt","evtName","evtOrigin","event","origin","XMLHttpRequest","params","context","status","method","host","pathname","tagName","id","className","i","classList","document","FileReader","path","old","time","node","resources","_this10","currentResource","fetchStart","parsed","parseUrl","res","initiatorType","responseEnd","protocol","hostname","port","entryType","metrics","message","stackHash","duration","stn","now","lookbackDuration","_this11","prunedNodes","cutoffHighResTime","max","keys","nameCategory","nodeList","cutoffIdx","findIndex","splice","_this12","firstHarvestOfSession","earliestTimeStamp","Infinity","stns","entries","flatMap","_ref4","_ref8","listOfSTNodes","oldestNodeTS","reduce","acc","reindexByOriginFn","smearEvtsByOrigin","partitionListByOriginMap","sort","a","b","values","flat","isFirstPayload","traceHarvestStarted","fsh","Number","qs","_objectSpread","st","offset","hr","fts","body","maxGap","maxLen","lastO","byOrigin","evtNode","lastArr","last","limit","trivial","AggregateBase","_this13","responseText","startTimer","_ref3","_ref9","concat","options","currentMode","takeSTNs"],"sourceRoot":""}